{
  "version": 3,
  "sources": ["../library/src/engine/consts.ts", "../library/src/engine/types.ts", "../library/src/plugins/official/core/attributes/computed.ts", "../library/src/utils/text.ts", "../library/src/plugins/official/core/attributes/signals.ts", "../library/src/plugins/official/core/attributes/star.ts", "../library/src/utils/dom.ts", "../library/src/utils/timing.ts", "../library/src/engine/errors.ts", "../library/src/vendored/preact-core.ts", "../library/src/engine/signals.ts", "../library/src/engine/engine.ts", "../library/src/engine/index.ts", "../library/src/bundles/datastar-core.ts"],
  "sourcesContent": ["// This is auto-generated by Datastar. DO NOT EDIT.\nconst lol = /\uD83D\uDD95JS_DS\uD83D\uDE80/.source\nexport const DSP = lol.slice(0, 5)\nexport const DSS = lol.slice(4)\n\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_EVENT = \"datastar-event\";\nexport const DATASTAR_REQUEST = \"Datastar-Request\";\n\n// #region Defaults\n\n// #region Default durations\n\n// The default duration for settling during fragment merges. Allows for CSS transitions to complete.\nexport const DefaultFragmentsSettleDurationMs = 300;\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000;\n\n// #endregion\n\n\n// #region Default strings\n\n// The default attributes for <script/> element use when executing scripts. It is a set of key-value pairs delimited by a newline \\\\n character.\nexport const DefaultExecuteScriptAttributes = \"type module\";\n\n// #endregion\n\n\n// #region Default booleans\n\n// Should fragments be merged using the ViewTransition API?\nexport const DefaultFragmentsUseViewTransitions = false;\n\n// Should a given set of signals merge if they are missing?\nexport const DefaultMergeSignalsOnlyIfMissing = false;\n\n// Should script element remove itself after execution?\nexport const DefaultExecuteScriptAutoRemove = true;\n\n// #endregion\n\n\n// #region Enums\n\n// The mode in which a fragment is merged into the DOM.\nexport const FragmentMergeModes = {\n    // Morphs the fragment into the existing element using idiomorph.\n    Morph: \"morph\",\n    // Replaces the inner HTML of the existing element.\n    Inner: \"inner\",\n    // Replaces the outer HTML of the existing element.\n    Outer: \"outer\",\n    // Prepends the fragment to the existing element.\n    Prepend: \"prepend\",\n    // Appends the fragment to the existing element.\n    Append: \"append\",\n    // Inserts the fragment before the existing element.\n    Before: \"before\",\n    // Inserts the fragment after the existing element.\n    After: \"after\",\n    // Upserts the attributes of the existing element.\n    UpsertAttributes: \"upsertAttributes\",\n} as const;\n\n// Default value for FragmentMergeMode\nexport const DefaultFragmentMergeMode = FragmentMergeModes.Morph;\n\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\nexport const EventTypes = {\n    // An event for merging HTML fragments into the DOM.\n    MergeFragments: \"datastar-merge-fragments\",\n    // An event for merging signals.\n    MergeSignals: \"datastar-merge-signals\",\n    // An event for removing HTML fragments from the DOM.\n    RemoveFragments: \"datastar-remove-fragments\",\n    // An event for removing signals.\n    RemoveSignals: \"datastar-remove-signals\",\n    // An event for executing <script/> elements in the browser.\n    ExecuteScript: \"datastar-execute-script\",\n} as const;\n// #endregion\n\n// #endregion", "import type { EffectFn, Signal } from '../vendored/preact-core'\nimport { DATASTAR } from './consts'\nimport type { SignalsRoot } from './signals'\n\nexport type OnRemovalFn = () => void\n\nexport enum PluginType {\n  Attribute = 1,\n  Watcher = 2,\n  Action = 3,\n}\n\nexport interface DatastarPlugin {\n  type: PluginType // The type of plugin\n  name: string // The name of the plugin\n}\n\nexport enum Requirement {\n  Allowed = 0,\n  Must = 1,\n  Denied = 2,\n  Exclusive = 3,\n}\n\nexport interface DatastarSignalEvent {\n  added: Array<string>\n  removed: Array<string>\n  updated: Array<string>\n}\nexport const DATASTAR_SIGNAL_EVENT = `${DATASTAR}-signals`\nexport interface CustomEventMap {\n  [DATASTAR_SIGNAL_EVENT]: CustomEvent<DatastarSignalEvent>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\ndeclare global {\n  interface Document {\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n  }\n}\n\n// A plugin accesible via a `data-${name}` attribute on an element\nexport interface AttributePlugin extends DatastarPlugin {\n  type: PluginType.Attribute\n  onGlobalInit?: (ctx: InitContext) => void // Called once on registration of the plugin\n  onLoad: (ctx: RuntimeContext) => OnRemovalFn | void // Return a function to be called on removal\n  removeOnLoad?: (rawKey: string) => boolean // Return whether the attribute key should be removed after onLoad (useful for plugin attributes you don\u2019t want reapplied)\n  mods?: Set<string> // If not provided, all modifiers are allowed\n  keyReq?: Requirement // The rules for the key requirements\n  valReq?: Requirement // The rules for the value requirements\n  argNames?: string[] // argument names for the reactive expression\n}\n\n// A plugin that runs on the global scope of the DastaStar instance\nexport interface WatcherPlugin extends DatastarPlugin {\n  type: PluginType.Watcher\n  onGlobalInit?: (ctx: InitContext) => void\n}\n\nexport type ActionPlugins = Record<string, ActionPlugin>\nexport type ActionMethod = (ctx: RuntimeContext, ...args: any[]) => any\n\nexport interface ActionPlugin extends DatastarPlugin {\n  type: PluginType.Action\n  fn: ActionMethod\n}\n\nexport type GlobalInitializer = (ctx: InitContext) => void\n// export type RemovalEntry = { id: string; fns: Array<OnRemovalFn> }\n\nexport type InitContext = {\n  plugin: DatastarPlugin\n  signals: SignalsRoot\n  effect: (fn: EffectFn) => OnRemovalFn\n  actions: Readonly<ActionPlugins>\n}\n\nexport type HTMLorSVGElement = Element & (HTMLElement | SVGElement)\nexport type Modifiers = Map<string, Set<string>> // mod name -> tags\n\nexport type RuntimeContext = InitContext & {\n  plugin: DatastarPlugin // The name of the plugin\n  el: HTMLorSVGElement // The element the attribute is on\n  rawKey: Readonly<string> // no parsing data-* key\n  key: Readonly<string> // data-* key without the prefix or tags\n  value: Readonly<string> // value of data-* attribute\n  mods: Modifiers // the tags and their arguments\n  genRX: () => <T>(...args: any[]) => T // a reactive expression\n  fnContent?: string // the content of the function\n}\n\nexport type NestedValues = { [key: string]: NestedValues | any }\nexport type NestedSignal = {\n  [key: string]: NestedSignal | Signal<any>\n}\n\nexport type RuntimeExpressionFunction = (\n  ctx: RuntimeContext,\n  ...args: any[]\n) => any\n", "import {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nconst name = 'computed'\nexport const Computed: AttributePlugin = {\n  type: PluginType.Attribute,\n  name,\n  keyReq: Requirement.Must,\n  valReq: Requirement.Must,\n  onLoad: ({ key, signals, genRX }) => {\n    const rx = genRX()\n    signals.setComputed(key, rx)\n  },\n}\n", "export const isBoolString = (str: string) => str.trim() === 'true'\n\nexport const lcFirst = (str: string) =>\n  str[0].toLowerCase() + str.slice(1)\n\nexport const kebabize = (str: string) =>\n  str.replace(\n    /[A-Z]+(?![a-z])|[A-Z]/g,\n    ($, ofs) => (ofs ? '-' : '') + $.toLowerCase(),\n  )\n\nexport const camelize = (str: string) =>\n  kebabize(str).replace(/-./g, (x) => x[1].toUpperCase())\n\nexport const jsStrToObject = (raw: string) =>\n  new Function(`return Object.assign({}, ${raw})`)()\n\nexport const trimDollarSignPrefix = (str: string) =>\n  str.startsWith('$') ? str.slice(1) : str\n", "import {\n  type AttributePlugin,\n  type NestedValues,\n  PluginType,\n} from '../../../../engine/types'\nimport { jsStrToObject } from '../../../../utils/text'\n\nexport const Signals: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'signals',\n  removeOnLoad: () => true,\n  onLoad: (ctx) => {\n    const { key, value, genRX, signals, mods } = ctx\n    const ifMissing = mods.has('ifmissing')\n    if (key !== '' && !ifMissing) {\n      const v = value === '' ? value : genRX()()\n      signals.setValue(key, v)\n    } else {\n      const obj = jsStrToObject(ctx.value)\n      ctx.value = JSON.stringify(obj)\n      const rx = genRX()\n      const nv = rx<NestedValues>()\n      signals.merge(nv, ifMissing)\n    }\n  },\n}\n", "import {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nexport const Star: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'star',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Denied,\n  onLoad: () => {\n    alert('YOU ARE PROBABLY OVERCOMPLICATING IT')\n  },\n}\n", "import { DATASTAR } from '../engine/consts'\n\nexport class Hash {\n  #value = 0\n  #prefix: string\n\n  constructor(prefix = DATASTAR) {\n    this.#prefix = prefix\n  }\n\n  with(x: number | string): Hash {\n    if (typeof x === 'string') {\n      for (const c of x.split('')) {\n        this.with(c.charCodeAt(0))\n      }\n    } else {\n      this.#value = (this.#value << 5) - this.#value + x\n    }\n    return this\n  }\n\n  get value() {\n    return this.#prefix + Math.abs(this.#value).toString(36)\n  }\n}\n\nexport function elUniqId(el: Element) {\n  if (el.id) return el.id\n  const hash = new Hash()\n\n  let currentEl = el\n  while (currentEl.parentNode) {\n    if (currentEl.id) {\n      hash.with(currentEl.id)\n      break\n    }\n    if (currentEl === currentEl.ownerDocument.documentElement) {\n      hash.with(currentEl.tagName)\n    } else {\n      for (\n        let i = 1, e = el;\n        e.previousElementSibling;\n        e = e.previousElementSibling, i++\n      ) {\n        hash.with(i)\n      }\n    }\n\n    currentEl = currentEl.parentNode as Element\n  }\n  return hash.value\n}\n\nexport function onElementRemoved(element: Element, callback: () => void) {\n  const observer = new MutationObserver((mutations) => {\n    for (const mutation of mutations) {\n      for (const removedNode of mutation.removedNodes) {\n        if (removedNode === element) {\n          observer.disconnect()\n          callback()\n          return\n        }\n      }\n    }\n  })\n  observer.observe(element.parentNode as Node, { childList: true })\n}\n", "export type TimerHandler = (...args: any[]) => void\n\nexport function delay(\n  callback: TimerHandler,\n  wait: number,\n): TimerHandler {\n  return (...args: any[]) => {\n    setTimeout(() => {\n      callback(...args)\n    }, wait)\n  }\n}\n\nexport function debounce(\n  callback: TimerHandler,\n  wait: number,\n  leading = false,\n  trailing = true,\n): TimerHandler {\n  let timer = -1\n\n  const resetTimer = () => timer && clearTimeout(timer)\n\n  return (...args: any[]) => {\n    resetTimer()\n\n    if (leading && !timer) {\n      callback(...args)\n    }\n\n    timer = setTimeout(() => {\n      if (trailing) {\n        callback(...args)\n      }\n      resetTimer()\n    }, wait)\n  }\n}\n\nexport function throttle(\n  callback: TimerHandler,\n  wait: number,\n  leading = true,\n  trailing = false,\n): TimerHandler {\n  let waiting = false\n\n  return (...args: any[]) => {\n    if (waiting) return\n\n    if (leading) {\n      callback(...args)\n    }\n\n    waiting = true\n    setTimeout(() => {\n      waiting = false\n      if (trailing) {\n        callback(...args)\n      }\n    }, wait)\n  }\n}\n", "import { kebabize } from '../utils/text'\nimport { DATASTAR } from './consts'\nimport { type InitContext, PluginType, type RuntimeContext } from './types'\n\nconst url = 'https://data-star.dev/errors'\n//const url = `${window.location.origin}/errors`\n\ninterface Metadata {\n  error?: string\n  [key: string]: any\n}\n\nfunction dserr(type: string, reason: string, metadata: Metadata = {}) {\n  const e = new Error()\n  reason = reason[0].toUpperCase() + reason.slice(1)\n  e.name = `${DATASTAR} ${type} error`\n  const r = kebabize(reason).replaceAll('-', '_')\n  const q = new URLSearchParams({\n    metadata: JSON.stringify(metadata),\n  }).toString()\n  const c = JSON.stringify(metadata, null, 2)\n  e.message = `${reason}\\nMore info: ${url}/${type}/${r}?${q}\\nContext: ${c}`\n  return e\n}\n\nexport function internalErr(from: string, reason: string, args = {}) {\n  return dserr('internal', reason, Object.assign({ from }, args))\n}\n\nexport function initErr(reason: string, ctx: InitContext, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: PluginType[ctx.plugin.type],\n    },\n  }\n  return dserr('init', reason, Object.assign(errCtx, metadata))\n}\n\nexport function runtimeErr(reason: string, ctx: RuntimeContext, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: PluginType[ctx.plugin.type],\n    },\n    element: {\n      id: ctx.el.id,\n      tag: ctx.el.tagName,\n    },\n    expression: {\n      rawKey: ctx.rawKey,\n      key: ctx.key,\n      value: ctx.value,\n      validSignals: ctx.signals.paths(),\n      fnContent: ctx.fnContent,\n    },\n  }\n  return dserr('runtime', reason, Object.assign(errCtx, metadata))\n}\n", "import { internalErr } from '../engine/errors'\nimport type { OnRemovalFn } from '../engine/types'\n\nconst from = 'preact-signals'\n\n// An named symbol/brand for detecting Signal instances even when they weren't\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for('preact-signals')\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0\nconst NOTIFIED = 1 << 1\nconst OUTDATED = 1 << 2\nconst DISPOSED = 1 << 3\nconst HAS_ERROR = 1 << 4\nconst TRACKING = 1 << 5\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n  // A source whose value the target depends on.\n  _source: Signal\n  _prevSource?: Node\n  _nextSource?: Node\n\n  // A target that depends on the source and should be notified when the source changes.\n  _target: Computed | Effect\n  _prevTarget?: Node\n  _nextTarget?: Node\n\n  // The version number of the source that target has last seen. We use version numbers\n  // instead of storing the source value, because source values can take arbitrary amount\n  // of memory, and computeds could hang on to them forever because they're lazily evaluated.\n  // Use the special value -1 to mark potentially unused but recyclable nodes.\n  _version: number\n\n  // Used to remember & roll back the source's previous `._node` value when entering &\n  // exiting a new evaluation context.\n  _rollbackNode?: Node\n}\n\nfunction startBatch() {\n  batchDepth++\n}\n\nfunction endBatch() {\n  if (batchDepth > 1) {\n    batchDepth--\n    return\n  }\n\n  let error: unknown\n  let hasError = false\n\n  while (batchedEffect !== undefined) {\n    let effect: Effect | undefined = batchedEffect\n    batchedEffect = undefined\n\n    batchIteration++\n\n    while (effect !== undefined) {\n      const next: Effect | undefined = effect._nextBatchedEffect\n      effect._nextBatchedEffect = undefined\n      effect._flags &= ~NOTIFIED\n\n      if (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n        try {\n          effect._callback()\n        } catch (err) {\n          if (!hasError) {\n            error = err\n            hasError = true\n          }\n        }\n      }\n      effect = next\n    }\n  }\n  batchIteration = 0\n  batchDepth--\n\n  if (hasError) {\n    throw internalErr(from, 'BatchError, error', { error })\n  }\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n  if (batchDepth > 0) {\n    return fn()\n  }\n  /*@__INLINE__**/ startBatch()\n  try {\n    return fn()\n  } finally {\n    endBatch()\n  }\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n  const prevContext = evalContext\n  evalContext = undefined\n  try {\n    return fn()\n  } finally {\n    evalContext = prevContext\n  }\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined\nlet batchDepth = 0\nlet batchIteration = 0\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0\n\nfunction addDependency(signal: Signal): Node | undefined {\n  if (evalContext === undefined) {\n    return undefined\n  }\n\n  let node = signal._node\n  if (node === undefined || node._target !== evalContext) {\n    /**\n     * `signal` is a new dependency. Create a new dependency node, and set it\n     * as the tail of the current context's dependency list. e.g:\n     *\n     * { A <-> B       }\n     *         \u2191     \u2191\n     *        tail  node (new)\n     *               \u2193\n     * { A <-> B <-> C }\n     *               \u2191\n     *              tail (evalContext._sources)\n     */\n    node = {\n      _version: 0,\n      _source: signal,\n      _prevSource: evalContext._sources,\n      _nextSource: undefined,\n      _target: evalContext,\n      _prevTarget: undefined,\n      _nextTarget: undefined,\n      _rollbackNode: node,\n    }\n\n    if (evalContext._sources !== undefined) {\n      evalContext._sources._nextSource = node\n    }\n    evalContext._sources = node\n    signal._node = node\n\n    // Subscribe to change notifications from this dependency if we're in an effect\n    // OR evaluating a computed signal that in turn has subscribers.\n    if (evalContext._flags & TRACKING) {\n      signal._subscribe(node)\n    }\n    return node\n  }\n  if (node._version === -1) {\n    // `signal` is an existing dependency from a previous evaluation. Reuse it.\n    node._version = 0\n\n    /**\n     * If `node` is not already the current tail of the dependency list (i.e.\n     * there is a next node in the list), then make the `node` the new tail. e.g:\n     *\n     * { A <-> B <-> C <-> D }\n     *         \u2191           \u2191\n     *        node   \u250C\u2500\u2500\u2500 tail (evalContext._sources)\n     *         \u2514\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2510\n     *               \u2193     \u2193\n     * { A <-> C <-> D <-> B }\n     *                     \u2191\n     *                    tail (evalContext._sources)\n     */\n    if (node._nextSource !== undefined) {\n      node._nextSource._prevSource = node._prevSource\n\n      if (node._prevSource !== undefined) {\n        node._prevSource._nextSource = node._nextSource\n      }\n\n      node._prevSource = evalContext._sources\n      node._nextSource = undefined\n\n      evalContext._sources!._nextSource = node\n      evalContext._sources = node\n    }\n\n    // We can assume that the currently evaluated effect / computed signal is already\n    // subscribed to change notifications from `signal` if needed.\n    return node\n  }\n  return undefined\n}\n\n/**\n * The base class for plain and computed signals.\n */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style protoTYPEOF_\n// This enables better control of the transpiled output size.\ndeclare class Signal<T = any> {\n  /** @internal */\n  _value: unknown\n\n  /**\n   * @internal\n   * Version numbers should always be >= 0, because the special value -1 is used\n   * by Nodes to signify potentially unused but recyclable nodes.\n   */\n  _version: number\n\n  /** @internal */\n  _node?: Node\n\n  /** @internal */\n  _targets?: Node\n\n  constructor(value?: T)\n\n  /** @internal */\n  _refresh(): boolean\n\n  /** @internal */\n  _subscribe(node: Node): void\n\n  /** @internal */\n  _unsubscribe(node: Node): void\n\n  subscribe(fn: (value: T) => void): () => void\n\n  valueOf(): T\n\n  toString(): string\n\n  toJSON(): T\n\n  peek(): T\n\n  brand: typeof BRAND_SYMBOL\n\n  get value(): T\n  set value(value: T)\n}\n\n/** @internal */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style protoTYPEOF_\n// This enables better control of the transpiled output size.\n// biome-ignore lint/suspicious/noRedeclare: <explanation>\nfunction Signal(this: Signal, value?: unknown) {\n  this._value = value\n  this._version = 0\n  this._node = undefined\n  this._targets = undefined\n}\n\nSignal.prototype.brand = BRAND_SYMBOL\n\nSignal.prototype._refresh = () => true\n\nSignal.prototype._subscribe = function (node) {\n  if (this._targets !== node && node._prevTarget === undefined) {\n    node._nextTarget = this._targets\n    if (this._targets !== undefined) {\n      this._targets._prevTarget = node\n    }\n    this._targets = node\n  }\n}\n\nSignal.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the signal has any subscribers to begin with.\n  if (this._targets !== undefined) {\n    const prev = node._prevTarget\n    const next = node._nextTarget\n    if (prev !== undefined) {\n      prev._nextTarget = next\n      node._prevTarget = undefined\n    }\n    if (next !== undefined) {\n      next._prevTarget = prev\n      node._nextTarget = undefined\n    }\n    if (node === this._targets) {\n      this._targets = next\n    }\n  }\n}\n\nSignal.prototype.subscribe = function (fn) {\n  return effect(() => {\n    const value = this.value\n\n    const prevContext = evalContext\n    evalContext = undefined\n    try {\n      fn(value)\n    } finally {\n      evalContext = prevContext\n    }\n  })\n}\n\nSignal.prototype.valueOf = function () {\n  return this.value\n}\n\nSignal.prototype.toString = function () {\n  return `${this.value}`\n}\n\nSignal.prototype.toJSON = function () {\n  return this.value\n}\n\nSignal.prototype.peek = function () {\n  const prevContext = evalContext\n  evalContext = undefined\n  try {\n    return this.value\n  } finally {\n    evalContext = prevContext\n  }\n}\n\nObject.defineProperty(Signal.prototype, 'value', {\n  get(this: Signal) {\n    const node = addDependency(this)\n    if (node !== undefined) {\n      node._version = this._version\n    }\n    return this._value\n  },\n  set(this: Signal, value) {\n    if (value !== this._value) {\n      if (batchIteration > 100) {\n        throw internalErr(from, 'SignalCycleDetected')\n      }\n\n      this._value = value\n      this._version++\n      globalVersion++\n\n      /**@__INLINE__*/ startBatch()\n      try {\n        for (\n          let node = this._targets;\n          node !== undefined;\n          node = node._nextTarget\n        ) {\n          node._target._notify()\n        }\n      } finally {\n        endBatch()\n      }\n    }\n  },\n})\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T): Signal<T>\nexport function signal<T = undefined>(): Signal<T | undefined>\nexport function signal<T>(value?: T): Signal<T> {\n  return new Signal(value)\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n  // Check the dependencies for changed values. The dependency list is already\n  // in order of use. Therefore if multiple dependencies have changed values, only\n  // the first used dependency is re-evaluated at this point.\n  for (\n    let node = target._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    // If there's a new version of the dependency before or after refreshing,\n    // or the dependency has something blocking it from refreshing at all (e.g. a\n    // dependency cycle), then we need to recompute.\n    if (\n      node._source._version !== node._version ||\n      !node._source._refresh() ||\n      node._source._version !== node._version\n    ) {\n      return true\n    }\n  }\n  // If none of the dependencies have changed values since last recompute then\n  // there's no need to recompute.\n  return false\n}\n\nfunction prepareSources(target: Computed | Effect) {\n  /**\n   * 1. Mark all current sources as re-usable nodes (version: -1)\n   * 2. Set a rollback node if the current node is being used in a different context\n   * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n   *\n   *    { undefined <- A <-> B <-> C -> undefined }\n   *                   \u2191           \u2191\n   *                   \u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   * target._sources = A; (node is head)  \u2502\n   *                   \u2193                  \u2502\n   * target._sources = C; (node is tail) \u2500\u2518\n   */\n  for (\n    let node = target._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    const rollbackNode = node._source._node\n    if (rollbackNode !== undefined) {\n      node._rollbackNode = rollbackNode\n    }\n    node._source._node = node\n    node._version = -1\n\n    if (node._nextSource === undefined) {\n      target._sources = node\n      break\n    }\n  }\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n  let node = target._sources\n  let head: Node | undefined = undefined\n\n  /**\n   * At this point 'target._sources' points to the tail of the doubly-linked list.\n   * It contains all existing sources + new sources in order of use.\n   * Iterate backwards until we find the head node while dropping old dependencies.\n   */\n  while (node !== undefined) {\n    const prev = node._prevSource\n\n    /**\n     * The node was not re-used, unsubscribe from its change notifications and remove itself\n     * from the doubly-linked list. e.g:\n     *\n     * { A <-> B <-> C }\n     *         \u2193\n     *    { A <-> C }\n     */\n    if (node._version === -1) {\n      node._source._unsubscribe(node)\n\n      if (prev !== undefined) {\n        prev._nextSource = node._nextSource\n      }\n      if (node._nextSource !== undefined) {\n        node._nextSource._prevSource = prev\n      }\n    } else {\n      /**\n       * The new head is the last node seen which wasn't removed/unsubscribed\n       * from the doubly-linked list. e.g:\n       *\n       * { A <-> B <-> C }\n       *   \u2191     \u2191     \u2191\n       *   \u2502     \u2502     \u2514 head = node\n       *   \u2502     \u2514 head = node\n       *   \u2514 head = node\n       */\n      head = node\n    }\n\n    node._source._node = node._rollbackNode\n    if (node._rollbackNode !== undefined) {\n      node._rollbackNode = undefined\n    }\n\n    node = prev\n  }\n\n  target._sources = head\n}\n\nexport declare class Computed<T = any> extends Signal<T> {\n  _fn: () => T\n  _sources?: Node\n  _globalVersion: number\n  _flags: number\n\n  constructor(fn: () => T)\n\n  _notify(): void\n  get value(): T\n}\n\n// biome-ignore lint/suspicious/noRedeclare: <explanation>\nexport function Computed(this: Computed, fn: () => unknown) {\n  Signal.call(this, undefined)\n\n  this._fn = fn\n  this._sources = undefined\n  this._globalVersion = globalVersion - 1\n  this._flags = OUTDATED\n}\n\nComputed.prototype = new Signal() as Computed\n\nComputed.prototype._refresh = function () {\n  this._flags &= ~NOTIFIED\n\n  if (this._flags & RUNNING) {\n    return false\n  }\n\n  // If this computed signal has subscribed to updates from its dependencies\n  // (TRACKING flag set) and none of them have notified about changes (OUTDATED\n  // flag not set), then the computed value can't have changed.\n  if ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n    return true\n  }\n  this._flags &= ~OUTDATED\n\n  if (this._globalVersion === globalVersion) {\n    return true\n  }\n  this._globalVersion = globalVersion\n\n  // Mark this computed signal running before checking the dependencies for value\n  // changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n  this._flags |= RUNNING\n  if (this._version > 0 && !needsToRecompute(this)) {\n    this._flags &= ~RUNNING\n    return true\n  }\n\n  const prevContext = evalContext\n  try {\n    prepareSources(this)\n    evalContext = this\n    const value = this._fn()\n    if (\n      this._flags & HAS_ERROR ||\n      this._value !== value ||\n      this._version === 0\n    ) {\n      this._value = value\n      this._flags &= ~HAS_ERROR\n      this._version++\n    }\n  } catch (err) {\n    this._value = err\n    this._flags |= HAS_ERROR\n    this._version++\n  }\n  evalContext = prevContext\n  cleanupSources(this)\n  this._flags &= ~RUNNING\n  return true\n}\n\nComputed.prototype._subscribe = function (node) {\n  if (this._targets === undefined) {\n    this._flags |= OUTDATED | TRACKING\n\n    // A computed signal subscribes lazily to its dependencies when it\n    // gets its first subscriber.\n    for (\n      let node = this._sources;\n      node !== undefined;\n      node = node._nextSource\n    ) {\n      node._source._subscribe(node)\n    }\n  }\n  Signal.prototype._subscribe.call(this, node)\n}\n\nComputed.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the computed signal has any subscribers.\n  if (this._targets !== undefined) {\n    Signal.prototype._unsubscribe.call(this, node)\n\n    // Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n    // This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n    if (this._targets === undefined) {\n      this._flags &= ~TRACKING\n\n      for (\n        let node = this._sources;\n        node !== undefined;\n        node = node._nextSource\n      ) {\n        node._source._unsubscribe(node)\n      }\n    }\n  }\n}\n\nComputed.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= OUTDATED | NOTIFIED\n\n    for (\n      let node = this._targets;\n      node !== undefined;\n      node = node._nextTarget\n    ) {\n      node._target._notify()\n    }\n  }\n}\n\nObject.defineProperty(Computed.prototype, 'value', {\n  get(this: Computed) {\n    if (this._flags & RUNNING) {\n      // Cycle detected\n      throw internalErr(from, 'SignalCycleDetected')\n    }\n    const node = addDependency(this)\n    this._refresh()\n    if (node !== undefined) {\n      node._version = this._version\n    }\n    if (this._flags & HAS_ERROR) {\n      throw internalErr(from, 'GetComputedError', { value: this._value })\n    }\n    return this._value\n  },\n})\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n  readonly value: T\n  peek(): T\n\n  subscribe(fn: (value: T) => void): () => void\n  valueOf(): T\n  toString(): string\n  toJSON(): T\n  brand: typeof BRAND_SYMBOL\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(fn: () => T): ReadonlySignal<T> {\n  return new Computed(fn)\n}\n\nfunction cleanupEffect(effect: Effect) {\n  const cleanup = effect._cleanup\n  effect._cleanup = undefined\n\n  if (typeof cleanup === 'function') {\n    /*@__INLINE__**/ startBatch()\n\n    // Run cleanup functions always outside of any context.\n    const prevContext = evalContext\n    evalContext = undefined\n    try {\n      cleanup!()\n    } catch (error) {\n      effect._flags &= ~RUNNING\n      effect._flags |= DISPOSED\n      disposeEffect(effect)\n      throw internalErr(from, 'CleanupEffectError', { error })\n    } finally {\n      evalContext = prevContext\n      endBatch()\n    }\n  }\n}\n\nfunction disposeEffect(effect: Effect) {\n  for (\n    let node = effect._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    node._source._unsubscribe(node)\n  }\n  effect._fn = undefined\n  effect._sources = undefined\n\n  cleanupEffect(effect)\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n  if (evalContext !== this) {\n    throw internalErr(from, 'EndEffectError')\n  }\n  cleanupSources(this)\n  evalContext = prevContext\n\n  this._flags &= ~RUNNING\n  if (this._flags & DISPOSED) {\n    disposeEffect(this)\n  }\n  endBatch()\n}\n\nexport type EffectFn = () => OnRemovalFn | void | Promise<OnRemovalFn | void>\n\ndeclare class Effect {\n  _fn?: EffectFn\n  _cleanup?: () => void\n  _sources?: Node\n  _nextBatchedEffect?: Effect\n  _flags: number\n\n  constructor(fn: EffectFn)\n\n  _callback(): void\n  _start(): () => void\n  _notify(): void\n  _dispose(): void\n}\n\n// biome-ignore lint/suspicious/noRedeclare: <explanation>\nfunction Effect(this: Effect, fn: EffectFn) {\n  this._fn = fn\n  this._cleanup = undefined\n  this._sources = undefined\n  this._nextBatchedEffect = undefined\n  this._flags = TRACKING\n}\n\nEffect.prototype._callback = function () {\n  const finish = this._start()\n  try {\n    if (this._flags & DISPOSED) return\n    if (this._fn === undefined) return\n\n    const cleanup = this._fn()\n    if (typeof cleanup === 'function') {\n      this._cleanup = cleanup!\n    }\n  } finally {\n    finish()\n  }\n}\n\nEffect.prototype._start = function () {\n  if (this._flags & RUNNING) {\n    throw internalErr(from, 'SignalCycleDetected')\n  }\n  this._flags |= RUNNING\n  this._flags &= ~DISPOSED\n  cleanupEffect(this)\n  prepareSources(this)\n\n  /*@__INLINE__**/ startBatch()\n  const prevContext = evalContext\n  evalContext = this\n  return endEffect.bind(this, prevContext)\n}\n\nEffect.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= NOTIFIED\n    this._nextBatchedEffect = batchedEffect\n    batchedEffect = this\n  }\n}\n\nEffect.prototype._dispose = function () {\n  this._flags |= DISPOSED\n\n  if (!(this._flags & RUNNING)) {\n    disposeEffect(this)\n  }\n}\n\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn): () => void {\n  const effect = new Effect(fn)\n  try {\n    effect._callback()\n  } catch (error) {\n    effect._dispose()\n    // Throw the error, since it is already a Datastar error.\n    throw error\n  }\n  // Return a bound function instead of a wrapper like `() => effect._dispose()`,\n  // because bound functions seem to be just as fast and take up a lot less memory.\n  return effect._dispose.bind(effect)\n}\n\nexport { batch, computed, effect, Signal, untracked }\nexport type { ReadonlySignal }\n", "import { type Computed, Signal, computed } from '../vendored/preact-core'\nimport { internalErr } from './errors'\nimport {\n  DATASTAR_SIGNAL_EVENT,\n  type DatastarSignalEvent,\n  type NestedSignal,\n  type NestedValues,\n} from './types'\n\nconst from = 'namespacedSignals'\n\nconst dispatchSignalEvent = (evt: Partial<DatastarSignalEvent>) => {\n  document.dispatchEvent(\n    new CustomEvent<DatastarSignalEvent>(DATASTAR_SIGNAL_EVENT, {\n      detail: Object.assign({ added: [], removed: [], updated: [] }, evt),\n    }),\n  )\n}\n// If onlyPublic is true, only signals not starting with an underscore are included\nfunction nestedValues(\n  signal: NestedSignal,\n  onlyPublic = false,\n): Record<string, any> {\n  const kv: Record<string, any> = {}\n  for (const key in signal) {\n    if (Object.hasOwn(signal, key)) {\n      if (onlyPublic && key.startsWith('_')) {\n        continue\n      }\n      const value = signal[key]\n      if (value instanceof Signal) {\n        kv[key] = value.value\n      } else {\n        kv[key] = nestedValues(value)\n      }\n    }\n  }\n  return kv\n}\n\nfunction mergeNested(\n  target: NestedValues,\n  values: NestedValues,\n  onlyIfMissing = false,\n) {\n  const evt: DatastarSignalEvent = {\n    added: [],\n    removed: [],\n    updated: [],\n  }\n  for (const key in values) {\n    if (Object.hasOwn(values, key)) {\n      if (key.match(/\\_\\_+/)) {\n        throw internalErr(from, 'InvalidSignalKey', { key })\n      }\n\n      const value = values[key]\n      if (value instanceof Object && !Array.isArray(value)) {\n        if (!target[key]) {\n          target[key] = {}\n        }\n        const subEvt = mergeNested(\n          target[key] as NestedValues,\n          value as NestedValues,\n          onlyIfMissing,\n        )\n        evt.added.push(...subEvt.added.map((k) => `${key}.${k}`))\n        evt.removed.push(...subEvt.removed.map((k) => `${key}.${k}`))\n        evt.updated.push(...subEvt.updated.map((k) => `${key}.${k}`))\n      } else {\n        const hasKey = Object.hasOwn(target, key)\n        if (hasKey) {\n          if (onlyIfMissing) continue\n          const t = target[key]\n          if (t instanceof Signal) {\n            const oldValue = t.value\n            t.value = value\n            if (oldValue !== value) {\n              evt.updated.push(key)\n            }\n            continue\n          }\n        }\n\n        target[key] = new Signal(value)\n        evt.added.push(key)\n      }\n    }\n  }\n  return evt\n}\n\nfunction walkNestedSignal(\n  signal: NestedSignal,\n  cb: (dotDeliminatedPath: string, signal: Signal<any>) => void,\n): void {\n  for (const key in signal) {\n    if (Object.hasOwn(signal, key)) {\n      const value = signal[key]\n      if (value instanceof Signal) {\n        cb(key, value)\n      } else {\n        walkNestedSignal(value, (path, value) => {\n          cb(`${key}.${path}`, value)\n        })\n      }\n    }\n  }\n}\n\n// Recursive function to subset a nested object, each key is a dot-delimited path\nfunction nestedSubset(original: NestedValues, ...keys: string[]): NestedValues {\n  const subset: NestedValues = {}\n  for (const key of keys) {\n    const parts = key.split('.')\n    let subOriginal = original\n    let subSubset = subset\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subOriginal[part]) {\n        return {}\n      }\n      if (!subSubset[part]) {\n        subSubset[part] = {}\n      }\n      subOriginal = subOriginal[part] as NestedValues\n      subSubset = subSubset[part] as NestedValues\n    }\n    const last = parts[parts.length - 1]\n    subSubset[last] = subOriginal[last]\n  }\n  return subset\n}\n\n// Recursively walk a NestedValue with a callback and dot-delimited path\nexport function walkNestedValues(\n  nv: NestedValues,\n  cb: (path: string, value: any) => void,\n) {\n  for (const key in nv) {\n    if (Object.hasOwn(nv, key)) {\n      const value = nv[key]\n      if (value instanceof Object && !Array.isArray(value)) {\n        walkNestedValues(value, (path, value) => {\n          cb(`${key}.${path}`, value)\n        })\n      } else {\n        cb(key, value)\n      }\n    }\n  }\n}\n\nexport class SignalsRoot {\n  #signals: NestedSignal = {}\n\n  exists(dotDelimitedPath: string): boolean {\n    return !!this.signal(dotDelimitedPath)\n  }\n\n  signal<T>(dotDelimitedPath: string): Signal<T> | null {\n    const parts = dotDelimitedPath.split('.')\n    let subSignals = this.#signals\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subSignals[part]) {\n        return null\n      }\n      subSignals = subSignals[part] as NestedSignal\n    }\n    const last = parts[parts.length - 1]\n    const signal = subSignals[last]\n    if (!signal)\n      throw internalErr(from, 'SignalNotFound', { path: dotDelimitedPath })\n    return signal as Signal<T>\n  }\n\n  setSignal<T extends Signal<T>>(dotDelimitedPath: string, signal: T) {\n    const parts = dotDelimitedPath.split('.')\n    let subSignals = this.#signals\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subSignals[part]) {\n        subSignals[part] = {}\n      }\n      subSignals = subSignals[part] as NestedSignal\n    }\n    const last = parts[parts.length - 1]\n    subSignals[last] = signal\n  }\n\n  setComputed<T>(dotDelimitedPath: string, fn: () => T) {\n    const signal = computed(() => fn()) as Computed\n    this.setSignal(dotDelimitedPath, signal)\n  }\n\n  value<T>(dotDelimitedPath: string): T {\n    const signal = this.signal(dotDelimitedPath) as Signal<T>\n    return signal?.value\n  }\n\n  setValue<T>(dotDelimitedPath: string, value: T) {\n    const s = this.upsertIfMissing(dotDelimitedPath, value)\n    const oldValue = s.value\n    s.value = value\n    if (oldValue !== value) {\n      dispatchSignalEvent({ updated: [dotDelimitedPath] })\n    }\n  }\n\n  upsertIfMissing<T>(dotDelimitedPath: string, defaultValue: T) {\n    const parts = dotDelimitedPath.split('.')\n    let subSignals = this.#signals\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subSignals[part]) {\n        subSignals[part] = {}\n      }\n      subSignals = subSignals[part] as NestedSignal\n    }\n    const last = parts[parts.length - 1]\n\n    const current = subSignals[last]\n    if (current instanceof Signal) {\n      return current as Signal<T>\n    }\n\n    const signal = new Signal(defaultValue)\n    subSignals[last] = signal\n\n    dispatchSignalEvent({ added: [dotDelimitedPath] })\n\n    return signal\n  }\n\n  remove(...dotDelimitedPaths: string[]) {\n    if (!dotDelimitedPaths.length) {\n      this.#signals = {}\n      return\n    }\n    const removed = Array<string>()\n    for (const path of dotDelimitedPaths) {\n      const parts = path.split('.')\n      let subSignals = this.#signals\n      for (let i = 0; i < parts.length - 1; i++) {\n        const part = parts[i]\n        if (!subSignals[part]) {\n          return\n        }\n        subSignals = subSignals[part] as NestedSignal\n      }\n      const last = parts[parts.length - 1]\n      delete subSignals[last]\n      removed.push(path)\n    }\n    dispatchSignalEvent({ removed })\n  }\n\n  merge(other: NestedValues, onlyIfMissing = false) {\n    const evt = mergeNested(this.#signals, other, onlyIfMissing)\n    if (evt.added.length || evt.removed.length || evt.updated.length) {\n      dispatchSignalEvent(evt)\n    }\n  }\n\n  subset(...keys: string[]): NestedValues {\n    return nestedSubset(this.values(), ...keys)\n  }\n\n  walk(cb: (name: string, signal: Signal<any>) => void) {\n    walkNestedSignal(this.#signals, cb)\n  }\n\n  paths() {\n    const signalNames = new Array<string>()\n    this.walk((path) => signalNames.push(path))\n    return signalNames\n  }\n\n  values(onlyPublic = false): NestedValues {\n    return nestedValues(this.#signals, onlyPublic)\n  }\n\n  JSON(shouldIndent = true, onlyPublic = false) {\n    const values = this.values(onlyPublic)\n    if (!shouldIndent) {\n      return JSON.stringify(values)\n    }\n    return JSON.stringify(values, null, 2)\n  }\n\n  public toString() {\n    return this.JSON()\n  }\n}\n", "import { Hash, elUniqId } from '../utils/dom'\nimport { camelize, lcFirst } from '../utils/text'\nimport { debounce } from '../utils/timing'\nimport { effect } from '../vendored/preact-core'\nimport { DSP, DSS } from './consts'\nimport { initErr, runtimeErr } from './errors'\nimport { SignalsRoot } from './signals'\nimport {\n  type ActionPlugin,\n  type ActionPlugins,\n  type AttributePlugin,\n  type DatastarPlugin,\n  type GlobalInitializer,\n  type HTMLorSVGElement,\n  type InitContext,\n  type OnRemovalFn,\n  PluginType,\n  Requirement,\n  type RuntimeContext,\n  type RuntimeExpressionFunction,\n  type WatcherPlugin,\n} from './types'\n\nconst removalKey = (k: string, v: string) => `${k}${DSP}${v}`\n\nexport class Engine {\n  aliasPrefix = ''\n  #signals: SignalsRoot = new SignalsRoot()\n  #plugins: AttributePlugin[] = []\n  #actions: ActionPlugins = {}\n  #watchers: WatcherPlugin[] = []\n\n  // Map of cleanup functions by element, keyed by the dataset key and value\n  #removals = new Map<Element, Map<string, OnRemovalFn>>()\n\n  constructor() {\n    const datasetPrefix = 'data-'\n\n    const ob = new MutationObserver((mutations) => {\n      for (const {\n        target,\n        type,\n        attributeName,\n        oldValue,\n        addedNodes,\n        removedNodes,\n      } of mutations) {\n        switch (type) {\n          case 'childList':\n            {\n              for (const node of removedNodes) {\n                const el = node as HTMLorSVGElement\n                const elRemovals = this.#removals.get(el)\n                if (!elRemovals) continue\n\n                for (const [_, removalFn] of elRemovals) {\n                  removalFn()\n                }\n                this.#removals.delete(el)\n              }\n\n              for (const node of addedNodes) {\n                const el = node as HTMLorSVGElement\n                this.#apply(el)\n              }\n            }\n            break\n          case 'attributes': {\n            {\n              const requiredPrefix = datasetPrefix + (this.aliasPrefix ? `${this.aliasPrefix}-` : '')\n              if (!attributeName?.startsWith(requiredPrefix)) {\n                break\n              }\n\n              const el = target as HTMLorSVGElement\n              const datasetKey = camelize(attributeName.slice(datasetPrefix.length))\n\n              // If the value has changed, clean up the old value\n              if (oldValue !== null && el.dataset[datasetKey] !== oldValue) {\n                const elRemovals = this.#removals.get(el)\n                if (elRemovals) {\n                  const rk = removalKey(datasetKey, oldValue)\n                  const removalFn = elRemovals.get(rk)\n                  if (removalFn) {\n                    removalFn()\n                    elRemovals.delete(rk)\n                  }\n                }\n              }\n\n              // Apply the plugin only if the dataset key exists\n              if (datasetKey in el.dataset) {\n                this.#applyAttributePlugin(el, datasetKey)\n              }\n            }\n            break\n          }\n        }\n      }\n    })\n\n    ob.observe(document.body, {\n      attributes: true,\n      attributeOldValue: true,\n      childList: true,\n      subtree: true,\n    })\n  }\n\n  get signals() {\n    return this.#signals\n  }\n\n  public load(...pluginsToLoad: DatastarPlugin[]) {\n    for (const plugin of pluginsToLoad) {\n      const that = this // I hate javascript\n      const ctx: InitContext = {\n        get signals() {\n          return that.#signals\n        },\n        effect: (cb: () => void): OnRemovalFn => effect(cb),\n        actions: this.#actions,\n        plugin,\n      }\n\n      let globalInitializer: GlobalInitializer | undefined\n      switch (plugin.type) {\n        case PluginType.Watcher: {\n          const wp = plugin as WatcherPlugin\n          this.#watchers.push(wp)\n          globalInitializer = wp.onGlobalInit\n          break\n        }\n        case PluginType.Action: {\n          this.#actions[plugin.name] = plugin as ActionPlugin\n          break\n        }\n        case PluginType.Attribute: {\n          const ap = plugin as AttributePlugin\n          this.#plugins.push(ap)\n          globalInitializer = ap.onGlobalInit\n          break\n        }\n        default: {\n          throw initErr('InvalidPluginType', ctx)\n        }\n      }\n      if (globalInitializer) {\n        globalInitializer(ctx)\n      }\n    }\n\n    // Sort attribute plugins by descending length then alphabetically\n    this.#plugins.sort((a, b) => {\n      const lenDiff = b.name.length - a.name.length\n      if (lenDiff !== 0) return lenDiff\n      return a.name.localeCompare(b.name)\n    })\n\n    this.#debouncedApply()\n  }\n\n  #debouncedApply = debounce(() => {\n    this.#apply(document.body)\n  }, 1)\n\n  // Apply all plugins to the element and its children\n  #apply(rootElement: Element) {\n    this.#walkDownDOM(rootElement, (el) => {\n      // Cleanup any existing removal functions\n      const elRemovals = this.#removals.get(el)\n      if (elRemovals) {\n        for (const [, removalFn] of elRemovals) {\n          removalFn()\n        }\n        this.#removals.delete(el)\n      }\n\n      // Apply the plugins to the element in order of application\n      // since DOMStringMap is ordered, we can be deterministic\n      for (const datasetKey of Object.keys(el.dataset)) {\n        this.#applyAttributePlugin(el, datasetKey)\n      }\n    })\n  }\n\n  #applyAttributePlugin(el: HTMLorSVGElement, datasetKey: string) {\n    // Extract the raw key from the dataset\n    const rawKey = lcFirst(datasetKey.slice(this.aliasPrefix.length))\n\n    // Find the plugin that matches, since the plugins are sorted by length descending and alphabetically\n    // the first match will be the most specific\n    const plugin = this.#plugins.find((p) => rawKey.startsWith(p.name))\n\n    // Skip if no plugin is found\n    if (!plugin) return\n\n    // Ensure the element has an id\n    if (!el.id.length) el.id = elUniqId(el)\n\n    // Extract the key and modifiers\n    let [key, ...rawModifiers] = rawKey.slice(plugin.name.length).split(/\\_\\_+/)\n\n    const hasKey = key.length > 0\n    if (hasKey) {\n      // Keys starting with a dash are not converted to camel case in the dataset\n      key = key.startsWith('-') ? key.slice(1) : lcFirst(key)\n    }\n    const value = el.dataset[datasetKey] || ''\n    const hasValue = value.length > 0\n\n    // Create the runtime context\n    const that = this // I hate javascript\n    const ctx: RuntimeContext = {\n      get signals() {\n        return that.#signals\n      },\n      effect: (cb: () => void): OnRemovalFn => effect(cb),\n      actions: this.#actions,\n      genRX: () => this.#genRX(ctx, ...(plugin.argNames || [])),\n      plugin,\n      el,\n      rawKey,\n      key,\n      value,\n      mods: new Map(),\n    }\n\n    // Check the requirements\n    const keyReq = plugin.keyReq || Requirement.Allowed\n    if (hasKey) {\n      if (keyReq === Requirement.Denied) {\n        throw runtimeErr(`${plugin.name}KeyNotAllowed`, ctx)\n      }\n    } else if (keyReq === Requirement.Must) {\n      throw runtimeErr(`${plugin.name}KeyRequired`, ctx)\n    }\n    const valReq = plugin.valReq || Requirement.Allowed\n    if (hasValue) {\n      if (valReq === Requirement.Denied) {\n        throw runtimeErr(`${plugin.name}ValueNotAllowed`, ctx)\n      }\n    } else if (valReq === Requirement.Must) {\n      throw runtimeErr(`${plugin.name}ValueRequired`, ctx)\n    }\n\n    // Check for exclusive requirements\n    if (keyReq === Requirement.Exclusive || valReq === Requirement.Exclusive) {\n      if (hasKey && hasValue) {\n        throw runtimeErr(`${plugin.name}KeyAndValueProvided`, ctx)\n      }\n      if (!hasKey && !hasValue) {\n        throw runtimeErr(`${plugin.name}KeyOrValueRequired`, ctx)\n      }\n    }\n\n    for (const rawMod of rawModifiers) {\n      const [label, ...mod] = rawMod.split('.')\n      ctx.mods.set(camelize(label), new Set(mod.map((t) => t.toLowerCase())))\n    }\n\n    // Load the plugin and store any cleanup functions\n    const removalFn = plugin.onLoad(ctx)\n    if (removalFn) {\n      let elRemovals = this.#removals.get(el)\n      if (!elRemovals) {\n        elRemovals = new Map()\n        this.#removals.set(el, elRemovals)\n      }\n      elRemovals.set(removalKey(datasetKey, value), removalFn)\n    }\n\n    // Remove the attribute if required\n    const removeOnLoad = plugin.removeOnLoad\n    if (removeOnLoad && removeOnLoad(rawKey) === true) {\n      delete el.dataset[datasetKey]\n    }\n  }\n\n  #genRX(\n    ctx: RuntimeContext,\n    ...argNames: string[]\n  ): RuntimeExpressionFunction {\n    let userExpression = ''\n\n    // This regex allows Datastar expressions to support nested\n    // regex and strings that contain ; without breaking.\n    //\n    // Each of these regex defines a block type we want to match\n    // (importantly we ignore the content within these blocks):\n    //\n    // regex            \\/(\\\\\\/|[^\\/])*\\/\n    // double quotes      \"(\\\\\"|[^\\\"])*\"\n    // single quotes      '(\\\\'|[^'])*'\n    // ticks              `(\\\\`|[^`])*`\n    //\n    // We also want to match the non delimiter part of statements\n    // note we only support ; statement delimiters:\n    //\n    // [^;]\n    //\n    const statementRe =\n      /(\\/(\\\\\\/|[^\\/])*\\/|\"(\\\\\"|[^\\\"])*\"|'(\\\\'|[^'])*'|`(\\\\`|[^`])*`|[^;])+/gm\n    const statements = ctx.value.trim().match(statementRe)\n    if (statements) {\n      const lastIdx = statements.length - 1\n      const last = statements[lastIdx].trim()\n      if (!last.startsWith('return')) {\n        statements[lastIdx] = `return (${last});`\n      }\n      userExpression = statements.join(';\\n')\n    }\n\n    // Ignore any escaped values\n    const escaped = new Map<string, string>()\n    const escapeRe = new RegExp(`(?:${DSP})(.*?)(?:${DSS})`, 'gm')\n    for (const match of userExpression.matchAll(escapeRe)) {\n      const k = match[1]\n      const v = new Hash('dsEscaped').with(k).value\n      escaped.set(v, k)\n      userExpression = userExpression.replace(DSP + k + DSS, v)\n    }\n\n    const fnCall = /@(\\w*)\\(/gm\n    const matches = userExpression.matchAll(fnCall)\n    const methodsCalled = new Set<string>()\n    for (const match of matches) {\n      methodsCalled.add(match[1])\n    }\n\n    // Replace any action calls\n    const actionsRe = new RegExp(\n      `@(${Object.keys(this.#actions).join('|')})\\\\(`,\n      'gm',\n    )\n\n    // Add ctx to action calls\n    userExpression = userExpression.replaceAll(\n      actionsRe,\n      'ctx.actions.$1.fn(ctx,',\n    )\n\n    // Replace any signal calls\n    const signalNames = ctx.signals.paths()\n    if (signalNames.length) {\n      // Match any valid `$signalName` followed by a non-word character or end of string\n      const signalsRe = new RegExp(`\\\\$(${signalNames.join('|')})(\\\\W|$)`, 'gm')\n      userExpression = userExpression.replaceAll(\n        signalsRe,\n        `ctx.signals.signal('$1').value$2`,\n      )\n    }\n\n    // Replace any escaped values\n    for (const [k, v] of escaped) {\n      userExpression = userExpression.replace(k, v)\n    }\n\n    const fnContent = `return (()=> {\\n${userExpression}\\n})()` // Wrap in IIFE\n    ctx.fnContent = fnContent\n\n    try {\n      const fn = new Function('ctx', ...argNames, fnContent)\n      return (...args: any[]) => {\n        try {\n          return fn(ctx, ...args)\n        } catch (error: any) {\n          throw runtimeErr('ExecuteExpression', ctx, {\n            error: error.message,\n          })\n        }\n      }\n    } catch (error: any) {\n      throw runtimeErr('GenerateExpression', ctx, {\n        error: error.message,\n      })\n    }\n  }\n\n  #walkDownDOM(\n    element: Element | null,\n    callback: (el: HTMLorSVGElement) => void,\n  ) {\n    if (\n      !element ||\n      !(element instanceof HTMLElement || element instanceof SVGElement)\n    ) {\n      return null\n    }\n    const dataset = element.dataset\n    if ('starIgnore' in dataset) {\n      return null\n    }\n    if (!('starIgnore__self' in dataset)) {\n      callback(element)\n    }\n    let el = element.firstElementChild\n    while (el) {\n      this.#walkDownDOM(el, callback)\n      el = el.nextElementSibling\n    }\n  }\n}\n", "import { DSP } from '../engine/consts'\n// @ts-ignore\nconst _ = DSP // This is to force the import of DSP first in the compiled code\n\nimport { Computed } from '../plugins/official/core/attributes/computed'\nimport { Signals } from '../plugins/official/core/attributes/signals'\nimport { Star } from '../plugins/official/core/attributes/star'\nimport { Engine } from './engine'\n\nconst DS = new Engine()\nDS.load(Star, Signals, Computed)\nexport const Datastar = DS\n", "import { Datastar as DS } from '../engine'\n\nexport const Datastar = DS\n"],
  "mappings": "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",
  "names": ["lol", "DSP", "DSS", "DATASTAR", "FragmentMergeModes", "DefaultFragmentMergeMode", "PluginType", "DATASTAR_SIGNAL_EVENT", "DATASTAR", "name", "Computed", "key", "signals", "genRX", "rx", "lcFirst", "str", "kebabize", "$", "ofs", "camelize", "x", "jsStrToObject", "raw", "Signals", "ctx", "key", "value", "genRX", "signals", "mods", "ifMissing", "v", "obj", "jsStrToObject", "nv", "Star", "Hash", "#value", "#prefix", "prefix", "DATASTAR", "x", "c", "elUniqId", "el", "hash", "currentEl", "i", "e", "debounce", "callback", "wait", "leading", "trailing", "timer", "resetTimer", "args", "url", "dserr", "type", "reason", "metadata", "e", "DATASTAR", "kebabize", "q", "c", "internalErr", "from", "args", "initErr", "ctx", "errCtx", "PluginType", "runtimeErr", "from", "BRAND_SYMBOL", "RUNNING", "NOTIFIED", "OUTDATED", "DISPOSED", "HAS_ERROR", "TRACKING", "startBatch", "batchDepth", "endBatch", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "needsToRecompute", "err", "internalErr", "evalContext", "batchedEffect", "batchDepth", "batchIteration", "globalVersion", "addDependency", "signal", "evalContext", "node", "TRACKING", "Signal", "value", "BRAND_SYMBOL", "prev", "next", "fn", "effect", "prevContext", "internalErr", "from", "startBatch", "endBatch", "needsToRecompute", "target", "node", "prepareSources", "rollbackNode", "cleanupSources", "head", "prev", "Computed", "fn", "Signal", "globalVersion", "OUTDATED", "NOTIFIED", "RUNNING", "TRACKING", "prevContext", "evalContext", "value", "HAS_ERROR", "err", "internalErr", "from", "addDependency", "computed", "cleanupEffect", "effect", "cleanup", "startBatch", "error", "DISPOSED", "disposeEffect", "endBatch", "endEffect", "Effect", "finish", "batchedEffect", "from", "dispatchSignalEvent", "evt", "DATASTAR_SIGNAL_EVENT", "nestedValues", "signal", "onlyPublic", "kv", "key", "value", "Signal", "mergeNested", "target", "values", "onlyIfMissing", "internalErr", "subEvt", "k", "t", "oldValue", "walkNestedSignal", "cb", "path", "nestedSubset", "original", "keys", "subset", "parts", "subOriginal", "subSubset", "i", "part", "last", "SignalsRoot", "#signals", "dotDelimitedPath", "parts", "subSignals", "i", "part", "last", "signal", "internalErr", "from", "fn", "computed", "value", "oldValue", "dispatchSignalEvent", "defaultValue", "current", "Signal", "dotDelimitedPaths", "removed", "path", "other", "onlyIfMissing", "evt", "mergeNested", "keys", "nestedSubset", "cb", "walkNestedSignal", "signalNames", "onlyPublic", "nestedValues", "shouldIndent", "values", "removalKey", "k", "v", "DSP", "Engine", "#signals", "SignalsRoot", "#plugins", "#actions", "#watchers", "#removals", "#debouncedApply", "debounce", "#apply", "datasetPrefix", "mutations", "target", "type", "attributeName", "oldValue", "addedNodes", "removedNodes", "node", "el", "elRemovals", "removalFn", "requiredPrefix", "datasetKey", "camelize", "rk", "#applyAttributePlugin", "pluginsToLoad", "plugin", "that", "ctx", "cb", "effect", "globalInitializer", "wp", "ap", "initErr", "a", "b", "lenDiff", "rootElement", "#walkDownDOM", "rawKey", "lcFirst", "p", "elUniqId", "key", "rawModifiers", "hasKey", "value", "hasValue", "#genRX", "keyReq", "runtimeErr", "valReq", "rawMod", "label", "mod", "t", "removeOnLoad", "argNames", "userExpression", "statementRe", "statements", "lastIdx", "last", "escaped", "escapeRe", "DSS", "match", "Hash", "fnCall", "matches", "methodsCalled", "actionsRe", "signalNames", "signalsRe", "fnContent", "fn", "args", "error", "element", "callback", "dataset", "DS", "Engine", "Star", "Signals", "Computed", "Datastar", "Datastar"]
}
