{
  "version": 3,
  "sources": ["../library/src/engine/consts.ts", "../library/src/engine/types.ts", "../library/src/utils/text.ts", "../library/src/plugins/official/core/attributes/computed.ts", "../library/src/plugins/official/core/attributes/signals.ts", "../library/src/plugins/official/core/attributes/star.ts", "../library/src/utils/dom.ts", "../library/src/engine/errors.ts", "../library/src/vendored/preact-core.ts", "../library/src/engine/signals.ts", "../library/src/engine/engine.ts", "../library/src/engine/index.ts", "../library/src/bundles/datastar-core.ts"],
  "sourcesContent": ["// This is auto-generated by Datastar. DO NOT EDIT.\nconst lol = /\uD83D\uDD95JS_DS\uD83D\uDE80/.source\nexport const DSP = lol.slice(0, 5)\nexport const DSS = lol.slice(4)\n\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_REQUEST = \"Datastar-Request\";\n\n// #region Defaults\n\n// #region Default durations\n\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000;\n\n// #endregion\n\n\n// #region Default strings\n\n// The default attributes for <script/> element use when executing scripts. It is a set of key-value pairs delimited by a newline \\\\n character.\nexport const DefaultExecuteScriptAttributes = \"type module\";\n\n// #endregion\n\n\n// #region Default booleans\n\n// Should fragments be merged using the ViewTransition API?\nexport const DefaultFragmentsUseViewTransitions = false;\n\n// Should a given set of signals merge if they are missing?\nexport const DefaultMergeSignalsOnlyIfMissing = false;\n\n// Should script element remove itself after execution?\nexport const DefaultExecuteScriptAutoRemove = true;\n\n// #endregion\n\n\n// #region Enums\n\n// The mode in which a fragment is merged into the DOM.\nexport const FragmentMergeModes = {\n    // Morphs the fragment into the existing element using idiomorph.\n    Morph: \"morph\",\n    // Replaces the inner HTML of the existing element.\n    Inner: \"inner\",\n    // Replaces the outer HTML of the existing element.\n    Outer: \"outer\",\n    // Prepends the fragment to the existing element.\n    Prepend: \"prepend\",\n    // Appends the fragment to the existing element.\n    Append: \"append\",\n    // Inserts the fragment before the existing element.\n    Before: \"before\",\n    // Inserts the fragment after the existing element.\n    After: \"after\",\n    // Upserts the attributes of the existing element.\n    UpsertAttributes: \"upsertAttributes\",\n} as const;\n\n// Default value for FragmentMergeMode\nexport const DefaultFragmentMergeMode = FragmentMergeModes.Morph;\n\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\nexport const EventTypes = {\n    // An event for merging HTML fragments into the DOM.\n    MergeFragments: \"datastar-merge-fragments\",\n    // An event for merging signals.\n    MergeSignals: \"datastar-merge-signals\",\n    // An event for removing HTML fragments from the DOM.\n    RemoveFragments: \"datastar-remove-fragments\",\n    // An event for removing signals.\n    RemoveSignals: \"datastar-remove-signals\",\n    // An event for executing <script/> elements in the browser.\n    ExecuteScript: \"datastar-execute-script\",\n} as const;\n// #endregion\n\n// #endregion", "import type { EffectFn, Signal } from '../vendored/preact-core'\nimport { DATASTAR } from './consts'\nimport type { SignalsRoot } from './signals'\n\nexport type OnRemovalFn = () => void\n\nexport enum PluginType {\n  Attribute = 1,\n  Watcher = 2,\n  Action = 3,\n}\n\nexport interface DatastarPlugin {\n  type: PluginType // The type of plugin\n  name: string // The name of the plugin\n}\n\nexport enum Requirement {\n  Allowed = 0,\n  Must = 1,\n  Denied = 2,\n  Exclusive = 3,\n}\n\nexport interface DatastarSignalEvent {\n  added: Array<string>\n  removed: Array<string>\n  updated: Array<string>\n}\nexport const DATASTAR_SIGNAL_EVENT = `${DATASTAR}-signals`\nexport interface CustomEventMap {\n  [DATASTAR_SIGNAL_EVENT]: CustomEvent<DatastarSignalEvent>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\ndeclare global {\n  interface Document {\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n  }\n}\n\n// A plugin accesible via a `data-${name}` attribute on an element\nexport interface AttributePlugin extends DatastarPlugin {\n  type: PluginType.Attribute\n  onGlobalInit?: (ctx: InitContext) => void // Called once on registration of the plugin\n  onLoad: (ctx: RuntimeContext) => OnRemovalFn | void // Return a function to be called on removal\n  keyReq?: Requirement // The rules for the key requirements\n  valReq?: Requirement // The rules for the value requirements\n  argNames?: string[] // argument names for the reactive expression\n}\n\n// A plugin that runs on the global scope of the DastaStar instance\nexport interface WatcherPlugin extends DatastarPlugin {\n  type: PluginType.Watcher\n  onGlobalInit?: (ctx: InitContext) => void\n}\n\nexport type ActionPlugins = Record<string, ActionPlugin>\nexport type ActionMethod = (ctx: RuntimeContext, ...args: any[]) => any\n\nexport interface ActionPlugin extends DatastarPlugin {\n  type: PluginType.Action\n  fn: ActionMethod\n}\n\nexport type GlobalInitializer = (ctx: InitContext) => void\n\nexport type InitContext = {\n  plugin: DatastarPlugin\n  signals: SignalsRoot\n  effect: (fn: EffectFn) => OnRemovalFn\n  actions: Readonly<ActionPlugins>\n  removals: Map<string, Map<number, OnRemovalFn>>\n  applyToElement: (el: HTMLorSVGElement) => void\n}\n\nexport type HTMLorSVGElement = Element & (HTMLElement | SVGElement)\nexport type Modifiers = Map<string, Set<string>> // mod name -> tags\n\nexport type RuntimeContext = InitContext & {\n  plugin: DatastarPlugin // The name of the plugin\n  el: HTMLorSVGElement // The element the attribute is on\n  rawKey: Readonly<string> // no parsing data-* key\n  key: Readonly<string> // data-* key without the prefix or tags\n  value: Readonly<string> // value of data-* attribute\n  mods: Modifiers // the tags and their arguments\n  genRX: () => <T>(...args: any[]) => T // a reactive expression\n  fnContent?: string // the content of the function\n}\n\nexport type NestedValues = { [key: string]: NestedValues | any }\nexport type NestedSignal = {\n  [key: string]: NestedSignal | Signal<any>\n}\n\nexport type RuntimeExpressionFunction = (\n  ctx: RuntimeContext,\n  ...args: any[]\n) => any\n\nexport type EventCallbackHandler = (...args: any[]) => void\n", "import type { Modifiers } from '../engine/types'\n\nexport const isBoolString = (str: string) => str.trim() === 'true'\n\nexport const kebab = (str: string) =>\n  str.replace(\n    /[A-Z]+(?![a-z])|[A-Z]/g,\n    ($, ofs) => (ofs ? '-' : '') + $.toLowerCase(),\n  )\n\nexport const camel = (str: string) =>\n  kebab(str).replace(/-./g, (x) => x[1].toUpperCase())\n\nexport const snake = (str: string) => kebab(str).replace(/-/g, '_')\n\nexport const pascal = (str: string) =>\n  camel(str).replace(/^./, (x) => x[0].toUpperCase())\n\nexport const jsStrToObject = (raw: string) =>\n  new Function(`return Object.assign({}, ${raw})`)()\n\nexport const trimDollarSignPrefix = (str: string) =>\n  str.startsWith('$') ? str.slice(1) : str\n\nconst caseFns: Record<string, (s: string) => string> = { kebab, snake, pascal }\n\nexport function modifyCasing(str: string, mods: Modifiers) {\n  for (const c of mods.get('case') || []) {\n    const fn = caseFns[c]\n    if (fn) str = fn(str)\n  }\n  return str\n}\n", "import {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { modifyCasing } from '../../../../utils/text'\n\nconst name = 'computed'\nexport const Computed: AttributePlugin = {\n  type: PluginType.Attribute,\n  name,\n  keyReq: Requirement.Must,\n  valReq: Requirement.Must,\n  onLoad: ({ key, mods, signals, genRX }) => {\n    key = modifyCasing(key, mods)\n    const rx = genRX()\n    signals.setComputed(key, rx)\n  },\n}\n", "import {\n  type AttributePlugin,\n  type NestedValues,\n  PluginType,\n} from '../../../../engine/types'\nimport { jsStrToObject, modifyCasing } from '../../../../utils/text'\n\nexport const Signals: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'signals',\n  onLoad: (ctx) => {\n    const { key, mods, signals, value, genRX } = ctx\n    const ifMissing = mods.has('ifmissing')\n\n    if (key !== '') {\n      const k = modifyCasing(key, mods)\n      const v = value === '' ? value : genRX()()\n      if (ifMissing) {\n        signals.upsertIfMissing(k, v)\n      } else {\n        signals.setValue(k, v)\n      }\n    } else {\n      const obj = jsStrToObject(ctx.value)\n      ctx.value = JSON.stringify(obj)\n      const rx = genRX()\n      const nv = rx<NestedValues>()\n      signals.merge(nv, ifMissing)\n    }\n  },\n}\n", "import {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nexport const Star: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'star',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Denied,\n  onLoad: () => {\n    alert('YOU ARE PROBABLY OVERCOMPLICATING IT')\n  },\n}\n", "import { DATASTAR } from '../engine/consts'\nimport type { HTMLorSVGElement } from '../engine/types'\n\nexport class Hash {\n  #value = 0\n  #prefix: string\n\n  constructor(prefix = DATASTAR) {\n    this.#prefix = prefix\n  }\n\n  with(x: number | string | boolean): Hash {\n    if (typeof x === 'string') {\n      for (const c of x.split('')) {\n        this.with(c.charCodeAt(0))\n      }\n    } else if (typeof x === 'boolean') {\n      this.with(1 << (x ? 7 : 3))\n    } else {\n      // use djb2 favored by bernstein http://www.cse.yorku.ca/~oz/hash.html\n      this.#value = (this.#value * 33) ^ x\n    }\n    return this\n  }\n\n  get value() {\n    return this.#value\n  }\n\n  get string() {\n    return this.#prefix + Math.abs(this.#value).toString(36)\n  }\n}\n\nexport function elUniqId(el: Element) {\n  if (el.id) return el.id\n  const hash = new Hash()\n\n  let currentEl = el\n  while (currentEl) {\n    hash.with(currentEl.tagName || '')\n    if (currentEl.id) {\n      hash.with(currentEl.id)\n      break\n    }\n    const p = currentEl?.parentNode\n    if (p) hash.with([...p.children].indexOf(currentEl))\n\n    currentEl = p as Element\n  }\n  return hash.string\n}\n\nexport function attrHash(key: number | string, val: number | string) {\n  return new Hash().with(key).with(val).value\n}\n\nexport function walkDOM(\n  element: Element | null,\n  callback: (el: HTMLorSVGElement) => void,\n) {\n  if (\n    !element ||\n    !(element instanceof HTMLElement || element instanceof SVGElement)\n  ) {\n    return null\n  }\n  const dataset = element.dataset\n  if ('starIgnore' in dataset) {\n    return null\n  }\n  if (!('starIgnore__self' in dataset)) {\n    callback(element)\n  }\n  let el = element.firstElementChild\n  while (el) {\n    walkDOM(el, callback)\n    el = el.nextElementSibling\n  }\n}\n", "import { snake } from '../utils/text'\nimport { DATASTAR } from './consts'\nimport { type InitContext, PluginType, type RuntimeContext } from './types'\n\nconst url = 'https://data-star.dev/errors'\n\ninterface Metadata {\n  error?: string\n  [key: string]: any\n}\n\nfunction dserr(type: string, reason: string, metadata: Metadata = {}) {\n  const e = new Error()\n  e.name = `${DATASTAR} ${type} error`\n  const r = snake(reason)\n  const q = new URLSearchParams({\n    metadata: JSON.stringify(metadata),\n  }).toString()\n  const c = JSON.stringify(metadata, null, 2)\n  e.message = `${reason}\\nMore info: ${url}/${type}/${r}?${q}\\nContext: ${c}`\n  return e\n}\n\nexport function internalErr(from: string, reason: string, args = {}) {\n  return dserr('internal', reason, Object.assign({ from }, args))\n}\n\nexport function initErr(reason: string, ctx: InitContext, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: PluginType[ctx.plugin.type],\n    },\n  }\n  return dserr('init', reason, Object.assign(errCtx, metadata))\n}\n\nexport function runtimeErr(reason: string, ctx: RuntimeContext, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: PluginType[ctx.plugin.type],\n    },\n    element: {\n      id: ctx.el.id,\n      tag: ctx.el.tagName,\n    },\n    expression: {\n      rawKey: ctx.rawKey,\n      key: ctx.key,\n      value: ctx.value,\n      validSignals: ctx.signals.paths(),\n      fnContent: ctx.fnContent,\n    },\n  }\n  return dserr('runtime', reason, Object.assign(errCtx, metadata))\n}\n", "import { internalErr } from '../engine/errors'\nimport type { OnRemovalFn } from '../engine/types'\n\nconst from = 'preact-signals'\n\n// An named symbol/brand for detecting Signal instances even when they weren't\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for('preact-signals')\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0\nconst NOTIFIED = 1 << 1\nconst OUTDATED = 1 << 2\nconst DISPOSED = 1 << 3\nconst HAS_ERROR = 1 << 4\nconst TRACKING = 1 << 5\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n  // A source whose value the target depends on.\n  _source: Signal\n  _prevSource?: Node\n  _nextSource?: Node\n\n  // A target that depends on the source and should be notified when the source changes.\n  _target: Computed | Effect\n  _prevTarget?: Node\n  _nextTarget?: Node\n\n  // The version number of the source that target has last seen. We use version numbers\n  // instead of storing the source value, because source values can take arbitrary amount\n  // of memory, and computeds could hang on to them forever because they're lazily evaluated.\n  // Use the special value -1 to mark potentially unused but recyclable nodes.\n  _version: number\n\n  // Used to remember & roll back the source's previous `._node` value when entering &\n  // exiting a new evaluation context.\n  _rollbackNode?: Node\n}\n\nfunction startBatch() {\n  batchDepth++\n}\n\nfunction endBatch() {\n  if (batchDepth > 1) {\n    batchDepth--\n    return\n  }\n\n  let error: unknown\n  let hasError = false\n\n  while (batchedEffect !== undefined) {\n    let effect: Effect | undefined = batchedEffect\n    batchedEffect = undefined\n\n    batchIteration++\n\n    while (effect !== undefined) {\n      const next: Effect | undefined = effect._nextBatchedEffect\n      effect._nextBatchedEffect = undefined\n      effect._flags &= ~NOTIFIED\n\n      if (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n        try {\n          effect._callback()\n        } catch (err) {\n          if (!hasError) {\n            error = err\n            hasError = true\n          }\n        }\n      }\n      effect = next\n    }\n  }\n  batchIteration = 0\n  batchDepth--\n\n  if (hasError) throw error\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n  if (batchDepth > 0) {\n    return fn()\n  }\n  /*@__INLINE__**/ startBatch()\n  try {\n    return fn()\n  } finally {\n    endBatch()\n  }\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n  const prevContext = evalContext\n  evalContext = undefined\n  try {\n    return fn()\n  } finally {\n    evalContext = prevContext\n  }\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined\nlet batchDepth = 0\nlet batchIteration = 0\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0\n\nfunction addDependency(signal: Signal): Node | undefined {\n  if (evalContext === undefined) {\n    return undefined\n  }\n\n  let node = signal._node\n  if (node === undefined || node._target !== evalContext) {\n    /**\n     * `signal` is a new dependency. Create a new dependency node, and set it\n     * as the tail of the current context's dependency list. e.g:\n     *\n     * { A <-> B       }\n     *         \u2191     \u2191\n     *        tail  node (new)\n     *               \u2193\n     * { A <-> B <-> C }\n     *               \u2191\n     *              tail (evalContext._sources)\n     */\n    node = {\n      _version: 0,\n      _source: signal,\n      _prevSource: evalContext._sources,\n      _nextSource: undefined,\n      _target: evalContext,\n      _prevTarget: undefined,\n      _nextTarget: undefined,\n      _rollbackNode: node,\n    }\n\n    if (evalContext._sources !== undefined) {\n      evalContext._sources._nextSource = node\n    }\n    evalContext._sources = node\n    signal._node = node\n\n    // Subscribe to change notifications from this dependency if we're in an effect\n    // OR evaluating a computed signal that in turn has subscribers.\n    if (evalContext._flags & TRACKING) {\n      signal._subscribe(node)\n    }\n    return node\n  }\n  if (node._version === -1) {\n    // `signal` is an existing dependency from a previous evaluation. Reuse it.\n    node._version = 0\n\n    /**\n     * If `node` is not already the current tail of the dependency list (i.e.\n     * there is a next node in the list), then make the `node` the new tail. e.g:\n     *\n     * { A <-> B <-> C <-> D }\n     *         \u2191           \u2191\n     *        node   \u250C\u2500\u2500\u2500 tail (evalContext._sources)\n     *         \u2514\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2510\n     *               \u2193     \u2193\n     * { A <-> C <-> D <-> B }\n     *                     \u2191\n     *                    tail (evalContext._sources)\n     */\n    if (node._nextSource !== undefined) {\n      node._nextSource._prevSource = node._prevSource\n\n      if (node._prevSource !== undefined) {\n        node._prevSource._nextSource = node._nextSource\n      }\n\n      node._prevSource = evalContext._sources\n      node._nextSource = undefined\n\n      evalContext._sources!._nextSource = node\n      evalContext._sources = node\n    }\n\n    // We can assume that the currently evaluated effect / computed signal is already\n    // subscribed to change notifications from `signal` if needed.\n    return node\n  }\n  return undefined\n}\n\n/**\n * The base class for plain and computed signals.\n */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style protoTYPEOF_\n// This enables better control of the transpiled output size.\ndeclare class Signal<T = any> {\n  /** @internal */\n  _onChange: (change: { old: T; revised: T }) => void\n\n  /** @internal */\n  _value: unknown\n\n  /**\n   * @internal\n   * Version numbers should always be >= 0, because the special value -1 is used\n   * by Nodes to signify potentially unused but recyclable nodes.\n   */\n  _version: number\n\n  /** @internal */\n  _node?: Node\n\n  /** @internal */\n  _targets?: Node\n\n  constructor(value?: T)\n\n  /** @internal */\n  _refresh(): boolean\n\n  /** @internal */\n  _subscribe(node: Node): void\n\n  /** @internal */\n  _unsubscribe(node: Node): void\n\n  subscribe(fn: (value: T) => void): () => void\n\n  valueOf(): T\n\n  toString(): string\n\n  toJSON(): T\n\n  peek(): T\n\n  brand: typeof BRAND_SYMBOL\n\n  get value(): T\n  set value(value: T)\n}\n\n/** @internal */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style protoTYPEOF_\n// This enables better control of the transpiled output size.\n// biome-ignore lint/suspicious/noRedeclare: <explanation>\nfunction Signal(this: Signal, value?: unknown) {\n  this._value = value\n  this._version = 0\n  this._node = undefined\n  this._targets = undefined\n}\n\nSignal.prototype.brand = BRAND_SYMBOL\n\nSignal.prototype._refresh = () => true\n\nSignal.prototype._subscribe = function (node) {\n  if (this._targets !== node && node._prevTarget === undefined) {\n    node._nextTarget = this._targets\n    if (this._targets !== undefined) {\n      this._targets._prevTarget = node\n    }\n    this._targets = node\n  }\n}\n\nSignal.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the signal has any subscribers to begin with.\n  if (this._targets !== undefined) {\n    const prev = node._prevTarget\n    const next = node._nextTarget\n    if (prev !== undefined) {\n      prev._nextTarget = next\n      node._prevTarget = undefined\n    }\n    if (next !== undefined) {\n      next._prevTarget = prev\n      node._nextTarget = undefined\n    }\n    if (node === this._targets) {\n      this._targets = next\n    }\n  }\n}\n\nSignal.prototype.subscribe = function (fn) {\n  return effect(() => {\n    const value = this.value\n\n    const prevContext = evalContext\n    evalContext = undefined\n    try {\n      fn(value)\n    } finally {\n      evalContext = prevContext\n    }\n  })\n}\n\nSignal.prototype.valueOf = function () {\n  return this.value\n}\n\nSignal.prototype.toString = function () {\n  return `${this.value}`\n}\n\nSignal.prototype.toJSON = function () {\n  return this.value\n}\n\nSignal.prototype.peek = function () {\n  const prevContext = evalContext\n  evalContext = undefined\n  try {\n    return this.value\n  } finally {\n    evalContext = prevContext\n  }\n}\n\nObject.defineProperty(Signal.prototype, 'value', {\n  get(this: Signal) {\n    const node = addDependency(this)\n    if (node !== undefined) {\n      node._version = this._version\n    }\n    return this._value\n  },\n  set(this: Signal, value) {\n    if (value !== this._value) {\n      if (batchIteration > 100) {\n        throw internalErr(from, 'SignalCycleDetected')\n      }\n      const old = this._value\n      const revised = value\n\n      this._value = value\n      this._version++\n      globalVersion++\n\n      /**@__INLINE__*/ startBatch()\n      try {\n        for (\n          let node = this._targets;\n          node !== undefined;\n          node = node._nextTarget\n        ) {\n          node._target._notify()\n        }\n      } finally {\n        endBatch()\n      }\n\n      this?._onChange({ old, revised })\n    }\n  },\n})\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T): Signal<T>\nexport function signal<T = undefined>(): Signal<T | undefined>\nexport function signal<T>(value?: T): Signal<T> {\n  return new Signal(value)\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n  // Check the dependencies for changed values. The dependency list is already\n  // in order of use. Therefore if multiple dependencies have changed values, only\n  // the first used dependency is re-evaluated at this point.\n  for (\n    let node = target._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    // If there's a new version of the dependency before or after refreshing,\n    // or the dependency has something blocking it from refreshing at all (e.g. a\n    // dependency cycle), then we need to recompute.\n    if (\n      node._source._version !== node._version ||\n      !node._source._refresh() ||\n      node._source._version !== node._version\n    ) {\n      return true\n    }\n  }\n  // If none of the dependencies have changed values since last recompute then\n  // there's no need to recompute.\n  return false\n}\n\nfunction prepareSources(target: Computed | Effect) {\n  /**\n   * 1. Mark all current sources as re-usable nodes (version: -1)\n   * 2. Set a rollback node if the current node is being used in a different context\n   * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n   *\n   *    { undefined <- A <-> B <-> C -> undefined }\n   *                   \u2191           \u2191\n   *                   \u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   * target._sources = A; (node is head)  \u2502\n   *                   \u2193                  \u2502\n   * target._sources = C; (node is tail) \u2500\u2518\n   */\n  for (\n    let node = target._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    const rollbackNode = node._source._node\n    if (rollbackNode !== undefined) {\n      node._rollbackNode = rollbackNode\n    }\n    node._source._node = node\n    node._version = -1\n\n    if (node._nextSource === undefined) {\n      target._sources = node\n      break\n    }\n  }\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n  let node = target._sources\n  let head: Node | undefined = undefined\n\n  /**\n   * At this point 'target._sources' points to the tail of the doubly-linked list.\n   * It contains all existing sources + new sources in order of use.\n   * Iterate backwards until we find the head node while dropping old dependencies.\n   */\n  while (node !== undefined) {\n    const prev = node._prevSource\n\n    /**\n     * The node was not re-used, unsubscribe from its change notifications and remove itself\n     * from the doubly-linked list. e.g:\n     *\n     * { A <-> B <-> C }\n     *         \u2193\n     *    { A <-> C }\n     */\n    if (node._version === -1) {\n      node._source._unsubscribe(node)\n\n      if (prev !== undefined) {\n        prev._nextSource = node._nextSource\n      }\n      if (node._nextSource !== undefined) {\n        node._nextSource._prevSource = prev\n      }\n    } else {\n      /**\n       * The new head is the last node seen which wasn't removed/unsubscribed\n       * from the doubly-linked list. e.g:\n       *\n       * { A <-> B <-> C }\n       *   \u2191     \u2191     \u2191\n       *   \u2502     \u2502     \u2514 head = node\n       *   \u2502     \u2514 head = node\n       *   \u2514 head = node\n       */\n      head = node\n    }\n\n    node._source._node = node._rollbackNode\n    if (node._rollbackNode !== undefined) {\n      node._rollbackNode = undefined\n    }\n\n    node = prev\n  }\n\n  target._sources = head\n}\n\nexport declare class Computed<T = any> extends Signal<T> {\n  _fn: () => T\n  _sources?: Node\n  _globalVersion: number\n  _flags: number\n\n  constructor(fn: () => T)\n\n  _notify(): void\n  get value(): T\n}\n\n// biome-ignore lint/suspicious/noRedeclare: <explanation>\nexport function Computed(this: Computed, fn: () => unknown) {\n  Signal.call(this, undefined)\n\n  this._fn = fn\n  this._sources = undefined\n  this._globalVersion = globalVersion - 1\n  this._flags = OUTDATED\n}\n\nComputed.prototype = new Signal() as Computed\n\nComputed.prototype._refresh = function () {\n  this._flags &= ~NOTIFIED\n\n  if (this._flags & RUNNING) {\n    return false\n  }\n\n  // If this computed signal has subscribed to updates from its dependencies\n  // (TRACKING flag set) and none of them have notified about changes (OUTDATED\n  // flag not set), then the computed value can't have changed.\n  if ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n    return true\n  }\n  this._flags &= ~OUTDATED\n\n  if (this._globalVersion === globalVersion) {\n    return true\n  }\n  this._globalVersion = globalVersion\n\n  // Mark this computed signal running before checking the dependencies for value\n  // changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n  this._flags |= RUNNING\n  if (this._version > 0 && !needsToRecompute(this)) {\n    this._flags &= ~RUNNING\n    return true\n  }\n\n  const prevContext = evalContext\n  try {\n    prepareSources(this)\n    evalContext = this\n    const value = this._fn()\n    if (\n      this._flags & HAS_ERROR ||\n      this._value !== value ||\n      this._version === 0\n    ) {\n      this._value = value\n      this._flags &= ~HAS_ERROR\n      this._version++\n    }\n  } catch (err) {\n    this._value = err\n    this._flags |= HAS_ERROR\n    this._version++\n  }\n  evalContext = prevContext\n  cleanupSources(this)\n  this._flags &= ~RUNNING\n  return true\n}\n\nComputed.prototype._subscribe = function (node) {\n  if (this._targets === undefined) {\n    this._flags |= OUTDATED | TRACKING\n\n    // A computed signal subscribes lazily to its dependencies when it\n    // gets its first subscriber.\n    for (\n      let node = this._sources;\n      node !== undefined;\n      node = node._nextSource\n    ) {\n      node._source._subscribe(node)\n    }\n  }\n  Signal.prototype._subscribe.call(this, node)\n}\n\nComputed.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the computed signal has any subscribers.\n  if (this._targets !== undefined) {\n    Signal.prototype._unsubscribe.call(this, node)\n\n    // Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n    // This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n    if (this._targets === undefined) {\n      this._flags &= ~TRACKING\n\n      for (\n        let node = this._sources;\n        node !== undefined;\n        node = node._nextSource\n      ) {\n        node._source._unsubscribe(node)\n      }\n    }\n  }\n}\n\nComputed.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= OUTDATED | NOTIFIED\n\n    for (\n      let node = this._targets;\n      node !== undefined;\n      node = node._nextTarget\n    ) {\n      node._target._notify()\n    }\n  }\n}\n\nObject.defineProperty(Computed.prototype, 'value', {\n  get(this: Computed) {\n    if (this._flags & RUNNING) {\n      // Cycle detected\n      throw internalErr(from, 'SignalCycleDetected')\n    }\n    const node = addDependency(this)\n    this._refresh()\n    if (node !== undefined) {\n      node._version = this._version\n    }\n    if (this._flags & HAS_ERROR) {\n      throw internalErr(from, 'GetComputedError', { value: this._value })\n    }\n    return this._value\n  },\n})\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n  readonly value: T\n  peek(): T\n\n  subscribe(fn: (value: T) => void): () => void\n  valueOf(): T\n  toString(): string\n  toJSON(): T\n  brand: typeof BRAND_SYMBOL\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(fn: () => T): ReadonlySignal<T> {\n  return new Computed(fn)\n}\n\nfunction cleanupEffect(effect: Effect) {\n  const cleanup = effect._cleanup\n  effect._cleanup = undefined\n\n  if (typeof cleanup === 'function') {\n    /*@__INLINE__**/ startBatch()\n\n    // Run cleanup functions always outside of any context.\n    const prevContext = evalContext\n    evalContext = undefined\n    try {\n      cleanup!()\n    } catch (error) {\n      effect._flags &= ~RUNNING\n      effect._flags |= DISPOSED\n      disposeEffect(effect)\n      throw internalErr(from, 'CleanupEffectError', { error })\n    } finally {\n      evalContext = prevContext\n      endBatch()\n    }\n  }\n}\n\nfunction disposeEffect(effect: Effect) {\n  for (\n    let node = effect._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    node._source._unsubscribe(node)\n  }\n  effect._fn = undefined\n  effect._sources = undefined\n\n  cleanupEffect(effect)\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n  if (evalContext !== this) {\n    throw internalErr(from, 'EndEffectError')\n  }\n  cleanupSources(this)\n  evalContext = prevContext\n\n  this._flags &= ~RUNNING\n  if (this._flags & DISPOSED) {\n    disposeEffect(this)\n  }\n  endBatch()\n}\n\nexport type EffectFn = () => OnRemovalFn | void | Promise<OnRemovalFn | void>\n\ndeclare class Effect {\n  _fn?: EffectFn\n  _cleanup?: () => void\n  _sources?: Node\n  _nextBatchedEffect?: Effect\n  _flags: number\n\n  constructor(fn: EffectFn)\n\n  _callback(): void\n  _start(): () => void\n  _notify(): void\n  _dispose(): void\n}\n\n// biome-ignore lint/suspicious/noRedeclare: <explanation>\nfunction Effect(this: Effect, fn: EffectFn) {\n  this._fn = fn\n  this._cleanup = undefined\n  this._sources = undefined\n  this._nextBatchedEffect = undefined\n  this._flags = TRACKING\n}\n\nEffect.prototype._callback = function () {\n  const finish = this._start()\n  try {\n    if (this._flags & DISPOSED) return\n    if (this._fn === undefined) return\n\n    const cleanup = this._fn()\n    if (typeof cleanup === 'function') {\n      this._cleanup = cleanup!\n    }\n  } finally {\n    finish()\n  }\n}\n\nEffect.prototype._start = function () {\n  if (this._flags & RUNNING) {\n    throw internalErr(from, 'SignalCycleDetected')\n  }\n  this._flags |= RUNNING\n  this._flags &= ~DISPOSED\n  cleanupEffect(this)\n  prepareSources(this)\n\n  /*@__INLINE__**/ startBatch()\n  const prevContext = evalContext\n  evalContext = this\n  return endEffect.bind(this, prevContext)\n}\n\nEffect.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= NOTIFIED\n    this._nextBatchedEffect = batchedEffect\n    batchedEffect = this\n  }\n}\n\nEffect.prototype._dispose = function () {\n  this._flags |= DISPOSED\n\n  if (!(this._flags & RUNNING)) {\n    disposeEffect(this)\n  }\n}\n\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn): () => void {\n  const effect = new Effect(fn)\n  try {\n    effect._callback()\n  } catch (error) {\n    effect._dispose()\n    // Throw the error, since it is already a Datastar error.\n    throw error\n  }\n  // Return a bound function instead of a wrapper like `() => effect._dispose()`,\n  // because bound functions seem to be just as fast and take up a lot less memory.\n  return effect._dispose.bind(effect)\n}\n\nexport { batch, computed, effect, Signal, untracked }\nexport type { ReadonlySignal }\n", "import { type Computed, Signal, computed } from '../vendored/preact-core'\nimport { internalErr } from './errors'\nimport {\n  DATASTAR_SIGNAL_EVENT,\n  type DatastarSignalEvent,\n  type NestedSignal,\n  type NestedValues,\n} from './types'\n\nconst from = 'namespacedSignals'\n\nconst dispatchSignalEvent = (evt: Partial<DatastarSignalEvent>) => {\n  document.dispatchEvent(\n    new CustomEvent<DatastarSignalEvent>(DATASTAR_SIGNAL_EVENT, {\n      detail: Object.assign({ added: [], removed: [], updated: [] }, evt),\n    }),\n  )\n}\n// If onlyPublic is true, only signals not starting with an underscore are included\nfunction nestedValues(\n  signal: NestedSignal,\n  onlyPublic = false,\n): Record<string, any> {\n  const kv: Record<string, any> = {}\n  for (const key in signal) {\n    if (Object.hasOwn(signal, key)) {\n      if (onlyPublic && key.startsWith('_')) {\n        continue\n      }\n      const value = signal[key]\n      if (value instanceof Signal) {\n        kv[key] = value.value\n      } else {\n        kv[key] = nestedValues(value)\n      }\n    }\n  }\n  return kv\n}\n\nfunction mergeNested(\n  target: NestedValues,\n  values: NestedValues,\n  onlyIfMissing = false,\n) {\n  const evt: DatastarSignalEvent = {\n    added: [],\n    removed: [],\n    updated: [],\n  }\n  for (const key in values) {\n    if (Object.hasOwn(values, key)) {\n      if (key.match(/\\_\\_+/)) {\n        throw internalErr(from, 'InvalidSignalKey', { key })\n      }\n\n      const value = values[key]\n      if (value instanceof Object && !Array.isArray(value)) {\n        if (!target[key]) {\n          target[key] = {}\n        }\n        const subEvt = mergeNested(\n          target[key] as NestedValues,\n          value as NestedValues,\n          onlyIfMissing,\n        )\n        evt.added.push(...subEvt.added.map((k) => `${key}.${k}`))\n        evt.removed.push(...subEvt.removed.map((k) => `${key}.${k}`))\n        evt.updated.push(...subEvt.updated.map((k) => `${key}.${k}`))\n      } else {\n        const hasKey = Object.hasOwn(target, key)\n        if (hasKey) {\n          if (onlyIfMissing) continue\n          const t = target[key]\n          if (t instanceof Signal) {\n            const oldValue = t.value\n            t.value = value\n            if (oldValue !== value) {\n              evt.updated.push(key)\n            }\n            continue\n          }\n        }\n\n        const s = new Signal(value)\n        s._onChange = () => {\n          dispatchSignalEvent({ updated: [key] })\n        }\n        target[key] = s\n\n        evt.added.push(key)\n      }\n    }\n  }\n  return evt\n}\n\nfunction walkNestedSignal(\n  signal: NestedSignal,\n  cb: (dotDeliminatedPath: string, signal: Signal<any>) => void,\n): void {\n  for (const key in signal) {\n    if (Object.hasOwn(signal, key)) {\n      const value = signal[key]\n      if (value instanceof Signal) {\n        cb(key, value)\n      } else {\n        walkNestedSignal(value, (path, value) => {\n          cb(`${key}.${path}`, value)\n        })\n      }\n    }\n  }\n}\n\n// Recursive function to subset a nested object, each key is a dot-delimited path\nfunction nestedSubset(original: NestedValues, ...keys: string[]): NestedValues {\n  const subset: NestedValues = {}\n  for (const key of keys) {\n    const parts = key.split('.')\n    let subOriginal = original\n    let subSubset = subset\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subOriginal[part]) {\n        return {}\n      }\n      if (!subSubset[part]) {\n        subSubset[part] = {}\n      }\n      subOriginal = subOriginal[part] as NestedValues\n      subSubset = subSubset[part] as NestedValues\n    }\n    const last = parts[parts.length - 1]\n    subSubset[last] = subOriginal[last]\n  }\n  return subset\n}\n\n// Recursively walk a NestedValue with a callback and dot-delimited path\nexport function walkNestedValues(\n  nv: NestedValues,\n  cb: (path: string, value: any) => void,\n) {\n  for (const key in nv) {\n    if (Object.hasOwn(nv, key)) {\n      const value = nv[key]\n      if (value instanceof Object && !Array.isArray(value)) {\n        walkNestedValues(value, (path, value) => {\n          cb(`${key}.${path}`, value)\n        })\n      } else {\n        cb(key, value)\n      }\n    }\n  }\n}\n\nexport class SignalsRoot {\n  #signals: NestedSignal = {}\n\n  exists(dotDelimitedPath: string): boolean {\n    return !!this.signal(dotDelimitedPath)\n  }\n\n  signal<T>(dotDelimitedPath: string): Signal<T> | null {\n    const parts = dotDelimitedPath.split('.')\n    let subSignals = this.#signals\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subSignals[part]) {\n        return null\n      }\n      subSignals = subSignals[part] as NestedSignal\n    }\n    const last = parts[parts.length - 1]\n    const signal = subSignals[last]\n    if (!signal)\n      throw internalErr(from, 'SignalNotFound', { path: dotDelimitedPath })\n    return signal as Signal<T>\n  }\n\n  setSignal<T extends Signal<T>>(dotDelimitedPath: string, signal: T) {\n    const parts = dotDelimitedPath.split('.')\n    let subSignals = this.#signals\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subSignals[part]) {\n        subSignals[part] = {}\n      }\n      subSignals = subSignals[part] as NestedSignal\n    }\n    const last = parts[parts.length - 1]\n    subSignals[last] = signal\n  }\n\n  setComputed<T>(dotDelimitedPath: string, fn: () => T) {\n    const signal = computed(() => fn()) as Computed\n    this.setSignal(dotDelimitedPath, signal)\n  }\n\n  value<T>(dotDelimitedPath: string): T {\n    const signal = this.signal(dotDelimitedPath) as Signal<T>\n    return signal?.value\n  }\n\n  setValue<T>(dotDelimitedPath: string, value: T) {\n    const { signal } = this.upsertIfMissing(dotDelimitedPath, value)\n    const oldValue = signal.value\n    signal.value = value\n    if (oldValue !== value) {\n      dispatchSignalEvent({ updated: [dotDelimitedPath] })\n    }\n  }\n\n  upsertIfMissing<T>(dotDelimitedPath: string, defaultValue: T) {\n    const parts = dotDelimitedPath.split('.')\n    let subSignals = this.#signals\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subSignals[part]) {\n        subSignals[part] = {}\n      }\n      subSignals = subSignals[part] as NestedSignal\n    }\n    const last = parts[parts.length - 1]\n\n    const current = subSignals[last]\n    if (current instanceof Signal) {\n      return { signal: current as Signal<T>, inserted: false }\n    }\n\n    const signal = new Signal(defaultValue)\n    signal._onChange = () => {\n      dispatchSignalEvent({ updated: [dotDelimitedPath] })\n    }\n    subSignals[last] = signal\n\n    dispatchSignalEvent({ added: [dotDelimitedPath] })\n\n    return { signal: signal, inserted: true }\n  }\n\n  remove(...dotDelimitedPaths: string[]) {\n    if (!dotDelimitedPaths.length) {\n      this.#signals = {}\n      return\n    }\n    const removed = Array<string>()\n    for (const path of dotDelimitedPaths) {\n      const parts = path.split('.')\n      let subSignals = this.#signals\n      for (let i = 0; i < parts.length - 1; i++) {\n        const part = parts[i]\n        if (!subSignals[part]) {\n          return\n        }\n        subSignals = subSignals[part] as NestedSignal\n      }\n      const last = parts[parts.length - 1]\n      delete subSignals[last]\n      removed.push(path)\n    }\n    dispatchSignalEvent({ removed })\n  }\n\n  merge(other: NestedValues, onlyIfMissing = false) {\n    const evt = mergeNested(this.#signals, other, onlyIfMissing)\n    if (evt.added.length || evt.removed.length || evt.updated.length) {\n      dispatchSignalEvent(evt)\n    }\n  }\n\n  subset(...keys: string[]): NestedValues {\n    return nestedSubset(this.values(), ...keys)\n  }\n\n  walk(cb: (name: string, signal: Signal<any>) => void) {\n    walkNestedSignal(this.#signals, cb)\n  }\n\n  paths() {\n    const signalNames = new Array<string>()\n    this.walk((path) => signalNames.push(path))\n    return signalNames\n  }\n\n  values(onlyPublic = false): NestedValues {\n    return nestedValues(this.#signals, onlyPublic)\n  }\n\n  JSON(shouldIndent = true, onlyPublic = false) {\n    const values = this.values(onlyPublic)\n    if (!shouldIndent) {\n      return JSON.stringify(values)\n    }\n    return JSON.stringify(values, null, 2)\n  }\n\n  public toString() {\n    return this.JSON()\n  }\n}\n", "import { Hash, attrHash, elUniqId, walkDOM } from '../utils/dom'\nimport { camel } from '../utils/text'\nimport { effect } from '../vendored/preact-core'\nimport { DSP, DSS } from './consts'\nimport { initErr, runtimeErr } from './errors'\nimport { SignalsRoot } from './signals'\nimport {\n  type ActionPlugin,\n  type ActionPlugins,\n  type AttributePlugin,\n  type DatastarPlugin,\n  type GlobalInitializer,\n  type HTMLorSVGElement,\n  type InitContext,\n  type OnRemovalFn,\n  PluginType,\n  Requirement,\n  type RuntimeContext,\n  type RuntimeExpressionFunction,\n  type WatcherPlugin,\n} from './types'\n\nconst signals: SignalsRoot = new SignalsRoot()\nconst actions: ActionPlugins = {}\nconst plugins: AttributePlugin[] = []\n\n// Map of cleanup functions by element ID, keyed by a dataset key-value hash\nconst removals = new Map<string, Map<number, OnRemovalFn>>()\n\nlet mutationObserver: MutationObserver | null = null\n\nlet alias = ''\nexport function setAlias(value: string) {\n  alias = value\n}\n\nexport function load(...pluginsToLoad: DatastarPlugin[]) {\n  for (const plugin of pluginsToLoad) {\n    const ctx: InitContext = {\n      plugin,\n      signals,\n      effect: (cb: () => void): OnRemovalFn => effect(cb),\n      actions,\n      removals,\n      applyToElement,\n    }\n\n    let globalInitializer: GlobalInitializer | undefined\n    switch (plugin.type) {\n      case PluginType.Action: {\n        actions[plugin.name] = plugin as ActionPlugin\n        break\n      }\n      case PluginType.Attribute: {\n        const ap = plugin as AttributePlugin\n        plugins.push(ap)\n        globalInitializer = ap.onGlobalInit\n        break\n      }\n      case PluginType.Watcher: {\n        const wp = plugin as WatcherPlugin\n        globalInitializer = wp.onGlobalInit\n        break\n      }\n      default: {\n        throw initErr('InvalidPluginType', ctx)\n      }\n    }\n    if (globalInitializer) {\n      globalInitializer(ctx)\n    }\n  }\n\n  // Sort attribute plugins by descending length then alphabetically\n  plugins.sort((a, b) => {\n    const lenDiff = b.name.length - a.name.length\n    if (lenDiff !== 0) return lenDiff\n    return a.name.localeCompare(b.name)\n  })\n}\n\n// Apply all plugins to all elements in the DOM\nexport function apply() {\n  // Delay applying plugins to give custom plugins a chance to load\n  queueMicrotask(() => {\n    applyToElement(document.documentElement)\n    observe()\n  })\n}\n\n// Apply all plugins to the element and its children\nfunction applyToElement(rootElement: HTMLorSVGElement) {\n  walkDOM(rootElement, (el) => {\n    // Check if the element has any data attributes already\n    const toApply = new Array<string>()\n    const elCleanups = removals.get(el.id) || new Map()\n    const toCleanup = new Map<number, OnRemovalFn>([...elCleanups])\n    const hashes = new Map<string, number>()\n\n    // Apply the plugins to the element in order of application\n    // since DOMStringMap is ordered, we can be deterministic\n    for (const datasetKey of Object.keys(el.dataset)) {\n      // Ignore data attributes that don\u2019t start with the alias\n      if (!datasetKey.startsWith(alias)) {\n        break\n      }\n\n      const datasetValue = el.dataset[datasetKey] || ''\n      const currentHash = attrHash(datasetKey, datasetValue)\n      hashes.set(datasetKey, currentHash)\n\n      // If the hash hasn't changed, ignore\n      // otherwise keep the old cleanup and add new to applys\n      if (elCleanups.has(currentHash)) {\n        toCleanup.delete(currentHash)\n      } else {\n        toApply.push(datasetKey)\n      }\n    }\n\n    // Clean up any old plugins and apply the new ones\n    for (const [_, cleanup] of toCleanup) {\n      cleanup()\n    }\n    for (const key of toApply) {\n      const h = hashes.get(key)!\n      applyAttributePlugin(el, key, h)\n    }\n  })\n}\n\n// Set up a mutation observer to run plugin removal and apply functions\nfunction observe() {\n  if (mutationObserver) {\n    return\n  }\n\n  mutationObserver = new MutationObserver((mutations) => {\n    const toRemove = new Set<HTMLorSVGElement>()\n    const toApply = new Set<HTMLorSVGElement>()\n    for (const { target, type, addedNodes, removedNodes } of mutations) {\n      switch (type) {\n        case 'childList':\n          {\n            for (const node of removedNodes) {\n              toRemove.add(node as HTMLorSVGElement)\n            }\n            for (const node of addedNodes) {\n              toApply.add(node as HTMLorSVGElement)\n            }\n          }\n          break\n        case 'attributes': {\n          toApply.add(target as HTMLorSVGElement)\n\n          break\n        }\n      }\n    }\n    for (const el of toRemove) {\n      const elTracking = removals.get(el.id)\n      if (elTracking) {\n        for (const [hash, cleanup] of elTracking) {\n          cleanup()\n          elTracking.delete(hash)\n        }\n        if (elTracking.size === 0) {\n          removals.delete(el.id)\n        }\n      }\n    }\n    for (const el of toApply) {\n      applyToElement(el)\n    }\n  })\n\n  mutationObserver.observe(document.body, {\n    attributes: true,\n    attributeOldValue: true,\n    childList: true,\n    subtree: true,\n  })\n}\n\nfunction applyAttributePlugin(\n  el: HTMLorSVGElement,\n  camelCasedKey: string,\n  hash: number,\n) {\n  // Extract the raw key from the dataset\n  const rawKey = camel(camelCasedKey.slice(alias.length))\n\n  // Find the plugin that matches, since the plugins are sorted by length descending and alphabetically. The first match will be the most specific.\n  const plugin = plugins.find((p) => {\n    // Ignore keys with the plugin name as a prefix (ignores `classes` but not `classBold`)\n    const regex = new RegExp(`^${p.name}([A-Z]|_|$)`)\n    return regex.test(rawKey)\n  })\n\n  // Skip if no plugin is found\n  if (!plugin) return\n\n  // Ensure the element has an id\n  if (!el.id.length) el.id = elUniqId(el)\n\n  // Extract the key and modifiers\n  let [key, ...rawModifiers] = rawKey.slice(plugin.name.length).split(/\\_\\_+/)\n\n  const hasKey = key.length > 0\n  if (hasKey) {\n    key = camel(key)\n  }\n  const value = el.dataset[camelCasedKey] || ''\n  const hasValue = value.length > 0\n\n  // Create the runtime context\n  const ctx: RuntimeContext = {\n    signals,\n    applyToElement,\n    effect: (cb: () => void): OnRemovalFn => effect(cb),\n    actions,\n    removals,\n    genRX: () => genRX(ctx, ...(plugin.argNames || [])),\n    plugin,\n    el,\n    rawKey,\n    key,\n    value,\n    mods: new Map(),\n  }\n\n  // Check the requirements\n  const keyReq = plugin.keyReq || Requirement.Allowed\n  if (hasKey) {\n    if (keyReq === Requirement.Denied) {\n      throw runtimeErr(`${plugin.name}KeyNotAllowed`, ctx)\n    }\n  } else if (keyReq === Requirement.Must) {\n    throw runtimeErr(`${plugin.name}KeyRequired`, ctx)\n  }\n\n  const valReq = plugin.valReq || Requirement.Allowed\n  if (hasValue) {\n    if (valReq === Requirement.Denied) {\n      throw runtimeErr(`${plugin.name}ValueNotAllowed`, ctx)\n    }\n  } else if (valReq === Requirement.Must) {\n    throw runtimeErr(`${plugin.name}ValueRequired`, ctx)\n  }\n\n  // Check for exclusive requirements\n  if (keyReq === Requirement.Exclusive || valReq === Requirement.Exclusive) {\n    if (hasKey && hasValue) {\n      throw runtimeErr(`${plugin.name}KeyAndValueProvided`, ctx)\n    }\n    if (!hasKey && !hasValue) {\n      throw runtimeErr(`${plugin.name}KeyOrValueRequired`, ctx)\n    }\n  }\n\n  for (const rawMod of rawModifiers) {\n    const [label, ...mod] = rawMod.split('.')\n    ctx.mods.set(camel(label), new Set(mod.map((t) => t.toLowerCase())))\n  }\n\n  // Load the plugin\n  const cleanup = plugin.onLoad(ctx) ?? (() => {})\n\n  // Store the cleanup function\n  let elTracking = removals.get(el.id)\n  if (!elTracking) {\n    elTracking = new Map()\n    removals.set(el.id, elTracking)\n  }\n  elTracking.set(hash, cleanup)\n}\n\nfunction genRX(\n  ctx: RuntimeContext,\n  ...argNames: string[]\n): RuntimeExpressionFunction {\n  let userExpression = ''\n\n  // This regex allows Datastar expressions to support nested\n  // regex and strings that contain ; without breaking.\n  //\n  // Each of these regex defines a block type we want to match\n  // (importantly we ignore the content within these blocks):\n  //\n  // regex            \\/(\\\\\\/|[^\\/])*\\/\n  // double quotes      \"(\\\\\"|[^\\\"])*\"\n  // single quotes      '(\\\\'|[^'])*'\n  // ticks              `(\\\\`|[^`])*`\n  //\n  // We also want to match the non delimiter part of statements\n  // note we only support ; statement delimiters:\n  //\n  // [^;]\n  //\n  const statementRe =\n    /(\\/(\\\\\\/|[^\\/])*\\/|\"(\\\\\"|[^\\\"])*\"|'(\\\\'|[^'])*'|`(\\\\`|[^`])*`|[^;])+/gm\n  const statements = ctx.value.trim().match(statementRe)\n  if (statements) {\n    const lastIdx = statements.length - 1\n    const last = statements[lastIdx].trim()\n    if (!last.startsWith('return')) {\n      statements[lastIdx] = `return (${last});`\n    }\n    userExpression = statements.join(';\\n')\n  }\n\n  // Ignore any escaped values\n  const escaped = new Map<string, string>()\n  const escapeRe = new RegExp(`(?:${DSP})(.*?)(?:${DSS})`, 'gm')\n  for (const match of userExpression.matchAll(escapeRe)) {\n    const k = match[1]\n    const v = new Hash('dsEscaped').with(k).string\n    escaped.set(v, k)\n    userExpression = userExpression.replace(DSP + k + DSS, v)\n  }\n\n  const fnCall = /@(\\w*)\\(/gm\n  const matches = userExpression.matchAll(fnCall)\n  const methodsCalled = new Set<string>()\n  for (const match of matches) {\n    methodsCalled.add(match[1])\n  }\n\n  // Replace any action calls\n  const actionsRe = new RegExp(`@(${Object.keys(actions).join('|')})\\\\(`, 'gm')\n\n  // Add ctx to action calls\n  userExpression = userExpression.replaceAll(\n    actionsRe,\n    'ctx.actions.$1.fn(ctx,',\n  )\n\n  // Replace any signal calls\n  const signalNames = ctx.signals.paths()\n  if (signalNames.length) {\n    // Match any valid `$signalName` followed by a non-word character or end of string\n    const signalsRe = new RegExp(`\\\\$(${signalNames.join('|')})(\\\\W|$)`, 'gm')\n    userExpression = userExpression.replaceAll(\n      signalsRe,\n      `ctx.signals.signal('$1').value$2`,\n    )\n  }\n\n  // Replace any escaped values\n  for (const [k, v] of escaped) {\n    userExpression = userExpression.replace(k, v)\n  }\n\n  const fnContent = `return (() => {\\n${userExpression}\\n})()` // Wrap in IIFE\n  ctx.fnContent = fnContent\n\n  try {\n    const fn = new Function('ctx', ...argNames, fnContent)\n    return (...args: any[]) => {\n      try {\n        return fn(ctx, ...args)\n      } catch (error: any) {\n        throw runtimeErr('ExecuteExpression', ctx, {\n          error: error.message,\n        })\n      }\n    }\n  } catch (error: any) {\n    throw runtimeErr('GenerateExpression', ctx, {\n      error: error.message,\n    })\n  }\n}\n", "import { DSP } from '../engine/consts'\n// @ts-ignore\nconst _ = DSP // This is to force the import of DSP first in the compiled code\n\nimport { Computed } from '../plugins/official/core/attributes/computed'\nimport { Signals } from '../plugins/official/core/attributes/signals'\nimport { Star } from '../plugins/official/core/attributes/star'\nimport { apply, load, setAlias } from './engine'\n\nload(Star, Signals, Computed)\n\nexport { apply, load, setAlias }\n", "import { apply, load, setAlias } from '../engine'\n\napply()\n\nexport { apply, load, setAlias }\n"],
  "mappings": "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",
  "names": ["lol", "DSP", "DSS", "DATASTAR", "FragmentMergeModes", "DefaultFragmentMergeMode", "PluginType", "DATASTAR_SIGNAL_EVENT", "DATASTAR", "kebab", "str", "$", "ofs", "camel", "x", "snake", "pascal", "jsStrToObject", "raw", "caseFns", "kebab", "snake", "pascal", "modifyCasing", "str", "mods", "c", "fn", "name", "Computed", "key", "mods", "signals", "genRX", "modifyCasing", "rx", "Signals", "ctx", "key", "mods", "signals", "value", "genRX", "ifMissing", "k", "modifyCasing", "v", "obj", "jsStrToObject", "nv", "Star", "Hash", "#value", "#prefix", "prefix", "DATASTAR", "x", "c", "elUniqId", "el", "hash", "currentEl", "p", "attrHash", "key", "val", "walkDOM", "element", "callback", "dataset", "url", "dserr", "type", "reason", "metadata", "e", "DATASTAR", "snake", "q", "c", "internalErr", "from", "args", "initErr", "ctx", "errCtx", "PluginType", "runtimeErr", "from", "BRAND_SYMBOL", "RUNNING", "NOTIFIED", "OUTDATED", "DISPOSED", "HAS_ERROR", "TRACKING", "startBatch", "batchDepth", "endBatch", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "needsToRecompute", "err", "evalContext", "batchedEffect", "batchDepth", "batchIteration", "globalVersion", "addDependency", "signal", "evalContext", "node", "TRACKING", "Signal", "value", "BRAND_SYMBOL", "prev", "next", "fn", "effect", "prevContext", "internalErr", "from", "old", "revised", "startBatch", "endBatch", "needsToRecompute", "target", "node", "prepareSources", "rollbackNode", "cleanupSources", "head", "prev", "Computed", "fn", "Signal", "globalVersion", "OUTDATED", "NOTIFIED", "RUNNING", "TRACKING", "prevContext", "evalContext", "value", "HAS_ERROR", "err", "internalErr", "from", "addDependency", "computed", "cleanupEffect", "effect", "cleanup", "startBatch", "error", "DISPOSED", "disposeEffect", "endBatch", "endEffect", "Effect", "finish", "batchedEffect", "from", "dispatchSignalEvent", "evt", "DATASTAR_SIGNAL_EVENT", "nestedValues", "signal", "onlyPublic", "kv", "key", "value", "Signal", "mergeNested", "target", "values", "onlyIfMissing", "internalErr", "subEvt", "k", "t", "oldValue", "s", "walkNestedSignal", "cb", "path", "nestedSubset", "original", "keys", "subset", "parts", "subOriginal", "subSubset", "i", "part", "last", "SignalsRoot", "#signals", "dotDelimitedPath", "parts", "subSignals", "i", "part", "last", "signal", "internalErr", "from", "fn", "computed", "value", "oldValue", "dispatchSignalEvent", "defaultValue", "current", "Signal", "dotDelimitedPaths", "removed", "path", "other", "onlyIfMissing", "evt", "mergeNested", "keys", "nestedSubset", "cb", "walkNestedSignal", "signalNames", "onlyPublic", "nestedValues", "shouldIndent", "values", "signals", "SignalsRoot", "actions", "plugins", "removals", "mutationObserver", "alias", "setAlias", "value", "load", "pluginsToLoad", "plugin", "ctx", "cb", "effect", "applyToElement", "globalInitializer", "ap", "initErr", "a", "b", "lenDiff", "apply", "observe", "rootElement", "walkDOM", "el", "toApply", "elCleanups", "toCleanup", "hashes", "datasetKey", "datasetValue", "currentHash", "attrHash", "_", "cleanup", "key", "h", "applyAttributePlugin", "mutations", "toRemove", "target", "type", "addedNodes", "removedNodes", "node", "elTracking", "hash", "camelCasedKey", "rawKey", "camel", "p", "elUniqId", "rawModifiers", "hasKey", "hasValue", "genRX", "keyReq", "runtimeErr", "valReq", "rawMod", "label", "mod", "t", "argNames", "userExpression", "statementRe", "statements", "lastIdx", "last", "escaped", "escapeRe", "DSP", "DSS", "match", "k", "v", "Hash", "fnCall", "matches", "methodsCalled", "actionsRe", "signalNames", "signalsRe", "fnContent", "fn", "args", "error", "load", "Star", "Signals", "Computed", "apply"]
}
