{
  "version": 3,
  "sources": ["../library/src/engine/consts.ts", "../library/src/engine/types.ts", "../library/src/utils/text.ts", "../library/src/plugins/official/core/attributes/computed.ts", "../library/src/plugins/official/core/attributes/signals.ts", "../library/src/plugins/official/core/attributes/star.ts", "../library/src/utils/dom.ts", "../library/src/engine/errors.ts", "../library/src/engine/signals.ts", "../library/src/engine/engine.ts", "../library/src/engine/index.ts", "../library/src/bundles/datastar-core.ts"],
  "sourcesContent": ["// This is auto-generated by Datastar. DO NOT EDIT.\nconst lol = /\uD83D\uDD95JS_DS\uD83D\uDE80/.source\nexport const DSP = lol.slice(0, 5)\nexport const DSS = lol.slice(4)\n\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_REQUEST = \"Datastar-Request\";\n\n// #region Defaults\n\n// #region Default durations\n\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000;\n\n// #endregion\n\n\n// #region Default strings\n\n// The default attributes for <script/> element use when executing scripts. It is a set of key-value pairs delimited by a newline \\\\n character.\nexport const DefaultExecuteScriptAttributes = \"type module\";\n\n// #endregion\n\n\n// #region Default booleans\n\n// Should fragments be merged using the ViewTransition API?\nexport const DefaultFragmentsUseViewTransitions = false;\n\n// Should a given set of signals merge if they are missing?\nexport const DefaultMergeSignalsOnlyIfMissing = false;\n\n// Should script element remove itself after execution?\nexport const DefaultExecuteScriptAutoRemove = true;\n\n// #endregion\n\n\n// #region Enums\n\n// The mode in which a fragment is merged into the DOM.\nexport const FragmentMergeModes = {\n    // Morphs the fragment into the existing element using idiomorph.\n    Morph: \"morph\",\n    // Replaces the inner HTML of the existing element.\n    Inner: \"inner\",\n    // Replaces the outer HTML of the existing element.\n    Outer: \"outer\",\n    // Prepends the fragment to the existing element.\n    Prepend: \"prepend\",\n    // Appends the fragment to the existing element.\n    Append: \"append\",\n    // Inserts the fragment before the existing element.\n    Before: \"before\",\n    // Inserts the fragment after the existing element.\n    After: \"after\",\n    // Upserts the attributes of the existing element.\n    UpsertAttributes: \"upsertAttributes\",\n} as const;\n\n// Default value for FragmentMergeMode\nexport const DefaultFragmentMergeMode = FragmentMergeModes.Morph;\n\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\nexport const EventTypes = {\n    // An event for merging HTML fragments into the DOM.\n    MergeFragments: \"datastar-merge-fragments\",\n    // An event for merging signals.\n    MergeSignals: \"datastar-merge-signals\",\n    // An event for removing HTML fragments from the DOM.\n    RemoveFragments: \"datastar-remove-fragments\",\n    // An event for removing signals.\n    RemoveSignals: \"datastar-remove-signals\",\n    // An event for executing <script/> elements in the browser.\n    ExecuteScript: \"datastar-execute-script\",\n} as const;\n// #endregion\n\n// #endregion", "import { DATASTAR } from './consts'\nimport type { Dependency, EffectFn, SignalsRoot } from './signals'\n\nexport type OnRemovalFn = () => void\n\nexport enum PluginType {\n  Attribute = 1,\n  Watcher = 2,\n  Action = 3,\n}\n\nexport interface DatastarPlugin {\n  type: PluginType // The type of plugin\n  name: string // The name of the plugin\n}\n\nexport enum Requirement {\n  Allowed = 0,\n  Must = 1,\n  Denied = 2,\n  Exclusive = 3,\n}\n\nexport interface DatastarSignalEvent {\n  added: Array<string>\n  removed: Array<string>\n  updated: Array<string>\n}\nexport const DATASTAR_SIGNAL_EVENT = `${DATASTAR}-signals`\nexport interface CustomEventMap {\n  [DATASTAR_SIGNAL_EVENT]: CustomEvent<DatastarSignalEvent>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\ndeclare global {\n  interface Document {\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n  }\n}\n\n// A plugin accesible via a `data-${name}` attribute on an element\nexport interface AttributePlugin extends DatastarPlugin {\n  type: PluginType.Attribute\n  onGlobalInit?: (ctx: InitContext) => void // Called once on registration of the plugin\n  onLoad: (ctx: RuntimeContext) => OnRemovalFn | void // Return a function to be called on removal\n  mods?: Set<string> // If not provided, all modifiers are allowed\n  keyReq?: Requirement // The rules for the key requirements\n  valReq?: Requirement // The rules for the value requirements\n  argNames?: string[] // argument names for the reactive expression\n}\n\n// A plugin that runs on the global scope of the DastaStar instance\nexport interface WatcherPlugin extends DatastarPlugin {\n  type: PluginType.Watcher\n  onGlobalInit?: (ctx: InitContext) => void\n}\n\nexport type ActionPlugins = Record<string, ActionPlugin>\nexport type ActionMethod = (ctx: RuntimeContext, ...args: any[]) => any\n\nexport interface ActionPlugin extends DatastarPlugin {\n  type: PluginType.Action\n  fn: ActionMethod\n}\n\nexport type GlobalInitializer = (ctx: InitContext) => void\n\nexport type InitContext = {\n  plugin: DatastarPlugin\n  signals: SignalsRoot\n  effect: EffectFn\n  actions: Readonly<ActionPlugins>\n  removals: Map<string, Map<number, OnRemovalFn>>\n  applyToElement: (el: HTMLorSVGElement) => void\n}\n\nexport type HTMLorSVGElement = Element & (HTMLElement | SVGElement)\nexport type Modifiers = Map<string, Set<string>> // mod name -> tags\n\nexport type RuntimeContext = InitContext & {\n  plugin: DatastarPlugin // The name of the plugin\n  el: HTMLorSVGElement // The element the attribute is on\n  rawKey: Readonly<string> // no parsing data-* key\n  key: Readonly<string> // data-* key without the prefix or tags\n  value: Readonly<string> // value of data-* attribute\n  mods: Modifiers // the tags and their arguments\n  genRX: () => {\n    deps: Dependency[]\n    rxFn: <T>(...args: any[]) => T // a reactive expression\n  }\n  fnContent?: string // the content of the function\n}\n\nexport type NestedValues = { [key: string]: NestedValues | any }\nexport type NestedSignal = {\n  [key: string]: NestedSignal | Dependency\n}\n\nexport type RuntimeExpressionFunction = (\n  ctx: RuntimeContext,\n  ...args: any[]\n) => any\n", "import type { Modifiers } from '../engine/types'\n\nexport const isBoolString = (str: string) => str.trim() === 'true'\n\nexport const kebab = (str: string) =>\n  str.replace(\n    /[A-Z]+(?![a-z])|[A-Z]/g,\n    ($, ofs) => (ofs ? '-' : '') + $.toLowerCase(),\n  )\n\nexport const camel = (str: string) =>\n  kebab(str).replace(/-./g, (x) => x[1].toUpperCase())\n\nexport const snake = (str: string) => kebab(str).replace(/-/g, '_')\n\nexport const pascal = (str: string) =>\n  camel(str).replace(/^./, (x) => x[0].toUpperCase())\n\nexport const jsStrToObject = (raw: string) =>\n  new Function(`return Object.assign({}, ${raw})`)()\n\nexport const trimDollarSignPrefix = (str: string) =>\n  str.startsWith('$') ? str.slice(1) : str\n\nconst caseFns: Record<string, (s: string) => string> = { kebab, snake, pascal }\n\nexport function modifyCasing(str: string, mods: Modifiers) {\n  for (const c of mods.get('case') || []) {\n    const fn = caseFns[c]\n    if (fn) str = fn(str)\n  }\n  return str\n}\n", "import {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { modifyCasing } from '../../../../utils/text'\n\nconst name = 'computed'\nexport const Computed: AttributePlugin = {\n  type: PluginType.Attribute,\n  name,\n  keyReq: Requirement.Must,\n  valReq: Requirement.Must,\n  onLoad: ({ key, mods, signals, genRX }) => {\n    key = modifyCasing(key, mods)\n    const { deps, rxFn } = genRX()\n    signals.setComputed(key, deps, rxFn)\n  },\n}\n", "import {\n  type AttributePlugin,\n  type NestedValues,\n  PluginType,\n} from '../../../../engine/types'\nimport { jsStrToObject, modifyCasing } from '../../../../utils/text'\n\nexport const Signals: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'signals',\n  onLoad: (ctx) => {\n    const { key, mods, signals, value, genRX } = ctx\n    const ifMissing = mods.has('ifmissing')\n    const { rxFn } = genRX()\n    if (key !== '') {\n      const k = modifyCasing(key, mods)\n      const v = value === '' ? value : rxFn()\n      if (ifMissing) {\n        signals.upsertIfMissing(k, v)\n      } else {\n        signals.setValue(k, v)\n      }\n    } else {\n      const obj = jsStrToObject(ctx.value)\n      ctx.value = JSON.stringify(obj)\n      const nv = rxFn<NestedValues>()\n      signals.merge(nv, ifMissing)\n    }\n  },\n}\n", "import {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nexport const Star: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'star',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Denied,\n  onLoad: () => {\n    alert('YOU ARE PROBABLY OVERCOMPLICATING IT')\n  },\n}\n", "import { DATASTAR } from '../engine/consts'\nimport type { HTMLorSVGElement } from '../engine/types'\n\nexport class Hash {\n  #value = 0\n  #prefix: string\n\n  constructor(prefix = DATASTAR) {\n    this.#prefix = prefix\n  }\n\n  with(x: number | string | boolean): Hash {\n    if (typeof x === 'string') {\n      for (const c of x.split('')) {\n        this.with(c.charCodeAt(0))\n      }\n    } else if (typeof x === 'boolean') {\n      this.with(1 << (x ? 7 : 3))\n    } else {\n      // use djb2 favored by bernstein http://www.cse.yorku.ca/~oz/hash.html\n      this.#value = (this.#value * 33) ^ x\n    }\n    return this\n  }\n\n  get value() {\n    return this.#value\n  }\n\n  get string() {\n    return this.#prefix + Math.abs(this.#value).toString(36)\n  }\n}\n\nexport function elUniqId(el: Element) {\n  if (el.id) return el.id\n  const hash = new Hash()\n\n  let currentEl = el\n  while (currentEl) {\n    hash.with(currentEl.tagName || '')\n    if (currentEl.id) {\n      hash.with(currentEl.id)\n      break\n    }\n    const p = currentEl?.parentNode\n    if (p) hash.with([...p.children].indexOf(currentEl))\n\n    currentEl = p as Element\n  }\n  return hash.string\n}\n\nexport function attrHash(key: number | string, val: number | string) {\n  return new Hash().with(key).with(val).value\n}\n\nexport function walkDOM(\n  element: Element | null,\n  callback: (el: HTMLorSVGElement) => void,\n) {\n  if (\n    !element ||\n    !(element instanceof HTMLElement || element instanceof SVGElement)\n  ) {\n    return null\n  }\n  const dataset = element.dataset\n  if ('starIgnore' in dataset) {\n    return null\n  }\n  if (!('starIgnore__self' in dataset)) {\n    callback(element)\n  }\n  let el = element.firstElementChild\n  while (el) {\n    walkDOM(el, callback)\n    el = el.nextElementSibling\n  }\n}\n", "import { snake } from '../utils/text'\nimport { DATASTAR } from './consts'\nimport { type InitContext, PluginType, type RuntimeContext } from './types'\n\nconst url = 'https://data-star.dev/errors'\n\ninterface Metadata {\n  error?: string\n  [key: string]: any\n}\n\nfunction dserr(type: string, reason: string, metadata: Metadata = {}) {\n  const e = new Error()\n  e.name = `${DATASTAR} ${type} error`\n  const r = snake(reason)\n  const q = new URLSearchParams({\n    metadata: JSON.stringify(metadata),\n  }).toString()\n  const c = JSON.stringify(metadata, null, 2)\n  e.message = `${reason}\\nMore info: ${url}/${type}/${r}?${q}\\nContext: ${c}`\n  return e\n}\n\nexport function internalErr(from: string, reason: string, args = {}) {\n  return dserr('internal', reason, Object.assign({ from }, args))\n}\n\nexport function initErr(reason: string, ctx: InitContext, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: PluginType[ctx.plugin.type],\n    },\n  }\n  return dserr('init', reason, Object.assign(errCtx, metadata))\n}\n\nexport function runtimeErr(reason: string, ctx: RuntimeContext, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: PluginType[ctx.plugin.type],\n    },\n    element: {\n      id: ctx.el.id,\n      tag: ctx.el.tagName,\n    },\n    expression: {\n      rawKey: ctx.rawKey,\n      key: ctx.key,\n      value: ctx.value,\n      validSignals: ctx.signals.paths(),\n      fnContent: ctx.fnContent,\n    },\n  }\n  return dserr('runtime', reason, Object.assign(errCtx, metadata))\n}\n", "import { internalErr } from './errors'\nimport {\n  DATASTAR_SIGNAL_EVENT,\n  type DatastarSignalEvent,\n  type NestedSignal as NestedDependency,\n  type NestedValues,\n} from './types'\n\nconst from = 'namespacedSignals'\n\nconst dispatchSignalEvent = (evt: Partial<DatastarSignalEvent>) => {\n  document.dispatchEvent(\n    new CustomEvent<DatastarSignalEvent>(DATASTAR_SIGNAL_EVENT, {\n      detail: Object.assign({ added: [], removed: [], updated: [] }, evt),\n    }),\n  )\n}\n\n// If onlyPublic is true, only signals not starting with an underscore are included\nfunction nestedValues(\n  signal: NestedDependency,\n  onlyPublic = false,\n): Record<string, any> {\n  const kv: Record<string, any> = {}\n  for (const key in signal) {\n    if (Object.hasOwn(signal, key)) {\n      if (onlyPublic && key.startsWith('_')) {\n        continue\n      }\n      const value = signal[key]\n      if (value instanceof Dependency) {\n        kv[key] = value.value\n      } else {\n        kv[key] = nestedValues(value)\n      }\n    }\n  }\n  return kv\n}\n\nfunction mergeNested(\n  target: NestedValues,\n  values: NestedValues,\n  pathPrefix: string,\n  onlyIfMissing = false,\n) {\n  const evt: DatastarSignalEvent = {\n    added: [],\n    removed: [],\n    updated: [],\n  }\n  for (const key in values) {\n    if (Object.hasOwn(values, key)) {\n      if (key.match(/\\_\\_+/)) {\n        throw internalErr(from, 'InvalidSignalKey', { key })\n      }\n      const path = pathPrefix ? `${pathPrefix}.${key}` : key\n      const value = values[key]\n      if (value instanceof Object && !Array.isArray(value)) {\n        if (!target[key]) {\n          target[key] = {}\n        }\n        const subEvt = mergeNested(\n          target[key] as NestedValues,\n          value as NestedValues,\n          path,\n          onlyIfMissing,\n        )\n        evt.added.push(...subEvt.added.map((k) => `${path}.${k}`))\n        evt.removed.push(...subEvt.removed.map((k) => `${path}.${k}`))\n        evt.updated.push(...subEvt.updated.map((k) => `${path}.${k}`))\n      } else {\n        const hasKey = Object.hasOwn(target, key)\n        if (hasKey) {\n          if (onlyIfMissing) continue\n          const t = target[key]\n          if (t instanceof Signal) {\n            const oldValue = t.value\n            t.value = value\n            if (oldValue !== value) {\n              evt.updated.push(path)\n            }\n            continue\n          }\n        }\n        const s = new Signal(value, () =>\n          dispatchSignalEvent({ updated: [path] }),\n        )\n        target[key] = s\n        evt.added.push(path)\n      }\n    }\n  }\n  return evt\n}\n\nfunction walkNestedSignal(\n  signal: NestedDependency,\n  cb: (dotDeliminatedPath: string, dep: Dependency) => void,\n): void {\n  for (const key in signal) {\n    if (Object.hasOwn(signal, key)) {\n      const value = signal[key]\n      if (value instanceof Dependency) {\n        cb(key, value)\n      } else {\n        walkNestedSignal(value, (path, value) => {\n          cb(`${key}.${path}`, value)\n        })\n      }\n    }\n  }\n}\n\n// Recursive function to subset a nested object, each key is a dot-delimited path\nfunction nestedSubset(original: NestedValues, ...keys: string[]): NestedValues {\n  const subset: NestedValues = {}\n  for (const key of keys) {\n    const parts = key.split('.')\n    let subOriginal = original\n    let subSubset = subset\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subOriginal[part]) {\n        return {}\n      }\n      if (!subSubset[part]) {\n        subSubset[part] = {}\n      }\n      subOriginal = subOriginal[part] as NestedValues\n      subSubset = subSubset[part] as NestedValues\n    }\n    const last = parts[parts.length - 1]\n    subSubset[last] = subOriginal[last]\n  }\n  return subset\n}\n\n// Recursively walk a NestedValue with a callback and dot-delimited path\nexport function walkNestedValues(\n  nv: NestedValues,\n  cb: (path: string, value: any) => void,\n) {\n  for (const key in nv) {\n    if (Object.hasOwn(nv, key)) {\n      const value = nv[key]\n      if (value instanceof Object && !Array.isArray(value)) {\n        walkNestedValues(value, (path, value) => {\n          cb(`${key}.${path}`, value)\n        })\n      } else {\n        cb(key, value)\n      }\n    }\n  }\n}\n\nexport class SignalsRoot {\n  #signals: NestedDependency = {}\n\n  exists(dotDelimitedPath: string): boolean {\n    return !!this.signal(dotDelimitedPath)\n  }\n\n  signal(dotDelimitedPath: string): Dependency | null {\n    const parts = dotDelimitedPath.split('.')\n    let subDeps = this.#signals\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subDeps[part]) {\n        return null\n      }\n      subDeps = subDeps[part] as NestedDependency\n    }\n    const last = parts[parts.length - 1]\n    const dep = subDeps[last]\n    if (!dep)\n      throw internalErr(from, 'SignalNotFound', { path: dotDelimitedPath })\n    return dep as Dependency\n  }\n\n  setSignal(dotDelimitedPath: string, signal: Dependency) {\n    const parts = dotDelimitedPath.split('.')\n    let subSignals = this.#signals\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subSignals[part]) {\n        subSignals[part] = {}\n      }\n      subSignals = subSignals[part] as NestedDependency\n    }\n    const last = parts[parts.length - 1]\n    subSignals[last] = signal\n  }\n\n  setComputed<T>(\n    dotDelimitedPath: string,\n    deps: Dependency[],\n    fn: DerivedFn<T>,\n  ) {\n    const c = computed(deps, fn)\n    this.setSignal(dotDelimitedPath, c)\n  }\n\n  value<T>(dotDelimitedPath: string): T {\n    const signal = this.signal(dotDelimitedPath) as Dependency\n    return signal?.value as T\n  }\n\n  setValue<T>(dotDelimitedPath: string, value: T) {\n    const { signal } = this.upsertIfMissing(dotDelimitedPath, value)\n    const oldValue = signal.value\n    signal.value = value\n    if (oldValue !== value) {\n      dispatchSignalEvent({ updated: [dotDelimitedPath] })\n    }\n  }\n\n  upsertIfMissing<T>(dotDelimitedPath: string, defaultValue: T) {\n    const parts = dotDelimitedPath.split('.')\n    let subSignals = this.#signals\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subSignals[part]) {\n        subSignals[part] = {}\n      }\n      subSignals = subSignals[part] as NestedDependency\n    }\n    const last = parts[parts.length - 1]\n\n    const current = subSignals[last]\n    if (current instanceof Signal) {\n      return { signal: current as Signal<T>, inserted: false }\n    }\n\n    const signal = new Signal(defaultValue)\n    signal.onChange = () => {\n      dispatchSignalEvent({ updated: [dotDelimitedPath] })\n    }\n    subSignals[last] = signal\n\n    dispatchSignalEvent({ added: [dotDelimitedPath] })\n\n    return { signal: signal, inserted: true }\n  }\n\n  remove(...dotDelimitedPaths: string[]) {\n    if (!dotDelimitedPaths.length) {\n      this.#signals = {}\n      return\n    }\n    const removed = Array<string>()\n    for (const path of dotDelimitedPaths) {\n      const parts = path.split('.')\n      let subSignals = this.#signals\n      for (let i = 0; i < parts.length - 1; i++) {\n        const part = parts[i]\n        if (!subSignals[part]) {\n          return\n        }\n        subSignals = subSignals[part] as NestedDependency\n      }\n      const last = parts[parts.length - 1]\n      delete subSignals[last]\n      removed.push(path)\n    }\n    dispatchSignalEvent({ removed })\n  }\n\n  merge(other: NestedValues, onlyIfMissing = false) {\n    const evt = mergeNested(this.#signals, other, '', onlyIfMissing)\n    if (evt.added.length || evt.removed.length || evt.updated.length) {\n      dispatchSignalEvent(evt)\n    }\n  }\n\n  subset(...keys: string[]): NestedValues {\n    return nestedSubset(this.values(), ...keys)\n  }\n\n  walk(cb: (name: string, signal: Dependency) => void) {\n    walkNestedSignal(this.#signals, cb)\n  }\n\n  paths() {\n    const signalNames = new Array<string>()\n    this.walk((path) => signalNames.push(path))\n    return signalNames\n  }\n\n  values(onlyPublic = false): NestedValues {\n    return nestedValues(this.#signals, onlyPublic)\n  }\n\n  JSON(shouldIndent = true, onlyPublic = false) {\n    const values = this.values(onlyPublic)\n    if (!shouldIndent) {\n      return JSON.stringify(values)\n    }\n    return JSON.stringify(values, null, 2)\n  }\n\n  public toString() {\n    return this.JSON()\n  }\n}\n\nabstract class Subscriber {\n  abstract markDirty(): void\n}\n\nexport abstract class Dependency {\n  abstract readonly value: unknown\n  abstract version(): number\n  abstract addSubscribers(...subscribers: Subscriber[]): void\n  abstract removeSubscribers(...subscribers: Subscriber[]): void\n}\n\nexport class Signal<T> extends Dependency implements Subscriber {\n  subs = new Set<Subscriber>()\n  ver = 1\n\n  constructor(\n    private val: T,\n    public onChange?: (val: T) => void,\n  ) {\n    super()\n  }\n\n  set value(val: T) {\n    if (this.val === val) {\n      return\n    }\n    this.val = val\n    this.ver++\n    this.markDirty()\n    this.onChange?.(val)\n  }\n\n  markDirty() {\n    for (const sub of this.subs) {\n      sub.markDirty()\n    }\n  }\n\n  get value() {\n    return this.val\n  }\n\n  version() {\n    return this.ver\n  }\n\n  addSubscribers(...subscribers: Subscriber[]) {\n    for (const sub of subscribers) {\n      this.subs.add(sub)\n    }\n  }\n\n  removeSubscribers(...subscribers: Subscriber[]) {\n    for (const sub of subscribers) {\n      this.subs.delete(sub)\n    }\n  }\n}\n\nexport function signal<T>(initialValue: T) {\n  return new Signal(initialValue)\n}\n\nexport type DerivedFn<O> = (...args: unknown[]) => O\n\nexport class Derived<O> extends Dependency implements Subscriber {\n  subs = new Set<Subscriber>()\n  isDirty = true\n  ver = 1\n  val!: O\n  versionSum = 0\n\n  constructor(\n    private deps: Dependency[],\n    private fn: DerivedFn<O>,\n  ) {\n    super()\n    for (const dep of deps) {\n      dep.addSubscribers(this)\n    }\n  }\n\n  get value() {\n    if (!this.isDirty) {\n      return this.val\n    }\n    this.isDirty = false\n    let depsVersionSum = 0\n    for (const dep of this.deps) {\n      depsVersionSum += dep.version()\n    }\n    if (depsVersionSum === this.versionSum) {\n      return this.val\n    }\n\n    this.versionSum = depsVersionSum\n    const args = this.deps.map((dep) => dep.value)\n    const currentVal = this.fn(...args)\n    if (this.val === currentVal) {\n      return this.val\n    }\n    this.val = currentVal\n    this.ver++\n    return this.val\n  }\n\n  version() {\n    return this.ver\n  }\n\n  markDirty() {\n    this.isDirty = true\n    for (const sub of this.subs) {\n      sub.markDirty()\n    }\n  }\n\n  addSubscribers(...subscribers: Subscriber[]) {\n    for (const sub of subscribers) {\n      this.subs.add(sub)\n    }\n  }\n\n  removeSubscribers(...subscribers: Subscriber[]) {\n    for (const sub of subscribers) {\n      this.subs.delete(sub)\n    }\n  }\n}\n\nexport function computed<O>(deps: Dependency[], fn: (...args: unknown[]) => O) {\n  return new Derived(deps, fn)\n}\n\nexport class Effect implements Subscriber {\n  depsVersionSum = -1\n\n  constructor(\n    private deps: Dependency[],\n    private fn: (...args: unknown[]) => void,\n  ) {\n    for (const dep of deps) {\n      dep.addSubscribers(this)\n    }\n  }\n\n  markDirty() {\n    let depsVersionSum = 0\n    for (const dep of this.deps) {\n      depsVersionSum += dep.version()\n    }\n    if (depsVersionSum === this.depsVersionSum) {\n      return\n    }\n    this.depsVersionSum = depsVersionSum\n    const args = this.deps.map((dep) => dep.value)\n    this.fn(...args)\n  }\n}\n\nexport type OnRemovalFn = () => void\nexport type EffectFn = (\n  deps: Dependency[],\n  fn: (...args: unknown[]) => void,\n) => OnRemovalFn\n\nexport function effect(\n  deps: Dependency[],\n  fn: (...args: unknown[]) => void,\n): OnRemovalFn {\n  const e = new Effect(deps, fn)\n  e.markDirty()\n  return () => {\n    for (const dep of deps) {\n      dep.removeSubscribers(e)\n    }\n  }\n}\n", "import { Hash, attrHash, elUniqId, walkDOM } from '../utils/dom'\nimport { camel } from '../utils/text'\nimport { DSP, DSS } from './consts'\nimport { initErr, runtimeErr } from './errors'\nimport { type Dependency, SignalsRoot, effect } from './signals'\nimport {\n  type ActionPlugin,\n  type ActionPlugins,\n  type AttributePlugin,\n  type DatastarPlugin,\n  type GlobalInitializer,\n  type HTMLorSVGElement,\n  type InitContext,\n  type OnRemovalFn,\n  PluginType,\n  Requirement,\n  type RuntimeContext,\n  type RuntimeExpressionFunction,\n  type WatcherPlugin,\n} from './types'\n\nconst signals: SignalsRoot = new SignalsRoot()\nconst actions: ActionPlugins = {}\nconst plugins: AttributePlugin[] = []\n\n// Map of cleanup functions by element ID, keyed by a dataset key-value hash\nconst removals = new Map<string, Map<number, OnRemovalFn>>()\n\nlet mutationObserver: MutationObserver | null = null\n\nlet alias = ''\nexport function setAlias(value: string) {\n  alias = value\n}\n\nexport function load(...pluginsToLoad: DatastarPlugin[]) {\n  for (const plugin of pluginsToLoad) {\n    const ctx: InitContext = {\n      plugin,\n      signals,\n      effect: (args: any[], cb: () => void): OnRemovalFn => effect(args, cb),\n      actions,\n      removals,\n      applyToElement,\n    }\n\n    let globalInitializer: GlobalInitializer | undefined\n    switch (plugin.type) {\n      case PluginType.Action: {\n        actions[plugin.name] = plugin as ActionPlugin\n        break\n      }\n      case PluginType.Attribute: {\n        const ap = plugin as AttributePlugin\n        plugins.push(ap)\n        globalInitializer = ap.onGlobalInit\n        break\n      }\n      case PluginType.Watcher: {\n        const wp = plugin as WatcherPlugin\n        globalInitializer = wp.onGlobalInit\n        break\n      }\n      default: {\n        throw initErr('InvalidPluginType', ctx)\n      }\n    }\n    if (globalInitializer) {\n      globalInitializer(ctx)\n    }\n  }\n\n  // Sort attribute plugins by descending length then alphabetically\n  plugins.sort((a, b) => {\n    const lenDiff = b.name.length - a.name.length\n    if (lenDiff !== 0) return lenDiff\n    return a.name.localeCompare(b.name)\n  })\n}\n\n// Apply all plugins to all elements in the DOM\nexport function apply() {\n  // Delay applying plugins to give custom plugins a chance to load\n  queueMicrotask(() => {\n    applyToElement(document.documentElement)\n    observe()\n  })\n}\n\n// Apply all plugins to the element and its children\nfunction applyToElement(rootElement: HTMLorSVGElement) {\n  walkDOM(rootElement, (el) => {\n    // Check if the element has any data attributes already\n    const toApply = new Array<string>()\n    const elCleanups = removals.get(el.id) || new Map()\n    const toCleanup = new Map<number, OnRemovalFn>([...elCleanups])\n    const hashes = new Map<string, number>()\n\n    // Apply the plugins to the element in order of application\n    // since DOMStringMap is ordered, we can be deterministic\n    for (const datasetKey of Object.keys(el.dataset)) {\n      // Ignore data attributes that don\u2019t start with the alias\n      if (!datasetKey.startsWith(alias)) {\n        break\n      }\n\n      const datasetValue = el.dataset[datasetKey] || ''\n      const currentHash = attrHash(datasetKey, datasetValue)\n      hashes.set(datasetKey, currentHash)\n\n      // If the hash hasn't changed, ignore\n      // otherwise keep the old cleanup and add new to applys\n      if (elCleanups.has(currentHash)) {\n        toCleanup.delete(currentHash)\n      } else {\n        toApply.push(datasetKey)\n      }\n    }\n\n    // Clean up any old plugins and apply the new ones\n    for (const [_, cleanup] of toCleanup) {\n      cleanup()\n    }\n    for (const key of toApply) {\n      const h = hashes.get(key)!\n      applyAttributePlugin(el, key, h)\n    }\n  })\n}\n\n// Set up a mutation observer to run plugin removal and apply functions\nfunction observe() {\n  if (mutationObserver) {\n    return\n  }\n\n  mutationObserver = new MutationObserver((mutations) => {\n    const toRemove = new Set<HTMLorSVGElement>()\n    const toApply = new Set<HTMLorSVGElement>()\n    for (const { target, type, addedNodes, removedNodes } of mutations) {\n      switch (type) {\n        case 'childList':\n          {\n            for (const node of removedNodes) {\n              toRemove.add(node as HTMLorSVGElement)\n            }\n            for (const node of addedNodes) {\n              toApply.add(node as HTMLorSVGElement)\n            }\n          }\n          break\n        case 'attributes': {\n          toApply.add(target as HTMLorSVGElement)\n\n          break\n        }\n      }\n    }\n    for (const el of toRemove) {\n      const elTracking = removals.get(el.id)\n      if (elTracking) {\n        for (const [hash, cleanup] of elTracking) {\n          cleanup()\n          elTracking.delete(hash)\n        }\n        if (elTracking.size === 0) {\n          removals.delete(el.id)\n        }\n      }\n    }\n    for (const el of toApply) {\n      applyToElement(el)\n    }\n  })\n\n  mutationObserver.observe(document.body, {\n    attributes: true,\n    attributeOldValue: true,\n    childList: true,\n    subtree: true,\n  })\n}\n\nfunction applyAttributePlugin(\n  el: HTMLorSVGElement,\n  camelCasedKey: string,\n  hash: number,\n) {\n  // Extract the raw key from the dataset\n  const rawKey = camel(camelCasedKey.slice(alias.length))\n\n  // Find the plugin that matches, since the plugins are sorted by length descending and alphabetically. The first match will be the most specific.\n  const plugin = plugins.find((p) => {\n    // Ignore keys with the plugin name as a prefix (ignores `classes` but not `classBold`)\n    const regex = new RegExp(`^${p.name}([A-Z]|_|$)`)\n    return regex.test(rawKey)\n  })\n\n  // Skip if no plugin is found\n  if (!plugin) return\n\n  // Ensure the element has an id\n  if (!el.id.length) el.id = elUniqId(el)\n\n  // Extract the key and modifiers\n  let [key, ...rawModifiers] = rawKey.slice(plugin.name.length).split(/\\_\\_+/)\n\n  const hasKey = key.length > 0\n  if (hasKey) {\n    key = camel(key)\n  }\n  const value = el.dataset[camelCasedKey] || ''\n  const hasValue = value.length > 0\n\n  // Create the runtime context\n  const ctx: RuntimeContext = {\n    signals,\n    applyToElement,\n    effect: (args: any[], cb: () => void): OnRemovalFn => effect(args, cb),\n    actions,\n    removals,\n    genRX: () => genRX(ctx, ...(plugin.argNames || [])),\n    plugin,\n    el,\n    rawKey,\n    key,\n    value,\n    mods: new Map(),\n  }\n\n  // Check the requirements\n  const keyReq = plugin.keyReq || Requirement.Allowed\n  if (hasKey) {\n    if (keyReq === Requirement.Denied) {\n      throw runtimeErr(`${plugin.name}KeyNotAllowed`, ctx)\n    }\n  } else if (keyReq === Requirement.Must) {\n    throw runtimeErr(`${plugin.name}KeyRequired`, ctx)\n  }\n\n  const valReq = plugin.valReq || Requirement.Allowed\n  if (hasValue) {\n    if (valReq === Requirement.Denied) {\n      throw runtimeErr(`${plugin.name}ValueNotAllowed`, ctx)\n    }\n  } else if (valReq === Requirement.Must) {\n    throw runtimeErr(`${plugin.name}ValueRequired`, ctx)\n  }\n\n  // Check for exclusive requirements\n  if (keyReq === Requirement.Exclusive || valReq === Requirement.Exclusive) {\n    if (hasKey && hasValue) {\n      throw runtimeErr(`${plugin.name}KeyAndValueProvided`, ctx)\n    }\n    if (!hasKey && !hasValue) {\n      throw runtimeErr(`${plugin.name}KeyOrValueRequired`, ctx)\n    }\n  }\n\n  for (const rawMod of rawModifiers) {\n    const [label, ...mod] = rawMod.split('.')\n    ctx.mods.set(camel(label), new Set(mod.map((t) => t.toLowerCase())))\n  }\n\n  // Load the plugin\n  const cleanup = plugin.onLoad(ctx) ?? (() => {})\n\n  // Store the cleanup function\n  let elTracking = removals.get(el.id)\n  if (!elTracking) {\n    elTracking = new Map()\n    removals.set(el.id, elTracking)\n  }\n  elTracking.set(hash, cleanup)\n}\n\nfunction genRX(\n  ctx: RuntimeContext,\n  ...argNames: string[]\n): {\n  deps: Dependency[]\n  rxFn: RuntimeExpressionFunction\n} {\n  let userExpression = ''\n\n  // Use a set to ensure unique dependencies\n  const depSignalNames = new Set<string>()\n\n  // This regex allows Datastar expressions to support nested\n  // regex and strings that contain ; without breaking.\n  //\n  // Each of these regex defines a block type we want to match\n  // (importantly we ignore the content within these blocks):\n  //\n  // regex            \\/(\\\\\\/|[^\\/])*\\/\n  // double quotes      \"(\\\\\"|[^\\\"])*\"\n  // single quotes      '(\\\\'|[^'])*'\n  // ticks              `(\\\\`|[^`])*`\n  //\n  // We also want to match the non delimiter part of statements\n  // note we only support ; statement delimiters:\n  //\n  // [^;]\n  //\n  const statementRe =\n    /(\\/(\\\\\\/|[^\\/])*\\/|\"(\\\\\"|[^\\\"])*\"|'(\\\\'|[^'])*'|`(\\\\`|[^`])*`|[^;])+/gm\n  const statements = ctx.value.trim().match(statementRe)\n  if (statements) {\n    const lastIdx = statements.length - 1\n    const last = statements[lastIdx].trim()\n    if (!last.startsWith('return')) {\n      statements[lastIdx] = `return (${last});`\n    }\n    userExpression = statements.join(';\\n')\n  }\n\n  // Ignore any escaped values\n  const escaped = new Map<string, string>()\n  const escapeRe = new RegExp(`(?:${DSP})(.*?)(?:${DSS})`, 'gm')\n  for (const match of userExpression.matchAll(escapeRe)) {\n    const k = match[1]\n    const v = new Hash('dsEscaped').with(k).string\n    escaped.set(v, k)\n    userExpression = userExpression.replace(DSP + k + DSS, v)\n  }\n\n  const fnCall = /@(\\w*)\\(/gm\n  const matches = userExpression.matchAll(fnCall)\n  const methodsCalled = new Set<string>()\n  for (const match of matches) {\n    methodsCalled.add(match[1])\n  }\n\n  // Replace any action calls\n  const actionsRe = new RegExp(`@(${Object.keys(actions).join('|')})\\\\(`, 'gm')\n\n  // Add ctx to action calls\n  userExpression = userExpression.replaceAll(\n    actionsRe,\n    'ctx.actions.$1.fn(ctx,',\n  )\n\n  // Replace any signal calls\n  const signalNames = ctx.signals.paths()\n  if (signalNames.length) {\n    // Match any valid `$signalName` followed by a non-word character or end of string\n    const signalsRe = new RegExp(`\\\\$(${signalNames.join('|')})(\\\\W|$)`, 'gm')\n    userExpression = userExpression.replaceAll(\n      signalsRe,\n      `ctx.signals.signal('$1').value$2`,\n    )\n    // Add dependencies for signal value usages\n    const signalValueRe = /ctx.signals.signal\\('(.+?)'\\).value/gm\n    for (const match of userExpression.matchAll(signalValueRe)) {\n      depSignalNames.add(match[1])\n    }\n    // Add dependencies for `signals.JSON()` usage\n    if (userExpression.includes('ctx.signals.JSON()')) {\n      for (const signalName of ctx.signals.paths()) {\n        depSignalNames.add(signalName)\n      }\n    }\n  }\n\n\n  // Add signal dependencies\n  const deps = new Array<Dependency>()\n  for (const signalName of depSignalNames) {\n    const signal = ctx.signals.signal(signalName)\n    if (signal) {\n      deps.push(signal)\n    }\n  }\n\n  // Replace any escaped values\n  for (const [k, v] of escaped) {\n    userExpression = userExpression.replace(k, v)\n  }\n\n  const fnContent = `return (() => {\\n${userExpression}\\n})()` // Wrap in IIFE\n  ctx.fnContent = fnContent\n\n  try {\n    const fn = new Function('ctx', ...argNames, fnContent)\n    return {\n      deps,\n      rxFn: (...args: any[]) => {\n        try {\n          return fn(ctx, ...args)\n        } catch (error: any) {\n          throw runtimeErr('ExecuteExpression', ctx, {\n            error: error.message,\n          })\n        }\n      },\n    }\n  } catch (error: any) {\n    throw runtimeErr('GenerateExpression', ctx, {\n      error: error.message,\n    })\n  }\n}\n", "import { DSP } from '../engine/consts'\n// @ts-ignore\nconst _ = DSP // This is to force the import of DSP first in the compiled code\n\nimport { Computed } from '../plugins/official/core/attributes/computed'\nimport { Signals } from '../plugins/official/core/attributes/signals'\nimport { Star } from '../plugins/official/core/attributes/star'\nimport { apply, load, setAlias } from './engine'\n\nload(Star, Signals, Computed)\n\nexport { apply, load, setAlias }\n", "import { apply, load, setAlias } from '../engine'\n\napply()\n\nexport { apply, load, setAlias }\n"],
  "mappings": "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",
  "names": ["lol", "DSP", "DSS", "DATASTAR", "FragmentMergeModes", "DefaultFragmentMergeMode", "PluginType", "DATASTAR_SIGNAL_EVENT", "DATASTAR", "kebab", "str", "$", "ofs", "camel", "x", "snake", "pascal", "jsStrToObject", "raw", "caseFns", "kebab", "snake", "pascal", "modifyCasing", "str", "mods", "c", "fn", "name", "Computed", "key", "mods", "signals", "genRX", "modifyCasing", "deps", "rxFn", "Signals", "ctx", "key", "mods", "signals", "value", "genRX", "ifMissing", "rxFn", "k", "modifyCasing", "v", "obj", "jsStrToObject", "nv", "Star", "Hash", "#value", "#prefix", "prefix", "DATASTAR", "x", "c", "elUniqId", "el", "hash", "currentEl", "p", "attrHash", "key", "val", "walkDOM", "element", "callback", "dataset", "url", "dserr", "type", "reason", "metadata", "e", "DATASTAR", "snake", "q", "c", "internalErr", "from", "args", "initErr", "ctx", "errCtx", "PluginType", "runtimeErr", "from", "dispatchSignalEvent", "evt", "DATASTAR_SIGNAL_EVENT", "nestedValues", "signal", "onlyPublic", "kv", "key", "value", "Dependency", "mergeNested", "target", "values", "pathPrefix", "onlyIfMissing", "internalErr", "path", "subEvt", "k", "t", "Signal", "oldValue", "s", "walkNestedSignal", "cb", "nestedSubset", "original", "keys", "subset", "parts", "subOriginal", "subSubset", "i", "part", "last", "SignalsRoot", "#signals", "dotDelimitedPath", "parts", "subDeps", "part", "last", "dep", "internalErr", "from", "signal", "subSignals", "deps", "fn", "c", "computed", "value", "oldValue", "dispatchSignalEvent", "defaultValue", "i", "current", "Signal", "dotDelimitedPaths", "removed", "path", "other", "onlyIfMissing", "evt", "mergeNested", "keys", "nestedSubset", "cb", "walkNestedSignal", "signalNames", "onlyPublic", "nestedValues", "shouldIndent", "values", "Dependency", "Signal", "val", "onChange", "sub", "subscribers", "Derived", "Dependency", "deps", "fn", "dep", "depsVersionSum", "args", "currentVal", "sub", "subscribers", "computed", "Effect", "effect", "signals", "SignalsRoot", "actions", "plugins", "removals", "mutationObserver", "alias", "setAlias", "value", "load", "pluginsToLoad", "plugin", "ctx", "args", "cb", "effect", "applyToElement", "globalInitializer", "ap", "initErr", "a", "b", "lenDiff", "apply", "observe", "rootElement", "walkDOM", "el", "toApply", "elCleanups", "toCleanup", "hashes", "datasetKey", "datasetValue", "currentHash", "attrHash", "_", "cleanup", "key", "h", "applyAttributePlugin", "mutations", "toRemove", "target", "type", "addedNodes", "removedNodes", "node", "elTracking", "hash", "camelCasedKey", "rawKey", "camel", "p", "elUniqId", "rawModifiers", "hasKey", "hasValue", "genRX", "keyReq", "runtimeErr", "valReq", "rawMod", "label", "mod", "t", "argNames", "userExpression", "depSignalNames", "statementRe", "statements", "lastIdx", "last", "escaped", "escapeRe", "DSP", "DSS", "match", "k", "v", "Hash", "fnCall", "matches", "methodsCalled", "actionsRe", "signalNames", "signalsRe", "signalValueRe", "signalName", "deps", "signal", "fnContent", "fn", "error", "load", "Star", "Signals", "Computed", "apply"]
}
