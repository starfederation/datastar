{
  "version": 3,
  "sources": ["../library/src/engine/consts.ts", "../library/src/utils/paths.ts", "../library/src/utils/dom.ts", "../library/src/utils/text.ts", "../library/src/plugins/core/attributes/computed.ts", "../library/src/plugins/core/attributes/effect.ts", "../library/src/plugins/core/attributes/signals.ts", "../library/src/engine/errors.ts", "../library/src/engine/types.ts", "../library/src/engine/engine.ts", "../library/src/engine/index.ts", "../library/src/bundles/datastar-core.ts"],
  "sourcesContent": ["// This is auto-generated by Datastar. DO NOT EDIT.\nconst lol = /\uD83D\uDD95JS_DS\uD83D\uDE80/.source\nexport const DSP = lol.slice(0, 5)\nexport const DSS = lol.slice(4)\n\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_REQUEST = \"Datastar-Request\";\n\n// #region Defaults\n\n// #region Default durations\n\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000;\n\n// #endregion\n\n\n// #region Default strings\n\n\n// #endregion\n\n\n// #region Default booleans\n\n// Should elements be patched using the ViewTransition API?\nexport const DefaultElementsUseViewTransitions = false;\n\n// Should a given set of signals patch if they are missing?\nexport const DefaultPatchSignalsOnlyIfMissing = false;\n\n// #endregion\n\n\n// #region Enums\n\n// The mode in which a element is patched into the DOM.\n// Morphs the element into the existing element.\nexport const ElementPatchModeOuter = \"outer\"\n// Replaces the inner HTML of the existing element.\nexport const ElementPatchModeInner = \"inner\"\n// Removes the existing element.\nexport const ElementPatchModeRemove = \"remove\"\n// Replaces the existing element with the new element.\nexport const ElementPatchModeReplace = \"replace\"\n// Prepends the element inside to the existing element.\nexport const ElementPatchModePrepend = \"prepend\"\n// Appends the element inside the existing element.\nexport const ElementPatchModeAppend = \"append\"\n// Inserts the element before the existing element.\nexport const ElementPatchModeBefore = \"before\"\n// Inserts the element after the existing element.\nexport const ElementPatchModeAfter = \"after\"\n\n// Default value for ElementPatchMode\nexport const DefaultElementPatchMode = ElementPatchModeOuter;\n\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\n// An event for patching HTML elements into the DOM.\nexport const EventTypePatchElements = \"datastar-patch-elements\"\n// An event for patching signals.\nexport const EventTypePatchSignals = \"datastar-patch-signals\"\n// #endregion\n\n// #endregion", "export const isPojo = (obj: any): obj is Record<string, any> =>\n  obj !== null &&\n  typeof obj === 'object' &&\n  (Object.getPrototypeOf(obj) === Object.prototype ||\n    Object.getPrototypeOf(obj) === null)\n\nexport function isEmpty(obj: Record<string, any>): boolean {\n  for (const prop in obj) {\n    if (Object.hasOwn(obj, prop)) {\n      return false\n    }\n  }\n  return true\n}\n\nexport function updateLeaves(\n  obj: Record<string, any>,\n  fn: (oldValue: any) => any,\n) {\n  for (const key in obj) {\n    const val = obj[key]\n    if (isPojo(val) || Array.isArray(val)) {\n      updateLeaves(val, fn)\n    } else {\n      obj[key] = fn(val)\n    }\n  }\n}\n\nexport const pathToObj = (\n  target: Record<string, any>,\n  paths: Record<string, any>,\n): Record<string, any> => {\n  for (const path in paths) {\n    const keys = path.split('.')\n    const lastKey = keys.pop()!\n    const obj = keys.reduce((acc, key) => (acc[key] ??= {}), target)\n    obj[lastKey] = paths[path]\n  }\n  return target\n}\n", "import type { HTMLOrSVG } from '../engine/types'\n\nexport function isHTMLOrSVG(el: Node): el is HTMLOrSVG {\n  return el instanceof HTMLElement || el instanceof SVGElement\n}\n\nexport function findClosestScoped(el: HTMLOrSVG | null): string | null {\n  return (\n    (el?.closest('[data-scope]') as HTMLOrSVG | null)?.dataset.scope ?? null\n  )\n}\n", "import type { HTMLOrSVG, Modifiers } from '../engine/types'\nimport { findClosestScoped } from './dom'\n\nexport const isBoolString = (str: string) => str.trim() === 'true'\n\nexport const kebab = (str: string) =>\n  str\n    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')\n    .replace(/([a-z])([0-9]+)/gi, '$1-$2')\n    .replace(/([0-9]+)([a-z])/gi, '$1-$2')\n    .toLowerCase()\n\nexport const camel = (str: string) =>\n  kebab(str).replace(/-./g, (x) => x[1].toUpperCase())\n\nexport const snake = (str: string) => kebab(str).replace(/-/g, '_')\n\nexport const pascal = (str: string) =>\n  camel(str).replace(/(^.|(?<=\\.).)/g, (x) => x[0].toUpperCase())\n\nexport const jsStrToObject = (raw: string) => {\n  try {\n    return JSON.parse(raw)\n  } catch {\n    // If JSON parsing fails, try to evaluate as a JavaScript object\n    // This is less safe and should be used with caution\n    return Function(`return (${raw})`)()\n  }\n}\n\nconst caseFns: Record<string, (s: string) => string> = { kebab, snake, pascal }\n\nexport function modifyCasing(str: string, mods: Modifiers) {\n  for (const c of mods.get('case') || []) {\n    const fn = caseFns[c]\n    if (fn) str = fn(str)\n  }\n  return str\n}\n\nexport function modifyScope(\n  signalName: string,\n  el: HTMLOrSVG,\n  mods: Modifiers,\n) {\n  if (mods.has('scoped')) {\n    const scope = findClosestScoped(el)\n    if (scope) {\n      signalName = `${scope}.${signalName}`\n    }\n  }\n  return signalName\n}\n", "import type { AttributePlugin } from '../../../engine/types'\nimport { pathToObj } from '../../../utils/paths'\nimport { modifyCasing, modifyScope } from '../../../utils/text'\n\nexport const Computed: AttributePlugin = {\n  type: 'attribute',\n  name: 'computed',\n  keyReq: 'must',\n  valReq: 'must',\n  isExpr: true,\n  onLoad: ({ el, key, mods, rx, computed, mergePatch }) => {\n    let signalName = modifyCasing(key, mods)\n    signalName = modifyScope(signalName, el, mods)\n    mergePatch(pathToObj({}, { [signalName]: computed(rx) }))\n  },\n}\n", "import type { AttributePlugin } from '../../../engine/types'\n\nexport const Effect: AttributePlugin = {\n  type: 'attribute',\n  name: 'effect',\n  keyReq: 'denied',\n  valReq: 'must',\n  onLoad: ({ effect, rx }) => effect(rx),\n}\n", "import type { AttributePlugin } from '../../../engine/types'\nimport { pathToObj } from '../../../utils/paths'\nimport { modifyCasing, modifyScope } from '../../../utils/text'\n\nexport const Signals: AttributePlugin = {\n  type: 'attribute',\n  name: 'signals',\n  isExpr: true,\n  onLoad: ({ el, key, mods, rx, mergePatch }) => {\n    const ifMissing = mods.has('ifmissing')\n\n    if (key) {\n      key = modifyScope(modifyCasing(key, mods), el, mods)\n      mergePatch(pathToObj({}, { [key]: rx() }), { ifMissing })\n    } else {\n      const patch = rx<Record<string, any>>()\n      const pathObj: Record<string, any> = {}\n      for (const key in patch) {\n        pathObj[modifyScope(key, el, mods)] = patch[key]\n      }\n      mergePatch(pathToObj({}, pathObj), { ifMissing })\n    }\n  },\n}\n", "import { snake } from '../utils/text'\nimport { DATASTAR } from './consts'\nimport type { InitContext, RuntimeContext } from './types'\n\nconst url = 'https://data-star.dev/errors'\n\ninterface Metadata {\n  error?: string\n  [key: string]: any\n}\n\nfunction dserr(type: string, reason: string, metadata: Metadata = {}) {\n  const e = new Error()\n  e.name = `${DATASTAR} ${type} error`\n  const r = snake(reason)\n  const q = new URLSearchParams({\n    metadata: JSON.stringify(metadata),\n  }).toString()\n  const c = JSON.stringify(metadata, null, 2)\n  e.message = `${reason}\\nMore info: ${url}/${type}/${r}?${q}\\nContext: ${c}`\n  return e\n}\n\nexport function internalErr(from: string, reason: string, args = {}) {\n  return dserr('internal', reason, Object.assign({ from }, args))\n}\n\nexport function initErr(reason: string, ctx: InitContext, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: ctx.plugin.type,\n    },\n  }\n  return dserr('init', reason, Object.assign(errCtx, metadata))\n}\n\nexport function runtimeErr(ctx: RuntimeContext, reason: string, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: ctx.plugin.type,\n    },\n    element: {\n      id: ctx.el.id,\n      tag: ctx.el.tagName,\n    },\n    expression: {\n      rawKey: ctx.rawKey,\n      key: ctx.key,\n      value: ctx.value,\n      // validSignals:\n      fnContent: ctx.fnContent,\n    },\n  }\n  return dserr('runtime', reason, Object.assign(errCtx, metadata))\n}\n", "import { DATASTAR } from './consts'\nexport type PluginType = 'attribute' | 'watcher' | 'action'\nexport type Requirement = 'allowed' | 'must' | 'denied' | 'exclusive'\n\n// export type ReactiveNode = Signal | Computed | Effect\n// export type Subscriber = Computed | Effect\nexport type OnRemovalFn = () => void\n\nexport type DatastarPlugin = AttributePlugin | WatcherPlugin | ActionPlugin\n\nexport const DATASTAR_SIGNAL_PATCH_EVENT = `${DATASTAR}-signal-patch`\nexport type JSONPatch = Record<string, any>\n\nexport interface CustomEventMap {\n  [DATASTAR_SIGNAL_PATCH_EVENT]: CustomEvent<JSONPatch>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\ndeclare global {\n  interface Document {\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n  }\n}\n\n// A plugin accessible via a `data-${name}` attribute on an element\nexport type AttributePlugin = {\n  type: 'attribute'\n  name: string // The name of the plugin\n  onGlobalInit?: (ctx: InitContext) => void // Called once on registration of the plugin\n  onLoad: (ctx: RuntimeContext) => OnRemovalFn | void // Return a function to be called on removal\n  keyReq?: Requirement // The rules for the key requirements\n  valReq?: Requirement // The rules for the value requirements\n  isExpr?: boolean // If the value is an expression\n  argNames?: string[] // argument names for the reactive expression\n}\n\n// A plugin that runs on the global scope of the Datastar instance\nexport type WatcherPlugin = {\n  type: 'watcher'\n  name: string // The name of the plugin\n  onGlobalInit?: (ctx: InitContext) => void\n}\n\nexport type ActionPlugins = Record<string, ActionPlugin>\nexport type ActionMethod = (ctx: RuntimeContext, ...args: any[]) => any\n\nexport type ActionPlugin = {\n  type: 'action'\n  name: string // The name of the plugin\n  fn: ActionMethod\n}\n\nexport type GlobalInitializer = (ctx: InitContext) => void\n\nexport type InitContext = {\n  plugin: DatastarPlugin // The plugin instance\n  actions: Readonly<ActionPlugins> // All registered actions\n  root: Record<string, any> // global signals and computed signals\n  filtered: (opts?: SignalFilterOptions, obj?: JSONPatch) => Record<string, any>\n  signal<T>(initialValue?: T | undefined): Signal<T> // creates a signal\n  computed<T>(getter: (previousValue?: T) => T): Computed<T> // creates a computed signal\n  effect(fn: (...args: any[]) => void): OnRemovalFn // creates an effect\n  mergePatch: (patch: any, args?: { ifMissing?: boolean }) => any\n  peek: <T>(fn: () => T) => T // returns the current state of the signal without subscribing\n  getPath: <T = any>(path: string) => T // get a value from the root\n  hasPath: (path: string) => boolean // check if a path exists from the root\n  startBatch: () => void // starts a signal batch\n  endBatch: () => void // ends a signal batch\n}\n\nexport type HTMLOrSVG = Element & (HTMLElement | SVGElement)\nexport type Modifiers = Map<string, Set<string>> // mod name -> tags\nexport type ReactiveExpressionFn = <T>(...argsThenDeps: any[]) => T // a reactive expression\n\nexport type RuntimeContext = InitContext & {\n  el: HTMLOrSVG // The element the attribute is on\n  rawKey: Readonly<string> // no parsing data-* key\n  key: Readonly<string> // data-* key without the prefix or tags\n  value: Readonly<string> // value of data-* attribute\n  mods: Modifiers // the modifiers and their tags\n  rx: ReactiveExpressionFn // function to generate a reactive expression\n  fnContent?: string // the content of the function\n  evt?: Event // the event that triggered the plugin\n  runtimeErr: (reason: string, metadata?: object) => Error\n}\n\nexport type RuntimeExpressionFunction = (\n  ctx: RuntimeContext,\n  ...args: any[]\n) => any\n\nexport type EventCallbackHandler = (...args: any[]) => void\n\nexport type SignalFilter = RegExp\nexport type SignalFilterOptions = {\n  include?: RegExp\n  exclude?: RegExp\n}\n\nexport type Signal<T = any> = {\n  (): T\n  (value: T): boolean\n}\n\nexport type Computed<T = any> = () => T\n\nexport type Effect = () => void\n", "import { findClosestScoped, isHTMLOrSVG } from '../utils/dom'\nimport { isEmpty, isPojo, pathToObj } from '../utils/paths'\nimport { camel, snake } from '../utils/text'\nimport { DATASTAR, DSP, DSS } from './consts'\nimport { initErr, runtimeErr } from './errors'\nimport type {\n  ActionPlugins,\n  AttributePlugin,\n  Computed,\n  DatastarPlugin,\n  Effect,\n  HTMLOrSVG,\n  InitContext,\n  JSONPatch,\n  OnRemovalFn,\n  RuntimeContext,\n  RuntimeExpressionFunction,\n  Signal,\n  SignalFilterOptions,\n} from './types'\nimport { DATASTAR_SIGNAL_PATCH_EVENT } from './types'\n\n/**\n * Custom signals implementation based on Alien Signals\n */\n\ninterface ReactiveNode {\n  deps_?: Link\n  depsTail_?: Link\n  subs_?: Link\n  subsTail_?: Link\n  flags_: ReactiveFlags\n}\n\ninterface Link {\n  dep_: ReactiveNode\n  sub_: ReactiveNode\n  prevSub_?: Link\n  nextSub_?: Link\n  prevDep_?: Link\n  nextDep_?: Link\n}\n\ninterface Stack<T> {\n  value_: T\n  prev_?: Stack<T>\n}\n\nenum ReactiveFlags {\n  None = 0,\n  Mutable = 1 << 0,\n  Watching = 1 << 1,\n  RecursedCheck = 1 << 2,\n  Recursed = 1 << 3,\n  Dirty = 1 << 4,\n  Pending = 1 << 5,\n}\n\nenum EffectFlags {\n  Queued = 1 << 6,\n}\n\ninterface AlienEffect extends ReactiveNode {\n  fn_(): void\n}\n\ninterface AlienComputed<T = any> extends ReactiveNode {\n  value_?: T\n  getter(previousValue?: T): T\n}\n\ninterface AlienSignal<T = any> extends ReactiveNode {\n  previousValue: T\n  value_: T\n}\n\nlet currentPatch: Record<string, any> = {}\nconst queuedEffects: (AlienEffect | undefined)[] = []\nlet batchDepth = 0\nlet notifyIndex = 0\nlet queuedEffectsLength = 0\nlet activeSub: ReactiveNode | undefined\n\nconst startBatch = (): void => {\n  batchDepth++\n}\nconst endBatch = (): void => {\n  if (!--batchDepth) {\n    flush()\n    dispatch()\n  }\n}\n\nconst signal = <T>(initialValue?: T): Signal<T> => {\n  return signalOper.bind(0, {\n    previousValue: initialValue,\n    value_: initialValue,\n    flags_: 1 satisfies ReactiveFlags.Mutable,\n  }) as Signal<T>\n}\n\nconst computedSymbol = Symbol('computed')\nconst computed = <T>(getter: (previousValue?: T) => T): Computed<T> => {\n  const c = computedOper.bind(0, {\n    flags_: 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty,\n    getter,\n  }) as Computed<T>\n  // @ts-ignore\n  c[computedSymbol] = 1\n  return c\n}\n\nconst effect = (fn: () => void): Effect => {\n  const e: AlienEffect = {\n    fn_: fn,\n    flags_: 2 satisfies ReactiveFlags.Watching,\n  }\n  if (activeSub) {\n    link(e, activeSub)\n  }\n  const prev = setCurrentSub(e)\n  startBatch()\n  try {\n    e.fn_()\n  } finally {\n    endBatch()\n    setCurrentSub(prev)\n  }\n  return effectOper.bind(0, e)\n}\n\nconst peek = <T>(fn: () => T): T => {\n  const prev = setCurrentSub(undefined)\n  try {\n    return fn()\n  } finally {\n    setCurrentSub(prev)\n  }\n}\n\nconst flush = () => {\n  while (notifyIndex < queuedEffectsLength) {\n    const effect = queuedEffects[notifyIndex]!\n    queuedEffects[notifyIndex++] = undefined\n    run(effect, (effect.flags_ &= ~EffectFlags.Queued))\n  }\n  notifyIndex = 0\n  queuedEffectsLength = 0\n}\n\nconst update = (signal: AlienSignal | AlienComputed): boolean => {\n  if ('getter' in signal) {\n    return updateComputed(signal)\n  }\n  return updateSignal(signal, signal.value_)\n}\n\nconst setCurrentSub = (sub?: ReactiveNode): ReactiveNode | undefined => {\n  const prevSub = activeSub\n  activeSub = sub\n  return prevSub\n}\n\nconst updateComputed = (c: AlienComputed): boolean => {\n  const prevSub = setCurrentSub(c)\n  startTracking(c)\n  try {\n    const oldValue = c.value_\n    return oldValue !== (c.value_ = c.getter(oldValue))\n  } finally {\n    setCurrentSub(prevSub)\n    endTracking(c)\n  }\n}\n\nconst updateSignal = (s: AlienSignal, value: any): boolean => {\n  s.flags_ = 1 satisfies ReactiveFlags.Mutable\n  return s.previousValue !== (s.previousValue = value)\n}\n\nconst notify = (e: AlienEffect): void => {\n  const flags = e.flags_\n  if (!(flags & EffectFlags.Queued)) {\n    e.flags_ = flags | EffectFlags.Queued\n    const subs = e.subs_\n    if (subs) {\n      notify(subs.sub_ as AlienEffect)\n    } else {\n      queuedEffects[queuedEffectsLength++] = e\n    }\n  }\n}\n\nconst run = (e: AlienEffect, flags: ReactiveFlags): void => {\n  if (\n    flags & (16 satisfies ReactiveFlags.Dirty) ||\n    (flags & (32 satisfies ReactiveFlags.Pending) && checkDirty(e.deps_!, e))\n  ) {\n    const prev = setCurrentSub(e)\n    startTracking(e)\n    startBatch()\n    try {\n      e.fn_()\n    } finally {\n      endBatch()\n      setCurrentSub(prev)\n      endTracking(e)\n    }\n    return\n  }\n  if (flags & (32 satisfies ReactiveFlags.Pending)) {\n    e.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending)\n  }\n  let link = e.deps_\n  while (link) {\n    const dep = link.dep_\n    const depFlags = dep.flags_\n    if (depFlags & EffectFlags.Queued) {\n      run(dep as AlienEffect, (dep.flags_ = depFlags & ~EffectFlags.Queued))\n    }\n    link = link.nextDep_\n  }\n}\n\nconst computedOper = <T>(c: AlienComputed<T>): T => {\n  const flags = c.flags_\n  if (\n    flags & (16 satisfies ReactiveFlags.Dirty) ||\n    (flags & (32 satisfies ReactiveFlags.Pending) && checkDirty(c.deps_!, c))\n  ) {\n    if (updateComputed(c)) {\n      const subs = c.subs_\n      if (subs) {\n        shallowPropagate(subs)\n      }\n    }\n  } else if (flags & (32 satisfies ReactiveFlags.Pending)) {\n    c.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending)\n  }\n  if (activeSub) {\n    link(c, activeSub)\n  }\n  return c.value_!\n}\n\nconst signalOper = <T>(s: AlienSignal<T>, ...value: [T]): T | boolean => {\n  if (value.length) {\n    const newValue = value[0]\n    if (s.value_ !== (s.value_ = newValue)) {\n      s.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty\n      const subs = s.subs_\n      if (subs) {\n        propagate(subs)\n        if (!batchDepth) {\n          flush()\n        }\n      }\n      return true\n    }\n    return false\n  }\n  const currentValue = s.value_\n  if (s.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n    if (updateSignal(s, currentValue)) {\n      const subs_ = s.subs_\n      if (subs_) {\n        shallowPropagate(subs_)\n      }\n    }\n  }\n  if (activeSub) {\n    link(s, activeSub)\n  }\n  return currentValue\n}\n\nconst effectOper = (e: AlienEffect): void => {\n  let dep = e.deps_\n  while (dep) {\n    dep = unlink(dep, e)\n  }\n  const sub = e.subs_\n  if (sub) {\n    unlink(sub)\n  }\n  e.flags_ = 0 satisfies ReactiveFlags.None\n}\n\nconst link = (dep: ReactiveNode, sub: ReactiveNode): void => {\n  const prevDep = sub.depsTail_\n  if (prevDep && prevDep.dep_ === dep) {\n    return\n  }\n  let nextDep: Link | undefined\n  const recursedCheck = sub.flags_ & (4 satisfies ReactiveFlags.RecursedCheck)\n  if (recursedCheck) {\n    nextDep = prevDep ? prevDep.nextDep_ : sub.deps_\n    if (nextDep && nextDep.dep_ === dep) {\n      sub.depsTail_ = nextDep\n      return\n    }\n  }\n  const prevSub = dep.subsTail_\n  if (\n    prevSub &&\n    prevSub.sub_ === sub &&\n    (!recursedCheck || isValidLink(prevSub, sub))\n  ) {\n    return\n  }\n  const newLink =\n    (sub.depsTail_ =\n    dep.subsTail_ =\n      {\n        dep_: dep,\n        sub_: sub,\n        prevDep_: prevDep,\n        nextDep_: nextDep,\n        prevSub_: prevSub,\n      })\n  if (nextDep) {\n    nextDep.prevDep_ = newLink\n  }\n  if (prevDep) {\n    prevDep.nextDep_ = newLink\n  } else {\n    sub.deps_ = newLink\n  }\n  if (prevSub) {\n    prevSub.nextSub_ = newLink\n  } else {\n    dep.subs_ = newLink\n  }\n}\n\nconst unlink = (link: Link, sub_ = link.sub_): Link | undefined => {\n  const dep_ = link.dep_\n  const prevDep_ = link.prevDep_\n  const nextDep_ = link.nextDep_\n  const nextSub_ = link.nextSub_\n  const prevSub_ = link.prevSub_\n  if (nextDep_) {\n    nextDep_.prevDep_ = prevDep_\n  } else {\n    sub_.depsTail_ = prevDep_\n  }\n  if (prevDep_) {\n    prevDep_.nextDep_ = nextDep_\n  } else {\n    sub_.deps_ = nextDep_\n  }\n  if (nextSub_) {\n    nextSub_.prevSub_ = prevSub_\n  } else {\n    dep_.subsTail_ = prevSub_\n  }\n  if (prevSub_) {\n    prevSub_.nextSub_ = nextSub_\n  } else if (!(dep_.subs_ = nextSub_)) {\n    if ('getter' in dep_) {\n      let toRemove = dep_.deps_\n      if (toRemove) {\n        dep_.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty\n        do {\n          toRemove = unlink(toRemove, dep_)\n        } while (toRemove)\n      }\n    } else if (!('previousValue' in dep_)) {\n      effectOper(dep_ as AlienEffect)\n    }\n  }\n  return nextDep_\n}\n\nconst propagate = (link: Link): void => {\n  let next = link.nextSub_\n  let stack: Stack<Link | undefined> | undefined\n\n  top: while (true) {\n    const sub = link.sub_\n\n    let flags = sub.flags_\n\n    if (flags & (3 as ReactiveFlags.Mutable | ReactiveFlags.Watching)) {\n      if (\n        !(\n          flags &\n          (60 as\n            | ReactiveFlags.RecursedCheck\n            | ReactiveFlags.Recursed\n            | ReactiveFlags.Dirty\n            | ReactiveFlags.Pending)\n        )\n      ) {\n        sub.flags_ = flags | (32 satisfies ReactiveFlags.Pending)\n      } else if (\n        !(flags & (12 as ReactiveFlags.RecursedCheck | ReactiveFlags.Recursed))\n      ) {\n        flags = 0 satisfies ReactiveFlags.None\n      } else if (!(flags & (4 satisfies ReactiveFlags.RecursedCheck))) {\n        sub.flags_ =\n          (flags & ~(8 satisfies ReactiveFlags.Recursed)) |\n          (32 satisfies ReactiveFlags.Pending)\n      } else if (\n        !(flags & (48 as ReactiveFlags.Dirty | ReactiveFlags.Pending)) &&\n        isValidLink(link, sub)\n      ) {\n        sub.flags_ =\n          flags | (40 as ReactiveFlags.Recursed | ReactiveFlags.Pending)\n        flags &= 1 satisfies ReactiveFlags.Mutable\n      } else {\n        flags = 0 satisfies ReactiveFlags.None\n      }\n\n      if (flags & (2 satisfies ReactiveFlags.Watching)) {\n        notify(sub as AlienEffect)\n      }\n\n      if (flags & (1 satisfies ReactiveFlags.Mutable)) {\n        const subSubs = sub.subs_\n        if (subSubs) {\n          link = subSubs\n          if (subSubs.nextSub_) {\n            stack = { value_: next, prev_: stack }\n            next = link.nextSub_\n          }\n          continue\n        }\n      }\n    }\n\n    if ((link = next!)) {\n      next = link.nextSub_\n      continue\n    }\n\n    while (stack) {\n      link = stack.value_!\n      stack = stack.prev_\n      if (link) {\n        next = link.nextSub_\n        continue top\n      }\n    }\n\n    break\n  }\n}\n\nconst startTracking = (sub: ReactiveNode): void => {\n  sub.depsTail_ = undefined\n  sub.flags_ =\n    (sub.flags_ &\n      ~(56 as\n        | ReactiveFlags.Recursed\n        | ReactiveFlags.Dirty\n        | ReactiveFlags.Pending)) |\n    (4 satisfies ReactiveFlags.RecursedCheck)\n}\n\nconst endTracking = (sub: ReactiveNode): void => {\n  const depsTail_ = sub.depsTail_\n  let toRemove = depsTail_ ? depsTail_.nextDep_ : sub.deps_\n  while (toRemove) {\n    toRemove = unlink(toRemove, sub)\n  }\n  sub.flags_ &= ~(4 satisfies ReactiveFlags.RecursedCheck)\n}\n\nconst checkDirty = (link: Link, sub: ReactiveNode): boolean => {\n  let stack: Stack<Link> | undefined\n  let checkDepth = 0\n\n  top: while (true) {\n    const dep = link.dep_\n    const depFlags = dep.flags_\n\n    let dirty = false\n\n    if (sub.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n      dirty = true\n    } else if (\n      (depFlags & (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)) ===\n      (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)\n    ) {\n      if (update(dep as AlienSignal | AlienComputed)) {\n        const subs = dep.subs_!\n        if (subs.nextSub_) {\n          shallowPropagate(subs)\n        }\n        dirty = true\n      }\n    } else if (\n      (depFlags & (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)) ===\n      (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)\n    ) {\n      if (link.nextSub_ || link.prevSub_) {\n        stack = { value_: link, prev_: stack }\n      }\n      link = dep.deps_!\n      sub = dep\n      ++checkDepth\n      continue\n    }\n\n    if (!dirty && link.nextDep_) {\n      link = link.nextDep_\n      continue\n    }\n\n    while (checkDepth) {\n      --checkDepth\n      const firstSub = sub.subs_!\n      const hasMultipleSubs = firstSub.nextSub_\n      if (hasMultipleSubs) {\n        link = stack!.value_\n        stack = stack!.prev_\n      } else {\n        link = firstSub\n      }\n      if (dirty) {\n        if (update(sub as AlienSignal | AlienComputed)) {\n          if (hasMultipleSubs) {\n            shallowPropagate(firstSub)\n          }\n          sub = link.sub_\n          continue\n        }\n      } else {\n        sub.flags_ &= ~(32 satisfies ReactiveFlags.Pending)\n      }\n      sub = link.sub_\n      if (link.nextDep_) {\n        link = link.nextDep_\n        continue top\n      }\n      dirty = false\n    }\n\n    return dirty\n  }\n}\n\nconst shallowPropagate = (link: Link): void => {\n  do {\n    const sub = link.sub_\n    const nextSub = link.nextSub_\n    const subFlags = sub.flags_\n    if (\n      (subFlags & (48 as ReactiveFlags.Pending | ReactiveFlags.Dirty)) ===\n      (32 satisfies ReactiveFlags.Pending)\n    ) {\n      sub.flags_ = subFlags | (16 satisfies ReactiveFlags.Dirty)\n      if (subFlags & (2 satisfies ReactiveFlags.Watching)) {\n        notify(sub as AlienEffect)\n      }\n    }\n    link = nextSub!\n  } while (link)\n}\n\nconst isValidLink = (checkLink: Link, sub: ReactiveNode): boolean => {\n  const depsTail = sub.depsTail_\n  if (depsTail) {\n    let link = sub.deps_!\n    do {\n      if (link === checkLink) {\n        return true\n      }\n      if (link === depsTail) {\n        break\n      }\n      link = link.nextDep_!\n    } while (link)\n  }\n  return false\n}\n\nconst getPath = <T = any>(path: string): T =>\n  path.split('.').reduce((acc, key) => acc[key], root) as T\n\nconst hasPath = (path: string): boolean =>\n  peek(\n    () =>\n      path\n        .split('.')\n        .reduce(\n          (obj, key) => (obj && Object.hasOwn(obj, key) ? obj[key] : undefined),\n          root,\n        ) !== undefined,\n  )\n\nconst deep = (value: any, prefix = ''): any => {\n  const isArr = Array.isArray(value)\n  if (isArr || isPojo(value)) {\n    const deepObj = (isArr ? [] : {}) as Record<string, Signal>\n    for (const key in value) {\n      deepObj[key] = signal(\n        deep((value as Record<string, Signal>)[key], `${prefix + key}.`),\n      )\n    }\n    const keys = signal(0)\n    return new Proxy(deepObj, {\n      get: (_, prop: string) => {\n        if (prop === 'toJSON' && !Object.hasOwn(deepObj, prop)) {\n          return\n        }\n        if (isArr && prop in Array.prototype) {\n          keys()\n          return deepObj[prop]\n        }\n        if (!Object.hasOwn(deepObj, prop)) {\n          deepObj[prop] = signal('')\n          dispatch({ [prefix + prop]: '' })\n          keys(keys() + 1)\n        }\n        return deepObj[prop]()\n      },\n      set: (_, prop: string, newValue) => {\n        if (isArr && prop === 'length') {\n          deepObj[prop] = newValue\n          dispatch({ [prefix.slice(0, -1)]: deepObj })\n          keys(keys() + 1)\n          return true\n        }\n\n        if (Object.hasOwn(deepObj, prop)) {\n          if (newValue === null || newValue === undefined) {\n            delete deepObj[prop]\n            dispatch({ [prefix + prop]: null })\n            keys(keys() + 1)\n            return true\n          }\n          if (deepObj[prop](deep(newValue, `${prefix + prop}.`))) {\n            dispatch({ [prefix + prop]: newValue })\n          }\n        } else {\n          if (newValue === null || newValue === undefined) {\n            return true\n          }\n          if (Object.hasOwn(newValue, computedSymbol)) {\n            deepObj[prop] = newValue\n            dispatch({ [prefix + prop]: '' })\n          } else {\n            deepObj[prop] = signal(deep(newValue, `${prefix + prop}.`))\n            dispatch({ [prefix + prop]: newValue })\n          }\n\n          keys(keys() + 1)\n        }\n\n        return true\n      },\n      deleteProperty: (_, prop: string) => {\n        if (Object.hasOwn(deepObj, prop)) {\n          delete deepObj[prop]\n          dispatch({ [prefix + prop]: null })\n          keys(keys() + 1)\n        }\n\n        return true\n      },\n      ownKeys: () => {\n        keys()\n        return Reflect.ownKeys(deepObj)\n      },\n      has(_, prop) {\n        keys()\n        return prop in deepObj\n      },\n    })\n  }\n  return value\n}\n\nconst dispatch = (obj?: Record<string, any>) => {\n  if (obj) {\n    pathToObj(currentPatch, obj)\n  }\n  if (!batchDepth && !isEmpty(currentPatch)) {\n    const oldPatch = currentPatch\n    currentPatch = {}\n    document.dispatchEvent(\n      new CustomEvent<JSONPatch>(DATASTAR_SIGNAL_PATCH_EVENT, {\n        detail: oldPatch,\n      }),\n    )\n  }\n}\n\nconst mergePatch = (\n  patch: Record<string, any>,\n  { ifMissing }: { ifMissing?: boolean } = {},\n): void => {\n  startBatch()\n  for (const key in patch) {\n    if (patch[key] === null || patch[key] === undefined) {\n      if (!ifMissing) {\n        delete root[key]\n      }\n    } else {\n      mergeInner(patch[key], key, root, '', ifMissing)\n    }\n  }\n  endBatch()\n}\n\nconst mergeInner = (\n  patch: any,\n  target: string,\n  targetParent: Record<string, any>,\n  prefix: string,\n  ifMissing: boolean | undefined,\n): void => {\n  if (isPojo(patch)) {\n    if (\n      !(\n        Object.hasOwn(targetParent, target) &&\n        (isPojo(targetParent[target]) || Array.isArray(targetParent[target]))\n      )\n    ) {\n      targetParent[target] = {}\n    }\n\n    for (const key in patch) {\n      if (patch[key] === null || patch[key] === undefined) {\n        if (!ifMissing) {\n          delete targetParent[target][key]\n        }\n      } else {\n        mergeInner(\n          patch[key],\n          key,\n          targetParent[target],\n          `${prefix + target}.`,\n          ifMissing,\n        )\n      }\n    }\n  } else if (!(ifMissing && Object.hasOwn(targetParent, target))) {\n    targetParent[target] = patch\n  }\n}\n\nfunction filtered(\n  { include = /.*/, exclude = /(?!)/ }: SignalFilterOptions = {},\n  obj: JSONPatch = root,\n) {\n  // We need to find all valid signal paths in the object\n  const pathObj: Record<string, any> = {}\n  const stack: Array<[any, string]> = [[obj, '']]\n\n  while (stack.length) {\n    const [node, prefix] = stack.pop()!\n\n    for (const key in node) {\n      if (isPojo(node[key])) {\n        stack.push([node[key], `${prefix + key}.`])\n      } else if (include.test(prefix + key) && !exclude.test(prefix + key)) {\n        pathObj[prefix + key] = getPath(prefix + key)\n      }\n    }\n  }\n\n  return pathToObj({}, pathObj)\n}\n\nconst root: Record<string, any> = deep({})\n\n/**\n * Turn data-* attributes into reactive expressions\n * This is the core of the Datastar\n */\n\nconst actions: ActionPlugins = {}\nconst plugins: AttributePlugin[] = []\nlet pluginRegexs: RegExp[] = []\n\n// Map of cleanup functions by element, keyed by a dataset key-value hash\nconst removals = new Map<HTMLOrSVG, Map<string, OnRemovalFn>>()\n\nlet mutationObserver: MutationObserver | null = null\n\nlet alias = ''\nexport function setAlias(value: string) {\n  alias = value\n}\nexport function aliasify(name: string) {\n  return alias ? `data-${alias}-${name}` : `data-${name}`\n}\n\nexport function load(...pluginsToLoad: DatastarPlugin[]) {\n  for (const plugin of pluginsToLoad) {\n    const ctx: InitContext = {\n      plugin,\n      actions,\n      root,\n      filtered,\n      signal,\n      computed,\n      effect,\n      mergePatch,\n      peek,\n      getPath,\n      hasPath,\n      startBatch,\n      endBatch,\n    }\n    if (plugin.type === 'action') {\n      actions[plugin.name] = plugin\n    } else if (plugin.type === 'attribute') {\n      plugins.push(plugin)\n      plugin.onGlobalInit?.(ctx)\n    } else if (plugin.type === 'watcher') {\n      plugin.onGlobalInit?.(ctx)\n    } else {\n      throw initErr('InvalidPluginType', ctx)\n    }\n  }\n\n  // Sort attribute plugins by descending length then alphabetically\n  plugins.sort((a, b) => {\n    const lenDiff = b.name.length - a.name.length\n    if (lenDiff !== 0) return lenDiff\n    return a.name.localeCompare(b.name)\n  })\n\n  pluginRegexs = plugins.map((plugin) => RegExp(`^${plugin.name}([A-Z]|_|$)`))\n}\n\nfunction applyEls(els: Iterable<HTMLOrSVG>): void {\n  const ignore = `[${aliasify('ignore')}]`\n  for (const el of els) {\n    if (!el.closest(ignore)) {\n      for (const key in el.dataset) {\n        applyAttributePlugin(el, key, el.dataset[key]!)\n      }\n    }\n  }\n}\n\n// Apply all plugins to the entire DOM or a provided element\nexport function apply(root: HTMLOrSVG = document.body) {\n  // Delay applying plugins to give custom plugins a chance to load\n  queueMicrotask(() => {\n    applyEls([root])\n    applyEls(root.querySelectorAll<HTMLOrSVG>('*'))\n\n    // Monitor the entire document body or a provided element for changes\n    // https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe\n    if (!mutationObserver) {\n      mutationObserver = new MutationObserver(observe)\n      mutationObserver.observe(root, {\n        subtree: true,\n        childList: true,\n        attributes: true,\n      })\n    }\n  })\n}\n\nfunction applyAttributePlugin(\n  el: HTMLOrSVG,\n  attrKey: string,\n  value: string,\n): void {\n  const rawKey = camel(alias ? attrKey.slice(alias.length) : attrKey)\n  const plugin = plugins.find((_, i) => pluginRegexs[i].test(rawKey))\n  if (plugin) {\n    // Extract the key and modifiers\n    let [key, ...rawModifiers] = rawKey.slice(plugin.name.length).split(/__+/)\n\n    const hasKey = !!key\n    if (hasKey) {\n      key = camel(key)\n    }\n    const hasValue = !!value\n\n    // Create the runtime context\n    const ctx: RuntimeContext = {\n      plugin,\n      actions,\n      root,\n      filtered,\n      signal,\n      computed,\n      effect,\n      mergePatch,\n      peek,\n      getPath,\n      hasPath,\n      startBatch,\n      endBatch,\n      el,\n      rawKey,\n      key,\n      value,\n      mods: new Map(),\n      runtimeErr: 0 as any,\n      rx: 0 as any,\n    }\n    ctx.runtimeErr = runtimeErr.bind(0, ctx)\n    ctx.rx = generateReactiveExpression(ctx)\n\n    // Check the requirements\n    const keyReq = plugin.keyReq || 'allowed'\n    if (hasKey) {\n      if (keyReq === 'denied') {\n        throw ctx.runtimeErr(`${plugin.name}KeyNotAllowed`)\n      }\n    } else if (keyReq === 'must') {\n      throw ctx.runtimeErr(`${plugin.name}KeyRequired`)\n    }\n\n    const valReq = plugin.valReq || 'allowed'\n    if (hasValue) {\n      if (valReq === 'denied') {\n        throw ctx.runtimeErr(`${plugin.name}ValueNotAllowed`)\n      }\n    } else if (valReq === 'must') {\n      throw ctx.runtimeErr(`${plugin.name}ValueRequired`)\n    }\n\n    // Check for exclusive requirements\n    if (keyReq === 'exclusive' || valReq === 'exclusive') {\n      if (hasKey && hasValue) {\n        throw ctx.runtimeErr(`${plugin.name}KeyAndValueProvided`)\n      }\n      if (!hasKey && !hasValue) {\n        throw ctx.runtimeErr(`${plugin.name}KeyOrValueRequired`)\n      }\n    }\n\n    for (const rawMod of rawModifiers) {\n      const [label, ...mod] = rawMod.split('.')\n      ctx.mods.set(camel(label), new Set(mod.map((t) => t.toLowerCase())))\n    }\n\n    const cleanup = plugin.onLoad(ctx)\n    if (cleanup) {\n      let cleanups = removals.get(el)\n      if (cleanups) {\n        cleanups.get(rawKey)?.()\n      } else {\n        cleanups = new Map()\n        removals.set(el, cleanups)\n      }\n      cleanups.set(rawKey, cleanup)\n    }\n  }\n}\n\n// Set up a mutation observer to run plugin removal and apply functions\nfunction observe(mutations: MutationRecord[]) {\n  const ignore = `[${aliasify('ignore')}]`\n\n  for (const {\n    target,\n    type,\n    attributeName,\n    addedNodes,\n    removedNodes,\n  } of mutations) {\n    if (type === 'childList') {\n      for (const node of removedNodes) {\n        if (isHTMLOrSVG(node)) {\n          const cleanups = removals.get(node)\n          // If removals has el, delete it and run all cleanup functions\n          if (removals.delete(node)) {\n            for (const cleanup of cleanups!.values()) {\n              cleanup()\n            }\n            cleanups!.clear()\n          }\n        }\n      }\n\n      for (const node of addedNodes) {\n        if (isHTMLOrSVG(node)) {\n          applyEls([node])\n          applyEls(node.querySelectorAll<HTMLOrSVG>('*'))\n        }\n      }\n    } else if (type === 'attributes') {\n      // If el has a parent with data-ignore, skip it\n      if (isHTMLOrSVG(target) && !target.closest(ignore)) {\n        const key = camel(attributeName!.slice(5))\n        const value = target.getAttribute(attributeName!)\n        if (value === null) {\n          const cleanups = removals.get(target)\n          if (cleanups) {\n            cleanups.get(key)?.()\n            cleanups.delete(key)\n          }\n        } else {\n          applyAttributePlugin(target, key, value)\n        }\n      }\n    }\n  }\n}\n\nfunction generateReactiveExpression(\n  ctx: RuntimeContext,\n): RuntimeExpressionFunction {\n  let expr = ''\n\n  const attrPlugin = (ctx.plugin as AttributePlugin) || undefined\n\n  // plugin is guaranteed to be an attribute plugin\n  if (attrPlugin?.isExpr) {\n    // This regex allows Datastar expressions to support nested\n    // regex and strings that contain ; without breaking.\n    //\n    // Each of these regex defines a block type we want to match\n    // (importantly we ignore the content within these blocks):\n    //\n    // regex            \\/(\\\\\\/|[^\\/])*\\/\n    // double quotes      \"(\\\\\"|[^\\\"])*\"\n    // single quotes      '(\\\\'|[^'])*'\n    // ticks              `(\\\\`|[^`])*`\n    // iife               \\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;)\\{]*)\\s*\\)\\s*\\(\\s*\\)\n    //\n    // The iife support is (intentionally) limited. It only supports\n    // function and arrow syntax with no arguments, and no nested IIFEs.\n    //\n    // We also want to match the non delimiter part of statements\n    // note we only support ; statement delimiters:\n    //\n    // [^;]\n    //\n    const statementRe =\n      /(\\/(\\\\\\/|[^/])*\\/|\"(\\\\\"|[^\"])*\"|'(\\\\'|[^'])*'|`(\\\\`|[^`])*`|\\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;){]*)\\s*\\)\\s*\\(\\s*\\)|[^;])+/gm\n    const statements = ctx.value.trim().match(statementRe)\n    if (statements) {\n      const lastIdx = statements.length - 1\n      const last = statements[lastIdx].trim()\n      if (!last.startsWith('return')) {\n        statements[lastIdx] = `return (${last});`\n      }\n      expr = statements.join(';\\n')\n    }\n  } else {\n    expr = ctx.value.trim()\n  }\n\n  // Handle $$ syntax - converts $$signal to $context.signal for context signals\n  expr = expr.replace(\n    // Regex: matches $$ followed by valid signal names (including nested like $$foo.bar)\n    /\\$\\$([a-zA-Z_][\\w.-]*(?:\\.[a-zA-Z_][\\w.-]*)*?)(?=\\s|$|[^\\w.-])/g,\n    // s = captured signal name after $$\n    (_, s) => {\n      const scope = findClosestScoped(ctx.el)\n      return scope ? `$${scope}.${s}` : `$${s}` // if no scope: $signal for global scope\n    },\n  )\n\n  expr = expr.replace(\n    /\\$([a-zA-Z_][\\w.-]*(?:\\.[a-zA-Z_][\\w.-]*)*?)(?=\\s|$|[^\\w.-])/g,\n    (match, signalName) => {\n      // If the signal name ends with a hyphen followed by a $, it's likely two separate signals\n      // So we should not include the trailing hyphen in this signal name\n      if (\n        signalName.endsWith('-') &&\n        match.length < expr.length &&\n        expr[expr.indexOf(match) + match.length] === '$'\n      ) {\n        signalName = signalName.slice(0, -1)\n        const parts = signalName.split('.')\n        return `${parts.reduce((acc: string, part: string) => `${acc}['${part}']`, '$')}-`\n      }\n\n      const parts = signalName.split('.')\n      return parts.reduce(\n        (acc: string, part: string) => `${acc}['${part}']`,\n        '$',\n      )\n    },\n  )\n\n  // Ignore any escaped values\n  const escaped = new Map<string, string>()\n  const escapeRe = RegExp(`(?:${DSP})(.*?)(?:${DSS})`, 'gm')\n  for (const match of expr.matchAll(escapeRe)) {\n    const k = match[1]\n    const v = `dsEscaped${djb2(k)}`\n    escaped.set(v, k)\n    expr = expr.replace(DSP + k + DSS, v)\n  }\n\n  const nameGen = (prefix: string, name: string) => {\n    return `${prefix}${snake(name).replaceAll(/\\./g, '_')}`\n  }\n\n  // Replace any action calls\n  const actionsCalled = new Set<string>()\n  const actionsRe = RegExp(`@(${Object.keys(actions).join('|')})\\\\(`, 'gm')\n  const actionMatches = [...expr.matchAll(actionsRe)]\n  const actionNames = new Set<string>()\n  const actionFns = new Set<(...args: any[]) => any>()\n  if (actionMatches.length) {\n    const actionPrefix = `${DATASTAR}Act_`\n    for (const match of actionMatches) {\n      const actionName = match[1]\n      const action = actions[actionName]\n      if (!action) {\n        continue\n      }\n      actionsCalled.add(actionName)\n\n      const name = nameGen(actionPrefix, actionName)\n\n      // Add ctx to action calls\n      expr = expr.replace(`@${actionName}(`, `${name}(`)\n      actionNames.add(name)\n      actionFns.add((...args: any[]) => action.fn(ctx, ...args))\n    }\n  }\n\n  // Replace any escaped values\n  for (const [k, v] of escaped) {\n    expr = expr.replace(k, v)\n  }\n\n  ctx.fnContent = expr\n\n  try {\n    const fn = Function(\n      'el',\n      '$',\n      ...(attrPlugin?.argNames || []),\n      ...actionNames,\n      expr,\n    )\n    return (...args: any[]) => {\n      try {\n        return fn(ctx.el, root, ...args, ...actionFns)\n      } catch (e: any) {\n        throw ctx.runtimeErr('ExecuteExpression', {\n          error: e.message,\n        })\n      }\n    }\n  } catch (error: any) {\n    throw ctx.runtimeErr('GenerateExpression', {\n      error: error.message,\n    })\n  }\n}\n\nfunction djb2(str: string) {\n  let hash = 5831\n  let i = str.length\n  while (i--) {\n    hash += (hash << 5) + str.charCodeAt(i)\n  }\n  return (hash >>> 0).toString(36)\n}\n", "import { DSP } from '../engine/consts'\n\n// @ts-ignore\nconst _ = DSP // This is to force the import of DSP first in the compiled code\n\nimport { Computed } from '../plugins/core/attributes/computed'\nimport { Effect } from '../plugins/core/attributes/effect'\nimport { Signals } from '../plugins/core/attributes/signals'\nimport { apply, load, setAlias } from './engine'\n\nload(Signals, Computed, Effect)\n\nexport { apply, load, setAlias }\n", "import { apply, load, setAlias } from '../engine'\n\napply()\n\nexport { apply, load, setAlias }\n"],
  "mappings": "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",
  "names": ["lol", "DSP", "DSS", "DATASTAR", "isPojo", "obj", "isEmpty", "prop", "pathToObj", "target", "paths", "path", "keys", "lastKey", "obj", "acc", "key", "isHTMLOrSVG", "el", "findClosestScoped", "kebab", "str", "camel", "x", "snake", "pascal", "caseFns", "kebab", "snake", "pascal", "modifyCasing", "str", "mods", "c", "fn", "modifyScope", "signalName", "el", "scope", "findClosestScoped", "Computed", "el", "key", "mods", "rx", "computed", "mergePatch", "signalName", "modifyCasing", "modifyScope", "pathToObj", "Effect", "effect", "rx", "Signals", "el", "key", "mods", "rx", "mergePatch", "ifMissing", "modifyScope", "modifyCasing", "pathToObj", "patch", "pathObj", "url", "dserr", "type", "reason", "metadata", "e", "DATASTAR", "r", "snake", "q", "c", "initErr", "reason", "ctx", "metadata", "errCtx", "dserr", "runtimeErr", "DATASTAR_SIGNAL_PATCH_EVENT", "DATASTAR", "currentPatch", "queuedEffects", "batchDepth", "notifyIndex", "queuedEffectsLength", "activeSub", "startBatch", "endBatch", "flush", "dispatch", "signal", "initialValue", "signalOper", "value_", "flags_", "computedSymbol", "computed", "getter", "c", "computedOper", "effect", "fn", "e", "fn_", "link", "prev", "setCurrentSub", "effectOper", "peek", "run", "update", "updateComputed", "updateSignal", "sub", "prevSub", "startTracking", "oldValue", "endTracking", "s", "value", "notify", "flags", "subs", "subs_", "sub_", "checkDirty", "deps_", "dep", "dep_", "depFlags", "nextDep_", "shallowPropagate", "newValue", "propagate", "currentValue", "unlink", "prevDep", "depsTail_", "nextDep", "recursedCheck", "subsTail_", "isValidLink", "newLink", "prevDep_", "prevSub_", "nextSub_", "toRemove", "next", "stack", "top", "subSubs", "prev_", "checkDepth", "dirty", "firstSub", "hasMultipleSubs", "nextSub", "subFlags", "checkLink", "depsTail", "getPath", "path", "acc", "key", "root", "hasPath", "obj", "deep", "prefix", "isArr", "isPojo", "deepObj", "keys", "_", "prop", "pathToObj", "isEmpty", "oldPatch", "DATASTAR_SIGNAL_PATCH_EVENT", "mergePatch", "patch", "ifMissing", "mergeInner", "target", "targetParent", "filtered", "include", "exclude", "pathObj", "node", "actions", "plugins", "pluginRegexs", "removals", "mutationObserver", "alias", "setAlias", "aliasify", "name", "load", "pluginsToLoad", "plugin", "ctx", "initErr", "a", "b", "lenDiff", "applyEls", "els", "ignore", "el", "applyAttributePlugin", "apply", "observe", "attrKey", "rawKey", "camel", "i", "rawModifiers", "hasKey", "hasValue", "runtimeErr", "generateReactiveExpression", "keyReq", "valReq", "rawMod", "label", "mod", "t", "cleanup", "cleanups", "mutations", "type", "attributeName", "addedNodes", "removedNodes", "isHTMLOrSVG", "expr", "attrPlugin", "statementRe", "statements", "lastIdx", "last", "scope", "findClosestScoped", "match", "signalName", "part", "escaped", "escapeRe", "DSP", "DSS", "k", "v", "djb2", "nameGen", "snake", "actionsCalled", "actionsRe", "actionMatches", "actionNames", "actionFns", "actionPrefix", "DATASTAR", "actionName", "action", "args", "error", "str", "hash", "load", "Signals", "Computed", "Effect", "apply"]
}
