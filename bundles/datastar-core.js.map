{
  "version": 3,
  "sources": ["../library/src/engine/consts.ts", "../library/src/engine/types.ts", "../library/src/plugins/official/core/attributes/computed.ts", "../library/src/utils/text.ts", "../library/src/plugins/official/core/attributes/signals.ts", "../library/src/plugins/official/core/attributes/star.ts", "../library/src/utils/dom.ts", "../library/src/engine/errors.ts", "../library/src/vendored/preact-core.ts", "../library/src/engine/signals.ts", "../library/src/engine/engine.ts", "../library/src/engine/index.ts", "../library/src/bundles/datastar-core.ts"],
  "sourcesContent": ["// This is auto-generated by Datastar. DO NOT EDIT.\nconst lol = /\uD83D\uDD95JS_DS\uD83D\uDE80/.source\nexport const DSP = lol.slice(0, 5)\nexport const DSS = lol.slice(4)\n\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_EVENT = \"datastar-event\";\nexport const DATASTAR_REQUEST = \"Datastar-Request\";\nexport const VERSION = \"1.0.0-beta.2\";\n\n// #region Defaults\n\n// #region Default durations\n\n// The default duration for settling during fragment merges. Allows for CSS transitions to complete.\nexport const DefaultFragmentsSettleDurationMs = 300;\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000;\n\n// #endregion\n\n\n// #region Default strings\n\n// The default attributes for <script/> element use when executing scripts. It is a set of of key-value pairs delimited by a newline \\\\n character.\nexport const DefaultExecuteScriptAttributes = \"type module\";\n\n// #endregion\n\n\n// #region Default booleans\n\n// Should fragments be merged using the ViewTransition API?\nexport const DefaultFragmentsUseViewTransitions = false;\n\n// Should a given set of signals merge if they are missing?\nexport const DefaultMergeSignalsOnlyIfMissing = false;\n\n// Should script element remove itself after execution?\nexport const DefaultExecuteScriptAutoRemove = true;\n\n// #endregion\n\n\n// #region Enums\n\n// The mode in which a fragment is merged into the DOM.\nexport const FragmentMergeModes = {\n    // Morphs the fragment into the existing element using idiomorph.\n    Morph: \"morph\",\n    // Replaces the inner HTML of the existing element.\n    Inner: \"inner\",\n    // Replaces the outer HTML of the existing element.\n    Outer: \"outer\",\n    // Prepends the fragment to the existing element.\n    Prepend: \"prepend\",\n    // Appends the fragment to the existing element.\n    Append: \"append\",\n    // Inserts the fragment before the existing element.\n    Before: \"before\",\n    // Inserts the fragment after the existing element.\n    After: \"after\",\n    // Upserts the attributes of the existing element.\n    UpsertAttributes: \"upsertAttributes\",\n} as const;\n\n// Default value for FragmentMergeMode\nexport const DefaultFragmentMergeMode = FragmentMergeModes.Morph;\n\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\nexport const EventTypes = {\n    // An event for merging HTML fragments into the DOM.\n    MergeFragments: \"datastar-merge-fragments\",\n    // An event for merging signals.\n    MergeSignals: \"datastar-merge-signals\",\n    // An event for removing HTML fragments from the DOM.\n    RemoveFragments: \"datastar-remove-fragments\",\n    // An event for removing signals.\n    RemoveSignals: \"datastar-remove-signals\",\n    // An event for executing <script/> elements in the browser.\n    ExecuteScript: \"datastar-execute-script\",\n} as const;\n// #endregion\n\n// #endregion", "import type { EffectFn, Signal } from '../vendored/preact-core'\nimport type { SignalsRoot } from './signals'\n\nexport type OnRemovalFn = () => void\n\nexport enum PluginType {\n  Attribute = 1,\n  Watcher = 2,\n  Action = 3,\n}\n\nexport interface DatastarPlugin {\n  type: PluginType // The type of plugin\n  name: string // The name of the plugin\n}\n\nexport enum Requirement {\n  Allowed = 0,\n  Must = 1,\n  Denied = 2,\n  Exclusive = 3,\n}\n\n// A plugin accesible via a `data-${name}` attribute on an element\nexport interface AttributePlugin extends DatastarPlugin {\n  type: PluginType.Attribute\n  onGlobalInit?: (ctx: InitContext) => void // Called once on registration of the plugin\n  onLoad: (ctx: RuntimeContext) => OnRemovalFn | void // Return a function to be called on removal\n  mods?: Set<string> // If not provided, all modifiers are allowed\n  keyReq?: Requirement // The rules for the key requirements\n  valReq?: Requirement // The rules for the value requirements\n  removeOnLoad?: boolean // If true, the attribute is removed after onLoad (useful for plugins you don\u2019t want reapplied)\n  argNames?: string[] // argument names for the reactive expression\n}\n\n// A plugin that runs on the global scope of the DastaStar instance\nexport interface WatcherPlugin extends DatastarPlugin {\n  type: PluginType.Watcher\n  onGlobalInit?: (ctx: InitContext) => void\n}\n\nexport type ActionPlugins = Record<string, ActionPlugin>\nexport type ActionMethod = (ctx: RuntimeContext, ...args: any[]) => any\n\nexport interface ActionPlugin extends DatastarPlugin {\n  type: PluginType.Action\n  fn: ActionMethod\n}\n\nexport type GlobalInitializer = (ctx: InitContext) => void\nexport type RemovalEntry = { id: string; fns: Array<OnRemovalFn> }\n\nexport type InitContext = {\n  plugin: DatastarPlugin\n  signals: SignalsRoot\n  effect: (fn: EffectFn) => OnRemovalFn\n  actions: Readonly<ActionPlugins>\n  apply: (target: Element) => void\n  cleanup: (el: Element) => void\n}\n\nexport type HTMLorSVGElement = Element & (HTMLElement | SVGElement)\nexport type Modifiers = Map<string, Set<string>> // mod name -> tags\n\nexport type RuntimeContext = InitContext & {\n  plugin: DatastarPlugin // The name of the plugin\n  el: HTMLorSVGElement // The element the attribute is on\n  rawKey: Readonly<string> // no parsing data-* key\n  key: Readonly<string> // data-* key without the prefix or tags\n  value: Readonly<string> // value of data-* attribute\n  mods: Modifiers // the tags and their arguments\n  genRX: () => <T>(...args: any[]) => T // a reactive expression\n  fnContent?: string // the content of the function\n}\n\nexport type NestedValues = { [key: string]: NestedValues | any }\nexport type NestedSignal = {\n  [key: string]: NestedSignal | Signal<any>\n}\n\nexport type RuntimeExpressionFunction = (\n  ctx: RuntimeContext,\n  ...args: any[]\n) => any\n", "import {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nconst name = 'computed'\nexport const Computed: AttributePlugin = {\n  type: PluginType.Attribute,\n  name,\n  keyReq: Requirement.Must,\n  valReq: Requirement.Must,\n  onLoad: ({ key, signals, genRX }) => {\n    const rx = genRX()\n    signals.setComputed(key, rx)\n  },\n}\n", "export const isBoolString = (str: string) => str.trim() === 'true'\n\nexport const kebabize = (str: string) =>\n  str.replace(\n    /[A-Z]+(?![a-z])|[A-Z]/g,\n    ($, ofs) => (ofs ? '-' : '') + $.toLowerCase(),\n  )\n\nexport const camelize = (str: string) =>\n  str\n    .replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (word, index) =>\n      index === 0 ? word.toLowerCase() : word.toUpperCase(),\n    )\n    .replace(/\\s+/g, '')\n\nexport const jsStrToObject = (raw: string) =>\n  new Function(`return Object.assign({}, ${raw})`)()\n\nexport const trimDollarSignPrefix = (str: string) =>\n  str.startsWith('$') ? str.slice(1) : str\n", "import {\n  type AttributePlugin,\n  type NestedValues,\n  PluginType,\n} from '../../../../engine/types'\nimport { jsStrToObject } from '../../../../utils/text'\n\nexport const Signals: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'signals',\n  removeOnLoad: true,\n  onLoad: (ctx) => {\n    const { key, value, genRX, signals, mods } = ctx\n    const ifMissing = mods.has('ifmissing')\n    if (key !== '' && !ifMissing) {\n      const v = value === '' ? value : genRX()()\n      signals.setValue(key, v)\n    } else {\n      const obj = jsStrToObject(ctx.value)\n      ctx.value = JSON.stringify(obj)\n      const rx = genRX()\n      const nv = rx<NestedValues>()\n      signals.merge(nv, ifMissing)\n    }\n  },\n}\n", "import {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nexport const Star: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'star',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Denied,\n  onLoad: () => {\n    alert('YOU ARE PROBABLY OVERCOMPLICATING IT')\n  },\n}\n", "import { DATASTAR } from '../engine/consts'\n\nexport class Hash {\n  #value = 0\n  #prefix: string\n\n  constructor(prefix = DATASTAR) {\n    this.#prefix = prefix\n  }\n\n  with(x: number | string): Hash {\n    if (typeof x === 'string') {\n      for (const c of x.split('')) {\n        this.with(c.charCodeAt(0))\n      }\n    } else {\n      this.#value = (this.#value << 5) - this.#value + x\n    }\n    return this\n  }\n\n  reset(): Hash {\n    this.#value = 0\n    return this\n  }\n\n  get value() {\n    return this.#prefix + Math.abs(this.#value).toString(36)\n  }\n}\n\nexport function elUniqId(el: Element) {\n  if (el.id) return el.id\n  const hash = new Hash()\n\n  let currentEl = el\n  while (currentEl.parentNode) {\n    if (currentEl.id) {\n      hash.with(currentEl.id)\n      break\n    }\n    if (currentEl === currentEl.ownerDocument.documentElement) {\n      hash.with(currentEl.tagName)\n    } else {\n      for (\n        let i = 1, e = el;\n        e.previousElementSibling;\n        e = e.previousElementSibling, i++\n      ) {\n        hash.with(i)\n      }\n      currentEl = currentEl.parentNode as Element\n    }\n\n    currentEl = currentEl.parentNode as Element\n  }\n  return hash.value\n}\n\nexport function onElementRemoved(element: Element, callback: () => void) {\n  const observer = new MutationObserver((mutations) => {\n    for (const mutation of mutations) {\n      for (const removedNode of mutation.removedNodes) {\n        if (removedNode === element) {\n          observer.disconnect()\n          callback()\n          return\n        }\n      }\n    }\n  })\n  observer.observe(element.parentNode as Node, { childList: true })\n}\n", "import { kebabize } from '../utils/text'\nimport { DATASTAR } from './consts'\nimport { type InitContext, PluginType, type RuntimeContext } from './types'\n\n// const url = 'https://data-star.dev/errors'\nconst url = `${window.location.origin}/errors`\n\ninterface Metadata {\n  error?: string;\n  [key: string]: any;\n}\n\nfunction dserr(type: string, reason: string, metadata: Metadata = {}) {\n  const e = new Error()\n  reason = reason[0].toUpperCase() + reason.slice(1)\n  e.name = `${DATASTAR} ${type} error`\n  const r = kebabize(reason).replaceAll('-', '_')\n  const q = new URLSearchParams({\n    metadata: JSON.stringify(metadata),\n  }).toString()\n  const c = JSON.stringify(metadata, null, 2)\n  e.message = `${reason}\\nMore info: ${url}/${type}/${r}?${q}\\nContext: ${c}`\n  return e\n}\n\nexport function internalErr(from: string, reason: string, args = {}) {\n  return dserr('internal', reason, Object.assign({ from }, args))\n}\n\nexport function initErr(reason: string, ctx: InitContext, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: PluginType[ctx.plugin.type],\n    },\n  }\n  return dserr('init', reason, Object.assign(errCtx, metadata))\n}\n\nexport function runtimeErr(reason: string, ctx: RuntimeContext, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: PluginType[ctx.plugin.type],\n    },\n    element: {\n      id: ctx.el.id,\n      tag: ctx.el.tagName,\n    },\n    expression: {\n      rawKey: ctx.rawKey,\n      key: ctx.key,\n      value: ctx.value,\n      validSignals: ctx.signals.paths(),\n      fnContent: ctx.fnContent,\n    },\n  }\n  return dserr('runtime', reason, Object.assign(errCtx, metadata))\n}", "import { internalErr } from '../engine/errors'\nimport type { OnRemovalFn } from '../engine/types'\n\nconst from = 'preact-signals'\n\n// An named symbol/brand for detecting Signal instances even when they weren't\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for('preact-signals')\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0\nconst NOTIFIED = 1 << 1\nconst OUTDATED = 1 << 2\nconst DISPOSED = 1 << 3\nconst HAS_ERROR = 1 << 4\nconst TRACKING = 1 << 5\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n  // A source whose value the target depends on.\n  _source: Signal\n  _prevSource?: Node\n  _nextSource?: Node\n\n  // A target that depends on the source and should be notified when the source changes.\n  _target: Computed | Effect\n  _prevTarget?: Node\n  _nextTarget?: Node\n\n  // The version number of the source that target has last seen. We use version numbers\n  // instead of storing the source value, because source values can take arbitrary amount\n  // of memory, and computeds could hang on to them forever because they're lazily evaluated.\n  // Use the special value -1 to mark potentially unused but recyclable nodes.\n  _version: number\n\n  // Used to remember & roll back the source's previous `._node` value when entering &\n  // exiting a new evaluation context.\n  _rollbackNode?: Node\n}\n\nfunction startBatch() {\n  batchDepth++\n}\n\nfunction endBatch() {\n  if (batchDepth > 1) {\n    batchDepth--\n    return\n  }\n\n  let error: unknown\n  let hasError = false\n\n  while (batchedEffect !== undefined) {\n    let effect: Effect | undefined = batchedEffect\n    batchedEffect = undefined\n\n    batchIteration++\n\n    while (effect !== undefined) {\n      const next: Effect | undefined = effect._nextBatchedEffect\n      effect._nextBatchedEffect = undefined\n      effect._flags &= ~NOTIFIED\n\n      if (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n        try {\n          effect._callback()\n        } catch (err) {\n          if (!hasError) {\n            error = err\n            hasError = true\n          }\n        }\n      }\n      effect = next\n    }\n  }\n  batchIteration = 0\n  batchDepth--\n\n  if (hasError) {\n    throw internalErr(from, 'BatchError, error', { error })\n  }\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n  if (batchDepth > 0) {\n    return fn()\n  }\n  /*@__INLINE__**/ startBatch()\n  try {\n    return fn()\n  } finally {\n    endBatch()\n  }\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n  const prevContext = evalContext\n  evalContext = undefined\n  try {\n    return fn()\n  } finally {\n    evalContext = prevContext\n  }\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined\nlet batchDepth = 0\nlet batchIteration = 0\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0\n\nfunction addDependency(signal: Signal): Node | undefined {\n  if (evalContext === undefined) {\n    return undefined\n  }\n\n  let node = signal._node\n  if (node === undefined || node._target !== evalContext) {\n    /**\n     * `signal` is a new dependency. Create a new dependency node, and set it\n     * as the tail of the current context's dependency list. e.g:\n     *\n     * { A <-> B       }\n     *         \u2191     \u2191\n     *        tail  node (new)\n     *               \u2193\n     * { A <-> B <-> C }\n     *               \u2191\n     *              tail (evalContext._sources)\n     */\n    node = {\n      _version: 0,\n      _source: signal,\n      _prevSource: evalContext._sources,\n      _nextSource: undefined,\n      _target: evalContext,\n      _prevTarget: undefined,\n      _nextTarget: undefined,\n      _rollbackNode: node,\n    }\n\n    if (evalContext._sources !== undefined) {\n      evalContext._sources._nextSource = node\n    }\n    evalContext._sources = node\n    signal._node = node\n\n    // Subscribe to change notifications from this dependency if we're in an effect\n    // OR evaluating a computed signal that in turn has subscribers.\n    if (evalContext._flags & TRACKING) {\n      signal._subscribe(node)\n    }\n    return node\n  }\n  if (node._version === -1) {\n    // `signal` is an existing dependency from a previous evaluation. Reuse it.\n    node._version = 0\n\n    /**\n     * If `node` is not already the current tail of the dependency list (i.e.\n     * there is a next node in the list), then make the `node` the new tail. e.g:\n     *\n     * { A <-> B <-> C <-> D }\n     *         \u2191           \u2191\n     *        node   \u250C\u2500\u2500\u2500 tail (evalContext._sources)\n     *         \u2514\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2510\n     *               \u2193     \u2193\n     * { A <-> C <-> D <-> B }\n     *                     \u2191\n     *                    tail (evalContext._sources)\n     */\n    if (node._nextSource !== undefined) {\n      node._nextSource._prevSource = node._prevSource\n\n      if (node._prevSource !== undefined) {\n        node._prevSource._nextSource = node._nextSource\n      }\n\n      node._prevSource = evalContext._sources\n      node._nextSource = undefined\n\n      evalContext._sources!._nextSource = node\n      evalContext._sources = node\n    }\n\n    // We can assume that the currently evaluated effect / computed signal is already\n    // subscribed to change notifications from `signal` if needed.\n    return node\n  }\n  return undefined\n}\n\n/**\n * The base class for plain and computed signals.\n */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style protoTYPEOF_\n// This enables better control of the transpiled output size.\ndeclare class Signal<T = any> {\n  /** @internal */\n  _value: unknown\n\n  /**\n   * @internal\n   * Version numbers should always be >= 0, because the special value -1 is used\n   * by Nodes to signify potentially unused but recyclable nodes.\n   */\n  _version: number\n\n  /** @internal */\n  _node?: Node\n\n  /** @internal */\n  _targets?: Node\n\n  constructor(value?: T)\n\n  /** @internal */\n  _refresh(): boolean\n\n  /** @internal */\n  _subscribe(node: Node): void\n\n  /** @internal */\n  _unsubscribe(node: Node): void\n\n  subscribe(fn: (value: T) => void): () => void\n\n  valueOf(): T\n\n  toString(): string\n\n  toJSON(): T\n\n  peek(): T\n\n  brand: typeof BRAND_SYMBOL\n\n  get value(): T\n  set value(value: T)\n}\n\n/** @internal */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style protoTYPEOF_\n// This enables better control of the transpiled output size.\n// biome-ignore lint/suspicious/noRedeclare: <explanation>\nfunction Signal(this: Signal, value?: unknown) {\n  this._value = value\n  this._version = 0\n  this._node = undefined\n  this._targets = undefined\n}\n\nSignal.prototype.brand = BRAND_SYMBOL\n\nSignal.prototype._refresh = () => true\n\nSignal.prototype._subscribe = function (node) {\n  if (this._targets !== node && node._prevTarget === undefined) {\n    node._nextTarget = this._targets\n    if (this._targets !== undefined) {\n      this._targets._prevTarget = node\n    }\n    this._targets = node\n  }\n}\n\nSignal.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the signal has any subscribers to begin with.\n  if (this._targets !== undefined) {\n    const prev = node._prevTarget\n    const next = node._nextTarget\n    if (prev !== undefined) {\n      prev._nextTarget = next\n      node._prevTarget = undefined\n    }\n    if (next !== undefined) {\n      next._prevTarget = prev\n      node._nextTarget = undefined\n    }\n    if (node === this._targets) {\n      this._targets = next\n    }\n  }\n}\n\nSignal.prototype.subscribe = function (fn) {\n  return effect(() => {\n    const value = this.value\n\n    const prevContext = evalContext\n    evalContext = undefined\n    try {\n      fn(value)\n    } finally {\n      evalContext = prevContext\n    }\n  })\n}\n\nSignal.prototype.valueOf = function () {\n  return this.value\n}\n\nSignal.prototype.toString = function () {\n  return `${this.value}`\n}\n\nSignal.prototype.toJSON = function () {\n  return this.value\n}\n\nSignal.prototype.peek = function () {\n  const prevContext = evalContext\n  evalContext = undefined\n  try {\n    return this.value\n  } finally {\n    evalContext = prevContext\n  }\n}\n\nObject.defineProperty(Signal.prototype, 'value', {\n  get(this: Signal) {\n    const node = addDependency(this)\n    if (node !== undefined) {\n      node._version = this._version\n    }\n    return this._value\n  },\n  set(this: Signal, value) {\n    if (value !== this._value) {\n      if (batchIteration > 100) {\n        throw internalErr(from, 'SignalCycleDetected')\n      }\n\n      this._value = value\n      this._version++\n      globalVersion++\n\n      /**@__INLINE__*/ startBatch()\n      try {\n        for (\n          let node = this._targets;\n          node !== undefined;\n          node = node._nextTarget\n        ) {\n          node._target._notify()\n        }\n      } finally {\n        endBatch()\n      }\n    }\n  },\n})\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T): Signal<T>\nexport function signal<T = undefined>(): Signal<T | undefined>\nexport function signal<T>(value?: T): Signal<T> {\n  return new Signal(value)\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n  // Check the dependencies for changed values. The dependency list is already\n  // in order of use. Therefore if multiple dependencies have changed values, only\n  // the first used dependency is re-evaluated at this point.\n  for (\n    let node = target._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    // If there's a new version of the dependency before or after refreshing,\n    // or the dependency has something blocking it from refreshing at all (e.g. a\n    // dependency cycle), then we need to recompute.\n    if (\n      node._source._version !== node._version ||\n      !node._source._refresh() ||\n      node._source._version !== node._version\n    ) {\n      return true\n    }\n  }\n  // If none of the dependencies have changed values since last recompute then\n  // there's no need to recompute.\n  return false\n}\n\nfunction prepareSources(target: Computed | Effect) {\n  /**\n   * 1. Mark all current sources as re-usable nodes (version: -1)\n   * 2. Set a rollback node if the current node is being used in a different context\n   * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n   *\n   *    { undefined <- A <-> B <-> C -> undefined }\n   *                   \u2191           \u2191\n   *                   \u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   * target._sources = A; (node is head)  \u2502\n   *                   \u2193                  \u2502\n   * target._sources = C; (node is tail) \u2500\u2518\n   */\n  for (\n    let node = target._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    const rollbackNode = node._source._node\n    if (rollbackNode !== undefined) {\n      node._rollbackNode = rollbackNode\n    }\n    node._source._node = node\n    node._version = -1\n\n    if (node._nextSource === undefined) {\n      target._sources = node\n      break\n    }\n  }\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n  let node = target._sources\n  let head: Node | undefined = undefined\n\n  /**\n   * At this point 'target._sources' points to the tail of the doubly-linked list.\n   * It contains all existing sources + new sources in order of use.\n   * Iterate backwards until we find the head node while dropping old dependencies.\n   */\n  while (node !== undefined) {\n    const prev = node._prevSource\n\n    /**\n     * The node was not re-used, unsubscribe from its change notifications and remove itself\n     * from the doubly-linked list. e.g:\n     *\n     * { A <-> B <-> C }\n     *         \u2193\n     *    { A <-> C }\n     */\n    if (node._version === -1) {\n      node._source._unsubscribe(node)\n\n      if (prev !== undefined) {\n        prev._nextSource = node._nextSource\n      }\n      if (node._nextSource !== undefined) {\n        node._nextSource._prevSource = prev\n      }\n    } else {\n      /**\n       * The new head is the last node seen which wasn't removed/unsubscribed\n       * from the doubly-linked list. e.g:\n       *\n       * { A <-> B <-> C }\n       *   \u2191     \u2191     \u2191\n       *   \u2502     \u2502     \u2514 head = node\n       *   \u2502     \u2514 head = node\n       *   \u2514 head = node\n       */\n      head = node\n    }\n\n    node._source._node = node._rollbackNode\n    if (node._rollbackNode !== undefined) {\n      node._rollbackNode = undefined\n    }\n\n    node = prev\n  }\n\n  target._sources = head\n}\n\nexport declare class Computed<T = any> extends Signal<T> {\n  _fn: () => T\n  _sources?: Node\n  _globalVersion: number\n  _flags: number\n\n  constructor(fn: () => T)\n\n  _notify(): void\n  get value(): T\n}\n\n// biome-ignore lint/suspicious/noRedeclare: <explanation>\nexport function Computed(this: Computed, fn: () => unknown) {\n  Signal.call(this, undefined)\n\n  this._fn = fn\n  this._sources = undefined\n  this._globalVersion = globalVersion - 1\n  this._flags = OUTDATED\n}\n\nComputed.prototype = new Signal() as Computed\n\nComputed.prototype._refresh = function () {\n  this._flags &= ~NOTIFIED\n\n  if (this._flags & RUNNING) {\n    return false\n  }\n\n  // If this computed signal has subscribed to updates from its dependencies\n  // (TRACKING flag set) and none of them have notified about changes (OUTDATED\n  // flag not set), then the computed value can't have changed.\n  if ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n    return true\n  }\n  this._flags &= ~OUTDATED\n\n  if (this._globalVersion === globalVersion) {\n    return true\n  }\n  this._globalVersion = globalVersion\n\n  // Mark this computed signal running before checking the dependencies for value\n  // changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n  this._flags |= RUNNING\n  if (this._version > 0 && !needsToRecompute(this)) {\n    this._flags &= ~RUNNING\n    return true\n  }\n\n  const prevContext = evalContext\n  try {\n    prepareSources(this)\n    evalContext = this\n    const value = this._fn()\n    if (\n      this._flags & HAS_ERROR ||\n      this._value !== value ||\n      this._version === 0\n    ) {\n      this._value = value\n      this._flags &= ~HAS_ERROR\n      this._version++\n    }\n  } catch (err) {\n    this._value = err\n    this._flags |= HAS_ERROR\n    this._version++\n  }\n  evalContext = prevContext\n  cleanupSources(this)\n  this._flags &= ~RUNNING\n  return true\n}\n\nComputed.prototype._subscribe = function (node) {\n  if (this._targets === undefined) {\n    this._flags |= OUTDATED | TRACKING\n\n    // A computed signal subscribes lazily to its dependencies when it\n    // gets its first subscriber.\n    for (\n      let node = this._sources;\n      node !== undefined;\n      node = node._nextSource\n    ) {\n      node._source._subscribe(node)\n    }\n  }\n  Signal.prototype._subscribe.call(this, node)\n}\n\nComputed.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the computed signal has any subscribers.\n  if (this._targets !== undefined) {\n    Signal.prototype._unsubscribe.call(this, node)\n\n    // Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n    // This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n    if (this._targets === undefined) {\n      this._flags &= ~TRACKING\n\n      for (\n        let node = this._sources;\n        node !== undefined;\n        node = node._nextSource\n      ) {\n        node._source._unsubscribe(node)\n      }\n    }\n  }\n}\n\nComputed.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= OUTDATED | NOTIFIED\n\n    for (\n      let node = this._targets;\n      node !== undefined;\n      node = node._nextTarget\n    ) {\n      node._target._notify()\n    }\n  }\n}\n\nObject.defineProperty(Computed.prototype, 'value', {\n  get(this: Computed) {\n    if (this._flags & RUNNING) {\n      // Cycle detected\n      throw internalErr(from, 'SignalCycleDetected')\n    }\n    const node = addDependency(this)\n    this._refresh()\n    if (node !== undefined) {\n      node._version = this._version\n    }\n    if (this._flags & HAS_ERROR) {\n      throw internalErr(from, 'GetComputedError', { value: this._value })\n    }\n    return this._value\n  },\n})\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n  readonly value: T\n  peek(): T\n\n  subscribe(fn: (value: T) => void): () => void\n  valueOf(): T\n  toString(): string\n  toJSON(): T\n  brand: typeof BRAND_SYMBOL\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(fn: () => T): ReadonlySignal<T> {\n  return new Computed(fn)\n}\n\nfunction cleanupEffect(effect: Effect) {\n  const cleanup = effect._cleanup\n  effect._cleanup = undefined\n\n  if (typeof cleanup === 'function') {\n    /*@__INLINE__**/ startBatch()\n\n    // Run cleanup functions always outside of any context.\n    const prevContext = evalContext\n    evalContext = undefined\n    try {\n      cleanup!()\n    } catch (error) {\n      effect._flags &= ~RUNNING\n      effect._flags |= DISPOSED\n      disposeEffect(effect)\n      throw internalErr(from, 'CleanupEffectError', { error })\n    } finally {\n      evalContext = prevContext\n      endBatch()\n    }\n  }\n}\n\nfunction disposeEffect(effect: Effect) {\n  for (\n    let node = effect._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    node._source._unsubscribe(node)\n  }\n  effect._fn = undefined\n  effect._sources = undefined\n\n  cleanupEffect(effect)\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n  if (evalContext !== this) {\n    throw internalErr(from, 'EndEffectError')\n  }\n  cleanupSources(this)\n  evalContext = prevContext\n\n  this._flags &= ~RUNNING\n  if (this._flags & DISPOSED) {\n    disposeEffect(this)\n  }\n  endBatch()\n}\n\nexport type EffectFn = () => OnRemovalFn | void | Promise<OnRemovalFn | void>\n\ndeclare class Effect {\n  _fn?: EffectFn\n  _cleanup?: () => void\n  _sources?: Node\n  _nextBatchedEffect?: Effect\n  _flags: number\n\n  constructor(fn: EffectFn)\n\n  _callback(): void\n  _start(): () => void\n  _notify(): void\n  _dispose(): void\n}\n\n// biome-ignore lint/suspicious/noRedeclare: <explanation>\nfunction Effect(this: Effect, fn: EffectFn) {\n  this._fn = fn\n  this._cleanup = undefined\n  this._sources = undefined\n  this._nextBatchedEffect = undefined\n  this._flags = TRACKING\n}\n\nEffect.prototype._callback = function () {\n  const finish = this._start()\n  try {\n    if (this._flags & DISPOSED) return\n    if (this._fn === undefined) return\n\n    const cleanup = this._fn()\n    if (typeof cleanup === 'function') {\n      this._cleanup = cleanup!\n    }\n  } finally {\n    finish()\n  }\n}\n\nEffect.prototype._start = function () {\n  if (this._flags & RUNNING) {\n    throw internalErr(from, 'SignalCycleDetected')\n  }\n  this._flags |= RUNNING\n  this._flags &= ~DISPOSED\n  cleanupEffect(this)\n  prepareSources(this)\n\n  /*@__INLINE__**/ startBatch()\n  const prevContext = evalContext\n  evalContext = this\n  return endEffect.bind(this, prevContext)\n}\n\nEffect.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= NOTIFIED\n    this._nextBatchedEffect = batchedEffect\n    batchedEffect = this\n  }\n}\n\nEffect.prototype._dispose = function () {\n  this._flags |= DISPOSED\n\n  if (!(this._flags & RUNNING)) {\n    disposeEffect(this)\n  }\n}\n\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn): () => void {\n  const effect = new Effect(fn)\n  try {\n    effect._callback()\n  } catch (error) {\n    effect._dispose()\n    // Throw the error, since it is already a Datastar error.\n    throw error\n  }\n  // Return a bound function instead of a wrapper like `() => effect._dispose()`,\n  // because bound functions seem to be just as fast and take up a lot less memory.\n  return effect._dispose.bind(effect)\n}\n\nexport { batch, computed, effect, Signal, untracked }\nexport type { ReadonlySignal }\n", "import { type Computed, Signal, computed } from '../vendored/preact-core'\nimport { internalErr } from './errors'\nimport type { NestedSignal, NestedValues } from './types'\n\nconst from = 'namespacedSignals'\n\n// If onlyPublic is true, only signals not starting with an underscore are included\nfunction nestedValues(\n  signal: NestedSignal,\n  onlyPublic = false,\n): Record<string, any> {\n  const kv: Record<string, any> = {}\n  for (const key in signal) {\n    if (Object.hasOwn(signal, key)) {\n      if (onlyPublic && key.startsWith('_')) {\n        continue\n      }\n      const value = signal[key]\n      if (value instanceof Signal) {\n        kv[key] = value.value\n      } else {\n        kv[key] = nestedValues(value)\n      }\n    }\n  }\n  return kv\n}\n\nfunction mergeNested(\n  target: NestedValues,\n  values: NestedValues,\n  onlyIfMissing = false,\n): void {\n  for (const key in values) {\n    if (Object.hasOwn(values, key)) {\n      if (key.match(/\\_\\_+/)) {\n        throw internalErr(from, 'InvalidSignalKey', { key })\n      }\n\n      const value = values[key]\n      if (value instanceof Object && !Array.isArray(value)) {\n        if (!target[key]) {\n          target[key] = {}\n        }\n        mergeNested(\n          target[key] as NestedValues,\n          value as NestedValues,\n          onlyIfMissing,\n        )\n      } else {\n        const hasKey = Object.hasOwn(target, key)\n        if (hasKey) {\n          if (onlyIfMissing) continue\n          const t = target[key]\n          if (t instanceof Signal) {\n            t.value = value\n            continue\n          }\n        }\n        target[key] = new Signal(value)\n      }\n    }\n  }\n}\n\nfunction walkNestedSignal(\n  signal: NestedSignal,\n  cb: (dotDeliminatedPath: string, signal: Signal<any>) => void,\n): void {\n  for (const key in signal) {\n    if (Object.hasOwn(signal, key)) {\n      const value = signal[key]\n      if (value instanceof Signal) {\n        cb(key, value)\n      } else {\n        walkNestedSignal(value, (path, value) => {\n          cb(`${key}.${path}`, value)\n        })\n      }\n    }\n  }\n}\n\n// Recursive function to subset a nested object, each key is a dot-delimited path\nfunction nestedSubset(original: NestedValues, ...keys: string[]): NestedValues {\n  const subset: NestedValues = {}\n  for (const key of keys) {\n    const parts = key.split('.')\n    let subOriginal = original\n    let subSubset = subset\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subOriginal[part]) {\n        return {}\n      }\n      if (!subSubset[part]) {\n        subSubset[part] = {}\n      }\n      subOriginal = subOriginal[part] as NestedValues\n      subSubset = subSubset[part] as NestedValues\n    }\n    const last = parts[parts.length - 1]\n    subSubset[last] = subOriginal[last]\n  }\n  return subset\n}\n\n// Recursively walk a NestedValue with a callback and dot-delimited path\nexport function walkNestedValues(\n  nv: NestedValues,\n  cb: (path: string, value: any) => void,\n) {\n  for (const key in nv) {\n    if (Object.hasOwn(nv, key)) {\n      const value = nv[key]\n      if (value instanceof Object && !Array.isArray(value)) {\n        walkNestedValues(value, (path, value) => {\n          cb(`${key}.${path}`, value)\n        })\n      } else {\n        cb(key, value)\n      }\n    }\n  }\n}\n\nexport class SignalsRoot {\n  #signals: NestedSignal = {}\n\n  exists(dotDelimitedPath: string): boolean {\n    return !!this.signal(dotDelimitedPath)\n  }\n\n  signal<T>(dotDelimitedPath: string): Signal<T> | null {\n    const parts = dotDelimitedPath.split('.')\n    let subSignals = this.#signals\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subSignals[part]) {\n        return null\n      }\n      subSignals = subSignals[part] as NestedSignal\n    }\n    const last = parts[parts.length - 1]\n    const signal = subSignals[last]\n    if (!signal)\n      throw internalErr(from, 'SignalNotFound', { path: dotDelimitedPath })\n    return signal as Signal<T>\n  }\n\n  setSignal<T extends Signal<T>>(dotDelimitedPath: string, signal: T) {\n    const parts = dotDelimitedPath.split('.')\n    let subSignals = this.#signals\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subSignals[part]) {\n        subSignals[part] = {}\n      }\n      subSignals = subSignals[part] as NestedSignal\n    }\n    const last = parts[parts.length - 1]\n    subSignals[last] = signal\n  }\n\n  setComputed<T>(dotDelimitedPath: string, fn: () => T) {\n    const signal = computed(() => fn()) as Computed\n    this.setSignal(dotDelimitedPath, signal)\n  }\n\n  value<T>(dotDelimitedPath: string): T {\n    const signal = this.signal(dotDelimitedPath) as Signal<T>\n    return signal?.value\n  }\n\n  setValue<T>(dotDelimitedPath: string, value: T) {\n    const s = this.upsertIfMissing(dotDelimitedPath, value)\n    s.value = value\n  }\n\n  upsertIfMissing<T>(dotDelimitedPath: string, defaultValue: T) {\n    const parts = dotDelimitedPath.split('.')\n    let subSignals = this.#signals\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subSignals[part]) {\n        subSignals[part] = {}\n      }\n      subSignals = subSignals[part] as NestedSignal\n    }\n    const last = parts[parts.length - 1]\n\n    const current = subSignals[last]\n    if (current instanceof Signal) {\n      return current as Signal<T>\n    }\n\n    const signal = new Signal(defaultValue)\n    subSignals[last] = signal\n\n    return signal\n  }\n\n  remove(...dotDelimitedPaths: string[]) {\n    for (const path of dotDelimitedPaths) {\n      const parts = path.split('.')\n      let subSignals = this.#signals\n      for (let i = 0; i < parts.length - 1; i++) {\n        const part = parts[i]\n        if (!subSignals[part]) {\n          return\n        }\n        subSignals = subSignals[part] as NestedSignal\n      }\n      const last = parts[parts.length - 1]\n      delete subSignals[last]\n    }\n  }\n\n  merge(other: NestedValues, onlyIfMissing = false) {\n    mergeNested(this.#signals, other, onlyIfMissing)\n  }\n\n  subset(...keys: string[]): NestedValues {\n    return nestedSubset(this.values(), ...keys)\n  }\n\n  walk(cb: (name: string, signal: Signal<any>) => void) {\n    walkNestedSignal(this.#signals, cb)\n  }\n\n  paths() {\n    const signalNames = new Array<string>()\n    this.walk((path) => signalNames.push(path))\n    return signalNames\n  }\n\n  values(onlyPublic = false): NestedValues {\n    return nestedValues(this.#signals, onlyPublic)\n  }\n\n  JSON(shouldIndent = true, onlyPublic = false) {\n    const values = this.values(onlyPublic)\n    if (!shouldIndent) {\n      return JSON.stringify(values)\n    }\n    return JSON.stringify(values, null, 2)\n  }\n\n  public toString() {\n    return this.JSON()\n  }\n}\n", "import { Hash, elUniqId } from '../utils/dom'\nimport { camelize } from '../utils/text'\nimport { effect } from '../vendored/preact-core'\nimport { DSP, DSS, VERSION } from './consts'\nimport { initErr, runtimeErr } from './errors'\nimport { SignalsRoot } from './signals'\nimport {\n  type ActionPlugin,\n  type ActionPlugins,\n  type AttributePlugin,\n  type DatastarPlugin,\n  type GlobalInitializer,\n  type HTMLorSVGElement,\n  type InitContext,\n  type OnRemovalFn,\n  PluginType,\n  type RemovalEntry,\n  Requirement,\n  type RuntimeContext,\n  type RuntimeExpressionFunction,\n  type WatcherPlugin,\n} from './types'\n\nexport class Engine {\n  #signals = new SignalsRoot()\n  #plugins: AttributePlugin[] = []\n  #actions: ActionPlugins = {}\n  #watchers: WatcherPlugin[] = []\n  #removals = new Map<Element, RemovalEntry>()\n\n  get signals() {\n    return this.#signals\n  }\n\n  get version() {\n    return VERSION\n  }\n\n  public load(...pluginsToLoad: DatastarPlugin[]) {\n    for (const plugin of pluginsToLoad) {\n      const that = this // I hate javascript\n      const ctx: InitContext = {\n        get signals() {\n          return that.#signals\n        },\n        effect: (cb: () => void): OnRemovalFn => effect(cb),\n        actions: this.#actions,\n        apply: this.apply.bind(this),\n        cleanup: this.#cleanup.bind(this),\n        plugin,\n      }\n\n      let globalInitializer: GlobalInitializer | undefined\n      switch (plugin.type) {\n        case PluginType.Watcher: {\n          const wp = plugin as WatcherPlugin\n          this.#watchers.push(wp)\n          globalInitializer = wp.onGlobalInit\n          break\n        }\n        case PluginType.Action: {\n          this.#actions[plugin.name] = plugin as ActionPlugin\n          break\n        }\n        case PluginType.Attribute: {\n          const ap = plugin as AttributePlugin\n          this.#plugins.push(ap)\n          globalInitializer = ap.onGlobalInit\n          break\n        }\n        default: {\n          throw initErr('InvalidPluginType', ctx)\n        }\n      }\n      if (globalInitializer) {\n        globalInitializer(ctx)\n      }\n    }\n\n    // Sort attribute plugins by descending length then alphabetically\n    this.#plugins.sort((a, b) => {\n      const lenDiff = b.name.length - a.name.length\n      if (lenDiff !== 0) return lenDiff\n      return a.name.localeCompare(b.name)\n    })\n  }\n\n  // Apply all plugins to the element and its children\n  public apply(rootElement: Element) {\n    this.#walkDownDOM(rootElement, (el) => {\n      // Cleanup any previous plugins\n      this.#cleanup(el)\n\n      // Apply the plugins to the element in order of application\n      // since DOMStringMap is ordered, we can be deterministic\n      for (const rawKey of Object.keys(el.dataset)) {\n        // Find the plugin that matches, since the plugins are sorted by length descending and alphabetically\n        // the first match will be the most specific\n        const plugin = this.#plugins.find((p) => rawKey.startsWith(p.name))\n\n        // Skip if no plugin is found\n        if (!plugin) continue\n\n        // Ensure the element has an id\n        if (!el.id.length) el.id = elUniqId(el)\n\n        // Extract the key and value from the dataset\n        let [key, ...rawModifiers] = rawKey\n          .slice(plugin.name.length)\n          .split(/\\_\\_+/)\n\n        const hasKey = key.length > 0\n        if (hasKey) {\n          // Keys starting with a dash are not converted to camel case in the dataset\n          const keySlice1 = key.slice(1)\n          key = key.startsWith('-')\n            ? keySlice1\n            : key[0].toLowerCase() + keySlice1\n        }\n        const value = `${el.dataset[rawKey]}` || ''\n        const hasValue = value.length > 0\n\n        // Create the runtime context\n        const that = this // I hate javascript\n        const ctx: RuntimeContext = {\n          get signals() {\n            return that.#signals\n          },\n          effect: (cb: () => void): OnRemovalFn => effect(cb),\n          apply: this.apply.bind(this),\n          cleanup: this.#cleanup.bind(this),\n          actions: this.#actions,\n          genRX: () => this.#genRX(ctx, ...(plugin.argNames || [])),\n          plugin,\n          el,\n          rawKey,\n          key,\n          value,\n          mods: new Map(),\n        }\n\n        // Check the requirements\n        const keyReq = plugin.keyReq || Requirement.Allowed\n        if (hasKey) {\n          if (keyReq === Requirement.Denied) {\n            throw runtimeErr(`${plugin.name}KeyNotAllowed`, ctx)\n          }\n        } else if (keyReq === Requirement.Must) {\n          throw runtimeErr(`${plugin.name}KeyRequired`, ctx)\n        }\n        const valReq = plugin.valReq || Requirement.Allowed\n        if (hasValue) {\n          if (valReq === Requirement.Denied) {\n            throw runtimeErr(`${plugin.name}ValueNotAllowed`, ctx)\n          }\n        } else if (valReq === Requirement.Must) {\n          throw runtimeErr(`${plugin.name}ValueRequired`, ctx)\n        }\n\n        // Check for exclusive requirements\n        if (\n          keyReq === Requirement.Exclusive ||\n          valReq === Requirement.Exclusive\n        ) {\n          if (hasKey && hasValue) {\n            throw runtimeErr(`${plugin.name}KeyAndValueProvided`, ctx)\n          }\n          if (!hasKey && !hasValue) {\n            throw runtimeErr(`${plugin.name}KeyOrValueRequired`, ctx)\n          }\n        }\n\n        for (const rawMod of rawModifiers) {\n          const [label, ...mod] = rawMod.split('.')\n          ctx.mods.set(\n            camelize(label),\n            new Set(mod.map((t) => t.toLowerCase())),\n          )\n        }\n\n        // Load the plugin and store any cleanup functions\n        const removal = plugin.onLoad(ctx)\n        if (removal) {\n          if (!this.#removals.has(el)) {\n            this.#removals.set(el, {\n              id: el.id,\n              fns: [],\n            })\n          }\n          this.#removals.get(el)?.fns.push(removal)\n        }\n\n        // Remove the attribute if required\n        if (plugin?.removeOnLoad) delete el.dataset[rawKey]\n      }\n    })\n  }\n\n  #genRX(\n    ctx: RuntimeContext,\n    ...argNames: string[]\n  ): RuntimeExpressionFunction {\n    // This regex allows Datastar expressions to support nested\n    // regex and strings that contain ; and/or \\n without breaking.\n    //\n    // Each of these regex defines a block type we want to match\n    // (importantly we ignore the content within these blocks):\n    //\n    // regex            \\/(\\\\\\/|[^\\/])*\\/\n    // double quotes      \"(\\\\\"|[^\\\"])*\"\n    // single quotes      '(\\\\'|[^'])*'\n    // ticks              `(\\\\`|[^`])*`\n    //\n    // We also want to match the non delimiter part of statements:\n    //\n    // [^;\\n]\n    //\n    const statementRe = /(\\/(\\\\\\/|[^\\/])*\\/|\"(\\\\\"|[^\\\"])*\"|'(\\\\'|[^'])*'|`(\\\\`|[^`])*`|[^;\\n])+/gm\n    const stmts = ctx.value.trim().match(statementRe)\n    const lastIdx = stmts.length - 1\n    const last = stmts[lastIdx]\n    if (!last.startsWith('return')) {\n      stmts[lastIdx] = `return (${last});`\n    }\n    let userExpression = stmts.join('\\n')\n\n    // Ingore any escaped values\n    const escaped = new Map<string, string>()\n    const escapeRe = new RegExp(`(?:${DSP})(.*?)(?:${DSS})`, 'gm')\n    for (const match of userExpression.matchAll(escapeRe)) {\n      const k = match[1]\n      const v = new Hash('dsEscaped').with(k).value\n      escaped.set(v, k)\n      userExpression = userExpression.replace(DSP + k + DSS, v)\n    }\n\n    const fnCall = /@(\\w*)\\(/gm\n    const matches = userExpression.matchAll(fnCall)\n    const methodsCalled = new Set<string>()\n    for (const match of matches) {\n      methodsCalled.add(match[1])\n    }\n\n    // Replace any action calls\n    const actionsRe = new RegExp(\n      `@(${Object.keys(this.#actions).join('|')})\\\\(`,\n      'gm',\n    )\n\n    // Add ctx to action calls\n    userExpression = userExpression.replaceAll(\n      actionsRe,\n      'ctx.actions.$1.fn(ctx,',\n    )\n\n    // Replace any signal calls\n    const signalNames = ctx.signals.paths()\n    if (signalNames.length) {\n      // Match any valid `$signalName` followed by a non-word character or end of string\n      const signalsRe = new RegExp(`\\\\$(${signalNames.join('|')})(\\\\W|$)`, 'gm')\n      userExpression = userExpression.replaceAll(\n        signalsRe,\n        `ctx.signals.signal('$1').value$2`,\n      )\n    }\n\n    // Replace any escaped values\n    for (const [k, v] of escaped) {\n      userExpression = userExpression.replace(k, v)\n    }\n\n    const fnContent = `return (()=> {\\n${userExpression}\\n})()` // Wrap in IIFE\n    ctx.fnContent = fnContent\n\n    try {\n      const fn = new Function('ctx', ...argNames, fnContent)\n      return (...args: any[]) => {\n        try {\n          return fn(ctx, ...args)\n        } catch (error: any) {\n          throw runtimeErr('ExecuteExpression', ctx, {\n            error: error.message,\n          })\n        }\n      }\n    } catch (error: any) {\n      throw runtimeErr('GenerateExpression', ctx, {\n        error: error.message,\n      })\n    }\n  }\n\n  #walkDownDOM(\n    element: Element | null,\n    callback: (el: HTMLorSVGElement) => void,\n  ) {\n    if (\n      !element ||\n      !(element instanceof HTMLElement || element instanceof SVGElement)\n    ) {\n      return null\n    }\n    const dataset = element.dataset\n    if ('starIgnore' in dataset) {\n      return null\n    }\n    if (!('starIgnore__self' in dataset)) {\n      callback(element)\n    }\n    let el = element.firstElementChild\n    while (el) {\n      this.#walkDownDOM(el, callback)\n      el = el.nextElementSibling\n    }\n  }\n\n  // Clenup all plugins associated with the element\n  #cleanup(el: Element) {\n    const removalSet = this.#removals.get(el)\n    if (removalSet) {\n      for (const removal of removalSet.fns) {\n        removal()\n      }\n      this.#removals.delete(el)\n    }\n  }\n}\n", "import { DSP } from '../engine/consts'\n// @ts-ignore\nconst _ = DSP // This is to force the import of DSP first in the compiled code\n\nimport { Computed } from '../plugins/official/core/attributes/computed'\nimport { Signals } from '../plugins/official/core/attributes/signals'\nimport { Star } from '../plugins/official/core/attributes/star'\nimport { Engine } from './engine'\n\nconst DS = new Engine()\nDS.load(Star, Signals, Computed)\nexport const Datastar = DS\n", "import { Datastar as DS } from '../engine'\n\nDS.apply(document.body)\nexport const Datastar = DS\n"],
  "mappings": "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",
  "names": ["lol", "DSP", "DSS", "DATASTAR", "VERSION", "FragmentMergeModes", "DefaultFragmentMergeMode", "PluginType", "name", "Computed", "key", "signals", "genRX", "rx", "kebabize", "str", "$", "ofs", "camelize", "word", "index", "jsStrToObject", "raw", "Signals", "ctx", "key", "value", "genRX", "signals", "mods", "ifMissing", "v", "obj", "jsStrToObject", "nv", "Star", "Hash", "#value", "#prefix", "prefix", "DATASTAR", "x", "c", "elUniqId", "el", "hash", "currentEl", "i", "e", "url", "dserr", "type", "reason", "metadata", "e", "DATASTAR", "r", "kebabize", "q", "c", "internalErr", "from", "args", "initErr", "ctx", "errCtx", "PluginType", "runtimeErr", "from", "BRAND_SYMBOL", "RUNNING", "NOTIFIED", "OUTDATED", "DISPOSED", "HAS_ERROR", "TRACKING", "startBatch", "batchDepth", "endBatch", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "needsToRecompute", "err", "internalErr", "evalContext", "batchedEffect", "batchDepth", "batchIteration", "globalVersion", "addDependency", "signal", "evalContext", "node", "TRACKING", "Signal", "value", "BRAND_SYMBOL", "prev", "next", "fn", "effect", "prevContext", "internalErr", "from", "startBatch", "endBatch", "needsToRecompute", "target", "node", "prepareSources", "rollbackNode", "cleanupSources", "head", "prev", "Computed", "fn", "Signal", "globalVersion", "OUTDATED", "NOTIFIED", "RUNNING", "TRACKING", "prevContext", "evalContext", "value", "HAS_ERROR", "err", "internalErr", "from", "addDependency", "computed", "cleanupEffect", "effect", "cleanup", "startBatch", "error", "DISPOSED", "disposeEffect", "endBatch", "endEffect", "Effect", "finish", "batchedEffect", "from", "nestedValues", "signal", "onlyPublic", "kv", "key", "value", "Signal", "mergeNested", "target", "values", "onlyIfMissing", "internalErr", "t", "walkNestedSignal", "cb", "path", "nestedSubset", "original", "keys", "subset", "parts", "subOriginal", "subSubset", "i", "part", "last", "SignalsRoot", "#signals", "dotDelimitedPath", "parts", "subSignals", "i", "part", "last", "signal", "internalErr", "from", "fn", "computed", "value", "defaultValue", "current", "Signal", "dotDelimitedPaths", "path", "other", "onlyIfMissing", "mergeNested", "keys", "nestedSubset", "cb", "walkNestedSignal", "signalNames", "onlyPublic", "nestedValues", "shouldIndent", "values", "Engine", "#signals", "SignalsRoot", "#plugins", "#actions", "#watchers", "#removals", "VERSION", "pluginsToLoad", "plugin", "that", "ctx", "cb", "effect", "#cleanup", "globalInitializer", "wp", "ap", "initErr", "a", "b", "lenDiff", "rootElement", "#walkDownDOM", "el", "rawKey", "p", "elUniqId", "key", "rawModifiers", "hasKey", "keySlice1", "value", "hasValue", "#genRX", "keyReq", "runtimeErr", "valReq", "rawMod", "label", "mod", "camelize", "t", "removal", "argNames", "statementRe", "stmts", "lastIdx", "last", "userExpression", "escaped", "escapeRe", "DSP", "DSS", "match", "k", "v", "Hash", "fnCall", "matches", "methodsCalled", "actionsRe", "signalNames", "signalsRe", "fnContent", "fn", "args", "error", "element", "callback", "dataset", "removalSet", "DS", "Engine", "Star", "Signals", "Computed", "Datastar", "Datastar"]
}
