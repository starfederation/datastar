{
  "version": 3,
  "sources": ["../library/src/engine/consts.ts", "../library/src/engine/types.ts", "../library/src/utils/text.ts", "../library/src/plugins/official/core/attributes/computed.ts", "../library/src/plugins/official/core/attributes/signals.ts", "../library/src/plugins/official/core/attributes/star.ts", "../library/src/utils/dom.ts", "../library/src/engine/errors.ts", "../library/src/engine/signals.ts", "../library/src/engine/engine.ts", "../library/src/engine/index.ts", "../library/src/vendored/fetch-event-source.ts", "../library/src/plugins/official/backend/shared.ts", "../library/src/plugins/official/backend/actions/sse.ts", "../library/src/plugins/official/backend/actions/delete.ts", "../library/src/plugins/official/backend/actions/get.ts", "../library/src/plugins/official/backend/actions/patch.ts", "../library/src/plugins/official/backend/actions/post.ts", "../library/src/plugins/official/backend/actions/put.ts", "../library/src/plugins/official/backend/attributes/indicator.ts", "../library/src/plugins/official/backend/watchers/executeScript.ts", "../library/src/utils/view-transtions.ts", "../library/src/vendored/idiomorph.esm.js", "../library/src/plugins/official/backend/watchers/mergeFragments.ts", "../library/src/plugins/official/backend/watchers/mergeSignals.ts", "../library/src/plugins/official/backend/watchers/removeFragments.ts", "../library/src/plugins/official/backend/watchers/removeSignals.ts", "../library/src/plugins/official/browser/actions/clipboard.ts", "../library/src/plugins/official/browser/attributes/customValidity.ts", "../library/src/plugins/official/browser/attributes/intersects.ts", "../library/src/utils/tags.ts", "../library/src/utils/timing.ts", "../library/src/plugins/official/dom/attributes/on.ts", "../library/src/plugins/official/browser/attributes/persist.ts", "../library/src/plugins/official/browser/attributes/replaceUrl.ts", "../library/src/plugins/official/browser/attributes/scrollIntoView.ts", "../library/src/plugins/official/browser/attributes/show.ts", "../library/src/plugins/official/browser/attributes/viewTransition.ts", "../library/src/plugins/official/dom/attributes/attr.ts", "../library/src/plugins/official/dom/attributes/bind.ts", "../library/src/plugins/official/dom/attributes/class.ts", "../library/src/plugins/official/dom/attributes/ref.ts", "../library/src/plugins/official/dom/attributes/text.ts", "../library/src/plugins/official/logic/actions/fit.ts", "../library/src/plugins/official/logic/actions/setAll.ts", "../library/src/plugins/official/logic/actions/toggleAll.ts", "../library/src/bundles/datastar.ts"],
  "sourcesContent": ["// This is auto-generated by Datastar. DO NOT EDIT.\nconst lol = /\uD83D\uDD95JS_DS\uD83D\uDE80/.source\nexport const DSP = lol.slice(0, 5)\nexport const DSS = lol.slice(4)\n\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_REQUEST = \"Datastar-Request\";\n\n// #region Defaults\n\n// #region Default durations\n\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000;\n\n// #endregion\n\n\n// #region Default strings\n\n// The default attributes for <script/> element use when executing scripts. It is a set of key-value pairs delimited by a newline \\\\n character.\nexport const DefaultExecuteScriptAttributes = \"type module\";\n\n// #endregion\n\n\n// #region Default booleans\n\n// Should fragments be merged using the ViewTransition API?\nexport const DefaultFragmentsUseViewTransitions = false;\n\n// Should a given set of signals merge if they are missing?\nexport const DefaultMergeSignalsOnlyIfMissing = false;\n\n// Should script element remove itself after execution?\nexport const DefaultExecuteScriptAutoRemove = true;\n\n// #endregion\n\n\n// #region Enums\n\n// The mode in which a fragment is merged into the DOM.\nexport const FragmentMergeModes = {\n    // Morphs the fragment into the existing element using idiomorph.\n    Morph: \"morph\",\n    // Replaces the inner HTML of the existing element.\n    Inner: \"inner\",\n    // Replaces the outer HTML of the existing element.\n    Outer: \"outer\",\n    // Prepends the fragment to the existing element.\n    Prepend: \"prepend\",\n    // Appends the fragment to the existing element.\n    Append: \"append\",\n    // Inserts the fragment before the existing element.\n    Before: \"before\",\n    // Inserts the fragment after the existing element.\n    After: \"after\",\n    // Upserts the attributes of the existing element.\n    UpsertAttributes: \"upsertAttributes\",\n} as const;\n\n// Default value for FragmentMergeMode\nexport const DefaultFragmentMergeMode = FragmentMergeModes.Morph;\n\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\nexport const EventTypes = {\n    // An event for merging HTML fragments into the DOM.\n    MergeFragments: \"datastar-merge-fragments\",\n    // An event for merging signals.\n    MergeSignals: \"datastar-merge-signals\",\n    // An event for removing HTML fragments from the DOM.\n    RemoveFragments: \"datastar-remove-fragments\",\n    // An event for removing signals.\n    RemoveSignals: \"datastar-remove-signals\",\n    // An event for executing <script/> elements in the browser.\n    ExecuteScript: \"datastar-execute-script\",\n} as const;\n// #endregion\n\n// #endregion", "import { DATASTAR } from './consts'\nimport type { Dependency, EffectFn, SignalsRoot } from './signals'\n\nexport type OnRemovalFn = () => void\n\nexport enum PluginType {\n  Attribute = 1,\n  Watcher = 2,\n  Action = 3,\n}\n\nexport interface DatastarPlugin {\n  type: PluginType // The type of plugin\n  name: string // The name of the plugin\n}\n\nexport enum Requirement {\n  Allowed = 0,\n  Must = 1,\n  Denied = 2,\n  Exclusive = 3,\n}\n\nexport interface DatastarSignalEvent {\n  added: Array<string>\n  removed: Array<string>\n  updated: Array<string>\n}\nexport const DATASTAR_SIGNAL_EVENT = `${DATASTAR}-signals`\nexport interface CustomEventMap {\n  [DATASTAR_SIGNAL_EVENT]: CustomEvent<DatastarSignalEvent>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\ndeclare global {\n  interface Document {\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n  }\n}\n\n// A plugin accesible via a `data-${name}` attribute on an element\nexport interface AttributePlugin extends DatastarPlugin {\n  type: PluginType.Attribute\n  onGlobalInit?: (ctx: InitContext) => void // Called once on registration of the plugin\n  onLoad: (ctx: RuntimeContext) => OnRemovalFn | void // Return a function to be called on removal\n  mods?: Set<string> // If not provided, all modifiers are allowed\n  keyReq?: Requirement // The rules for the key requirements\n  valReq?: Requirement // The rules for the value requirements\n  argNames?: string[] // argument names for the reactive expression\n}\n\n// A plugin that runs on the global scope of the DastaStar instance\nexport interface WatcherPlugin extends DatastarPlugin {\n  type: PluginType.Watcher\n  onGlobalInit?: (ctx: InitContext) => void\n}\n\nexport type ActionPlugins = Record<string, ActionPlugin>\nexport type ActionMethod = (ctx: RuntimeContext, ...args: any[]) => any\n\nexport interface ActionPlugin extends DatastarPlugin {\n  type: PluginType.Action\n  fn: ActionMethod\n}\n\nexport type GlobalInitializer = (ctx: InitContext) => void\n\nexport type InitContext = {\n  plugin: DatastarPlugin\n  signals: SignalsRoot\n  effect: EffectFn\n  actions: Readonly<ActionPlugins>\n  removals: Map<string, Map<number, OnRemovalFn>>\n  applyToElement: (el: HTMLorSVGElement) => void\n}\n\nexport type HTMLorSVGElement = Element & (HTMLElement | SVGElement)\nexport type Modifiers = Map<string, Set<string>> // mod name -> tags\n\nexport type RuntimeContext = InitContext & {\n  plugin: DatastarPlugin // The name of the plugin\n  el: HTMLorSVGElement // The element the attribute is on\n  rawKey: Readonly<string> // no parsing data-* key\n  key: Readonly<string> // data-* key without the prefix or tags\n  value: Readonly<string> // value of data-* attribute\n  mods: Modifiers // the tags and their arguments\n  genRX: () => {\n    deps: Dependency[]\n    rxFn: <T>(...args: any[]) => T // a reactive expression\n  }\n  fnContent?: string // the content of the function\n}\n\nexport type NestedValues = { [key: string]: NestedValues | any }\nexport type NestedSignal = {\n  [key: string]: NestedSignal | Dependency\n}\n\nexport type RuntimeExpressionFunction = (\n  ctx: RuntimeContext,\n  ...args: any[]\n) => any\n", "import type { Modifiers } from '../engine/types'\n\nexport const isBoolString = (str: string) => str.trim() === 'true'\n\nexport const kebab = (str: string) =>\n  str.replace(\n    /[A-Z]+(?![a-z])|[A-Z]/g,\n    ($, ofs) => (ofs ? '-' : '') + $.toLowerCase(),\n  )\n\nexport const camel = (str: string) =>\n  kebab(str).replace(/-./g, (x) => x[1].toUpperCase())\n\nexport const snake = (str: string) => kebab(str).replace(/-/g, '_')\n\nexport const pascal = (str: string) =>\n  camel(str).replace(/^./, (x) => x[0].toUpperCase())\n\nexport const jsStrToObject = (raw: string) =>\n  new Function(`return Object.assign({}, ${raw})`)()\n\nexport const trimDollarSignPrefix = (str: string) =>\n  str.startsWith('$') ? str.slice(1) : str\n\nconst caseFns: Record<string, (s: string) => string> = { kebab, snake, pascal }\n\nexport function modifyCasing(str: string, mods: Modifiers) {\n  for (const c of mods.get('case') || []) {\n    const fn = caseFns[c]\n    if (fn) str = fn(str)\n  }\n  return str\n}\n", "import {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { modifyCasing } from '../../../../utils/text'\n\nconst name = 'computed'\nexport const Computed: AttributePlugin = {\n  type: PluginType.Attribute,\n  name,\n  keyReq: Requirement.Must,\n  valReq: Requirement.Must,\n  onLoad: ({ key, mods, signals, genRX }) => {\n    key = modifyCasing(key, mods)\n    const { deps, rxFn } = genRX()\n    signals.setComputed(key, deps, rxFn)\n  },\n}\n", "import {\n  type AttributePlugin,\n  type NestedValues,\n  PluginType,\n} from '../../../../engine/types'\nimport { jsStrToObject, modifyCasing } from '../../../../utils/text'\n\nexport const Signals: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'signals',\n  onLoad: (ctx) => {\n    const { key, mods, signals, value, genRX } = ctx\n    const ifMissing = mods.has('ifmissing')\n    const { rxFn } = genRX()\n    if (key !== '') {\n      const k = modifyCasing(key, mods)\n      const v = value === '' ? value : rxFn()\n      if (ifMissing) {\n        signals.upsertIfMissing(k, v)\n      } else {\n        signals.setValue(k, v)\n      }\n    } else {\n      const obj = jsStrToObject(ctx.value)\n      ctx.value = JSON.stringify(obj)\n      const nv = rxFn<NestedValues>()\n      signals.merge(nv, ifMissing)\n    }\n  },\n}\n", "import {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nexport const Star: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'star',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Denied,\n  onLoad: () => {\n    alert('YOU ARE PROBABLY OVERCOMPLICATING IT')\n  },\n}\n", "import { DATASTAR } from '../engine/consts'\nimport type { HTMLorSVGElement } from '../engine/types'\n\nexport class Hash {\n  #value = 0\n  #prefix: string\n\n  constructor(prefix = DATASTAR) {\n    this.#prefix = prefix\n  }\n\n  with(x: number | string | boolean): Hash {\n    if (typeof x === 'string') {\n      for (const c of x.split('')) {\n        this.with(c.charCodeAt(0))\n      }\n    } else if (typeof x === 'boolean') {\n      this.with(1 << (x ? 7 : 3))\n    } else {\n      // use djb2 favored by bernstein http://www.cse.yorku.ca/~oz/hash.html\n      this.#value = (this.#value * 33) ^ x\n    }\n    return this\n  }\n\n  get value() {\n    return this.#value\n  }\n\n  get string() {\n    return this.#prefix + Math.abs(this.#value).toString(36)\n  }\n}\n\nexport function elUniqId(el: Element) {\n  if (el.id) return el.id\n  const hash = new Hash()\n\n  let currentEl = el\n  while (currentEl) {\n    hash.with(currentEl.tagName || '')\n    if (currentEl.id) {\n      hash.with(currentEl.id)\n      break\n    }\n    const p = currentEl?.parentNode\n    if (p) hash.with([...p.children].indexOf(currentEl))\n\n    currentEl = p as Element\n  }\n  return hash.string\n}\n\nexport function attrHash(key: number | string, val: number | string) {\n  return new Hash().with(key).with(val).value\n}\n\nexport function walkDOM(\n  element: Element | null,\n  callback: (el: HTMLorSVGElement) => void,\n) {\n  if (\n    !element ||\n    !(element instanceof HTMLElement || element instanceof SVGElement)\n  ) {\n    return null\n  }\n  const dataset = element.dataset\n  if ('starIgnore' in dataset) {\n    return null\n  }\n  if (!('starIgnore__self' in dataset)) {\n    callback(element)\n  }\n  let el = element.firstElementChild\n  while (el) {\n    walkDOM(el, callback)\n    el = el.nextElementSibling\n  }\n}\n", "import { snake } from '../utils/text'\nimport { DATASTAR } from './consts'\nimport { type InitContext, PluginType, type RuntimeContext } from './types'\n\nconst url = 'https://data-star.dev/errors'\n\ninterface Metadata {\n  error?: string\n  [key: string]: any\n}\n\nfunction dserr(type: string, reason: string, metadata: Metadata = {}) {\n  const e = new Error()\n  e.name = `${DATASTAR} ${type} error`\n  const r = snake(reason)\n  const q = new URLSearchParams({\n    metadata: JSON.stringify(metadata),\n  }).toString()\n  const c = JSON.stringify(metadata, null, 2)\n  e.message = `${reason}\\nMore info: ${url}/${type}/${r}?${q}\\nContext: ${c}`\n  return e\n}\n\nexport function internalErr(from: string, reason: string, args = {}) {\n  return dserr('internal', reason, Object.assign({ from }, args))\n}\n\nexport function initErr(reason: string, ctx: InitContext, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: PluginType[ctx.plugin.type],\n    },\n  }\n  return dserr('init', reason, Object.assign(errCtx, metadata))\n}\n\nexport function runtimeErr(reason: string, ctx: RuntimeContext, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: PluginType[ctx.plugin.type],\n    },\n    element: {\n      id: ctx.el.id,\n      tag: ctx.el.tagName,\n    },\n    expression: {\n      rawKey: ctx.rawKey,\n      key: ctx.key,\n      value: ctx.value,\n      validSignals: ctx.signals.paths(),\n      fnContent: ctx.fnContent,\n    },\n  }\n  return dserr('runtime', reason, Object.assign(errCtx, metadata))\n}\n", "import { internalErr } from './errors'\nimport {\n  DATASTAR_SIGNAL_EVENT,\n  type DatastarSignalEvent,\n  type NestedSignal as NestedDependency,\n  type NestedValues,\n} from './types'\n\nconst from = 'namespacedSignals'\n\nconst dispatchSignalEvent = (evt: Partial<DatastarSignalEvent>) => {\n  document.dispatchEvent(\n    new CustomEvent<DatastarSignalEvent>(DATASTAR_SIGNAL_EVENT, {\n      detail: Object.assign({ added: [], removed: [], updated: [] }, evt),\n    }),\n  )\n}\n\n// If onlyPublic is true, only signals not starting with an underscore are included\nfunction nestedValues(\n  signal: NestedDependency,\n  onlyPublic = false,\n): Record<string, any> {\n  const kv: Record<string, any> = {}\n  for (const key in signal) {\n    if (Object.hasOwn(signal, key)) {\n      if (onlyPublic && key.startsWith('_')) {\n        continue\n      }\n      const value = signal[key]\n      if (value instanceof Dependency) {\n        kv[key] = value.value\n      } else {\n        kv[key] = nestedValues(value)\n      }\n    }\n  }\n  return kv\n}\n\nfunction mergeNested(\n  target: NestedValues,\n  values: NestedValues,\n  pathPrefix: string,\n  onlyIfMissing = false,\n) {\n  const evt: DatastarSignalEvent = {\n    added: [],\n    removed: [],\n    updated: [],\n  }\n  for (const key in values) {\n    if (Object.hasOwn(values, key)) {\n      if (key.match(/\\_\\_+/)) {\n        throw internalErr(from, 'InvalidSignalKey', { key })\n      }\n      const path = pathPrefix ? `${pathPrefix}.${key}` : key\n      const value = values[key]\n      if (value instanceof Object && !Array.isArray(value)) {\n        if (!target[key]) {\n          target[key] = {}\n        }\n        const subEvt = mergeNested(\n          target[key] as NestedValues,\n          value as NestedValues,\n          path,\n          onlyIfMissing,\n        )\n        evt.added.push(...subEvt.added.map((k) => `${path}.${k}`))\n        evt.removed.push(...subEvt.removed.map((k) => `${path}.${k}`))\n        evt.updated.push(...subEvt.updated.map((k) => `${path}.${k}`))\n      } else {\n        const hasKey = Object.hasOwn(target, key)\n        if (hasKey) {\n          if (onlyIfMissing) continue\n          const t = target[key]\n          if (t instanceof Signal) {\n            const oldValue = t.value\n            t.value = value\n            if (oldValue !== value) {\n              evt.updated.push(path)\n            }\n            continue\n          }\n        }\n        const s = new Signal(value, () =>\n          dispatchSignalEvent({ updated: [path] }),\n        )\n        target[key] = s\n        evt.added.push(path)\n      }\n    }\n  }\n  return evt\n}\n\nfunction walkNestedSignal(\n  signal: NestedDependency,\n  cb: (dotDeliminatedPath: string, dep: Dependency) => void,\n): void {\n  for (const key in signal) {\n    if (Object.hasOwn(signal, key)) {\n      const value = signal[key]\n      if (value instanceof Dependency) {\n        cb(key, value)\n      } else {\n        walkNestedSignal(value, (path, value) => {\n          cb(`${key}.${path}`, value)\n        })\n      }\n    }\n  }\n}\n\n// Recursive function to subset a nested object, each key is a dot-delimited path\nfunction nestedSubset(original: NestedValues, ...keys: string[]): NestedValues {\n  const subset: NestedValues = {}\n  for (const key of keys) {\n    const parts = key.split('.')\n    let subOriginal = original\n    let subSubset = subset\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subOriginal[part]) {\n        return {}\n      }\n      if (!subSubset[part]) {\n        subSubset[part] = {}\n      }\n      subOriginal = subOriginal[part] as NestedValues\n      subSubset = subSubset[part] as NestedValues\n    }\n    const last = parts[parts.length - 1]\n    subSubset[last] = subOriginal[last]\n  }\n  return subset\n}\n\n// Recursively walk a NestedValue with a callback and dot-delimited path\nexport function walkNestedValues(\n  nv: NestedValues,\n  cb: (path: string, value: any) => void,\n) {\n  for (const key in nv) {\n    if (Object.hasOwn(nv, key)) {\n      const value = nv[key]\n      if (value instanceof Object && !Array.isArray(value)) {\n        walkNestedValues(value, (path, value) => {\n          cb(`${key}.${path}`, value)\n        })\n      } else {\n        cb(key, value)\n      }\n    }\n  }\n}\n\nexport class SignalsRoot {\n  #signals: NestedDependency = {}\n\n  exists(dotDelimitedPath: string): boolean {\n    return !!this.signal(dotDelimitedPath)\n  }\n\n  signal(dotDelimitedPath: string): Dependency | null {\n    const parts = dotDelimitedPath.split('.')\n    let subDeps = this.#signals\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subDeps[part]) {\n        return null\n      }\n      subDeps = subDeps[part] as NestedDependency\n    }\n    const last = parts[parts.length - 1]\n    const dep = subDeps[last]\n    if (!dep)\n      throw internalErr(from, 'SignalNotFound', { path: dotDelimitedPath })\n    return dep as Dependency\n  }\n\n  setSignal(dotDelimitedPath: string, signal: Dependency) {\n    const parts = dotDelimitedPath.split('.')\n    let subSignals = this.#signals\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subSignals[part]) {\n        subSignals[part] = {}\n      }\n      subSignals = subSignals[part] as NestedDependency\n    }\n    const last = parts[parts.length - 1]\n    subSignals[last] = signal\n  }\n\n  setComputed<T>(\n    dotDelimitedPath: string,\n    deps: Dependency[],\n    fn: DerivedFn<T>,\n  ) {\n    const c = computed(deps, fn)\n    this.setSignal(dotDelimitedPath, c)\n  }\n\n  value<T>(dotDelimitedPath: string): T {\n    const signal = this.signal(dotDelimitedPath) as Dependency\n    return signal?.value as T\n  }\n\n  setValue<T>(dotDelimitedPath: string, value: T) {\n    const { signal } = this.upsertIfMissing(dotDelimitedPath, value)\n    const oldValue = signal.value\n    signal.value = value\n    if (oldValue !== value) {\n      dispatchSignalEvent({ updated: [dotDelimitedPath] })\n    }\n  }\n\n  upsertIfMissing<T>(dotDelimitedPath: string, defaultValue: T) {\n    const parts = dotDelimitedPath.split('.')\n    let subSignals = this.#signals\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subSignals[part]) {\n        subSignals[part] = {}\n      }\n      subSignals = subSignals[part] as NestedDependency\n    }\n    const last = parts[parts.length - 1]\n\n    const current = subSignals[last]\n    if (current instanceof Signal) {\n      return { signal: current as Signal<T>, inserted: false }\n    }\n\n    const signal = new Signal(defaultValue)\n    signal.onChange = () => {\n      dispatchSignalEvent({ updated: [dotDelimitedPath] })\n    }\n    subSignals[last] = signal\n\n    dispatchSignalEvent({ added: [dotDelimitedPath] })\n\n    return { signal: signal, inserted: true }\n  }\n\n  remove(...dotDelimitedPaths: string[]) {\n    if (!dotDelimitedPaths.length) {\n      this.#signals = {}\n      return\n    }\n    const removed = Array<string>()\n    for (const path of dotDelimitedPaths) {\n      const parts = path.split('.')\n      let subSignals = this.#signals\n      for (let i = 0; i < parts.length - 1; i++) {\n        const part = parts[i]\n        if (!subSignals[part]) {\n          return\n        }\n        subSignals = subSignals[part] as NestedDependency\n      }\n      const last = parts[parts.length - 1]\n      delete subSignals[last]\n      removed.push(path)\n    }\n    dispatchSignalEvent({ removed })\n  }\n\n  merge(other: NestedValues, onlyIfMissing = false) {\n    const evt = mergeNested(this.#signals, other, '', onlyIfMissing)\n    if (evt.added.length || evt.removed.length || evt.updated.length) {\n      dispatchSignalEvent(evt)\n    }\n  }\n\n  subset(...keys: string[]): NestedValues {\n    return nestedSubset(this.values(), ...keys)\n  }\n\n  walk(cb: (name: string, signal: Dependency) => void) {\n    walkNestedSignal(this.#signals, cb)\n  }\n\n  paths() {\n    const signalNames = new Array<string>()\n    this.walk((path) => signalNames.push(path))\n    return signalNames\n  }\n\n  values(onlyPublic = false): NestedValues {\n    return nestedValues(this.#signals, onlyPublic)\n  }\n\n  JSON(shouldIndent = true, onlyPublic = false) {\n    const values = this.values(onlyPublic)\n    if (!shouldIndent) {\n      return JSON.stringify(values)\n    }\n    return JSON.stringify(values, null, 2)\n  }\n\n  public toString() {\n    return this.JSON()\n  }\n}\n\nabstract class Subscriber {\n  abstract markDirty(): void\n}\n\nexport abstract class Dependency {\n  abstract readonly value: unknown\n  abstract version(): number\n  abstract addSubscribers(...subscribers: Subscriber[]): void\n  abstract removeSubscribers(...subscribers: Subscriber[]): void\n}\n\nexport class Signal<T> extends Dependency implements Subscriber {\n  subs = new Set<Subscriber>()\n  ver = 1\n\n  constructor(\n    private val: T,\n    public onChange?: (val: T) => void,\n  ) {\n    super()\n  }\n\n  set value(val: T) {\n    if (this.val === val) {\n      return\n    }\n    this.val = val\n    this.ver++\n    this.markDirty()\n    this.onChange?.(val)\n  }\n\n  markDirty() {\n    for (const sub of this.subs) {\n      sub.markDirty()\n    }\n  }\n\n  get value() {\n    return this.val\n  }\n\n  version() {\n    return this.ver\n  }\n\n  addSubscribers(...subscribers: Subscriber[]) {\n    for (const sub of subscribers) {\n      this.subs.add(sub)\n    }\n  }\n\n  removeSubscribers(...subscribers: Subscriber[]) {\n    for (const sub of subscribers) {\n      this.subs.delete(sub)\n    }\n  }\n}\n\nexport function signal<T>(initialValue: T) {\n  return new Signal(initialValue)\n}\n\nexport type DerivedFn<O> = (...args: unknown[]) => O\n\nexport class Derived<O> extends Dependency implements Subscriber {\n  subs = new Set<Subscriber>()\n  isDirty = true\n  ver = 1\n  val!: O\n  versionSum = 0\n\n  constructor(\n    private deps: Dependency[],\n    private fn: DerivedFn<O>,\n  ) {\n    super()\n    for (const dep of deps) {\n      dep.addSubscribers(this)\n    }\n  }\n\n  get value() {\n    if (!this.isDirty) {\n      return this.val\n    }\n    this.isDirty = false\n    let depsVersionSum = 0\n    for (const dep of this.deps) {\n      depsVersionSum += dep.version()\n    }\n    if (depsVersionSum === this.versionSum) {\n      return this.val\n    }\n\n    this.versionSum = depsVersionSum\n    const args = this.deps.map((dep) => dep.value)\n    const currentVal = this.fn(...args)\n    if (this.val === currentVal) {\n      return this.val\n    }\n    this.val = currentVal\n    this.ver++\n    return this.val\n  }\n\n  version() {\n    return this.ver\n  }\n\n  markDirty() {\n    this.isDirty = true\n    for (const sub of this.subs) {\n      sub.markDirty()\n    }\n  }\n\n  addSubscribers(...subscribers: Subscriber[]) {\n    for (const sub of subscribers) {\n      this.subs.add(sub)\n    }\n  }\n\n  removeSubscribers(...subscribers: Subscriber[]) {\n    for (const sub of subscribers) {\n      this.subs.delete(sub)\n    }\n  }\n}\n\nexport function computed<O>(deps: Dependency[], fn: (...args: unknown[]) => O) {\n  return new Derived(deps, fn)\n}\n\nexport class Effect implements Subscriber {\n  depsVersionSum = -1\n\n  constructor(\n    private deps: Dependency[],\n    private fn: (...args: unknown[]) => void,\n  ) {\n    for (const dep of deps) {\n      dep.addSubscribers(this)\n    }\n  }\n\n  markDirty() {\n    let depsVersionSum = 0\n    for (const dep of this.deps) {\n      depsVersionSum += dep.version()\n    }\n    if (depsVersionSum === this.depsVersionSum) {\n      return\n    }\n    this.depsVersionSum = depsVersionSum\n    const args = this.deps.map((dep) => dep.value)\n    this.fn(...args)\n  }\n}\n\nexport type OnRemovalFn = () => void\nexport type EffectFn = (\n  deps: Dependency[],\n  fn: (...args: unknown[]) => void,\n) => OnRemovalFn\n\nexport function effect(\n  deps: Dependency[],\n  fn: (...args: unknown[]) => void,\n): OnRemovalFn {\n  const e = new Effect(deps, fn)\n  e.markDirty()\n  return () => {\n    for (const dep of deps) {\n      dep.removeSubscribers(e)\n    }\n  }\n}\n", "import { Hash, attrHash, elUniqId, walkDOM } from '../utils/dom'\nimport { camel } from '../utils/text'\nimport { DSP, DSS } from './consts'\nimport { initErr, runtimeErr } from './errors'\nimport { type Dependency, SignalsRoot, effect } from './signals'\nimport {\n  type ActionPlugin,\n  type ActionPlugins,\n  type AttributePlugin,\n  type DatastarPlugin,\n  type GlobalInitializer,\n  type HTMLorSVGElement,\n  type InitContext,\n  type OnRemovalFn,\n  PluginType,\n  Requirement,\n  type RuntimeContext,\n  type RuntimeExpressionFunction,\n  type WatcherPlugin,\n} from './types'\n\nconst signals: SignalsRoot = new SignalsRoot()\nconst actions: ActionPlugins = {}\nconst plugins: AttributePlugin[] = []\n\n// Map of cleanup functions by element ID, keyed by a dataset key-value hash\nconst removals = new Map<string, Map<number, OnRemovalFn>>()\n\nlet mutationObserver: MutationObserver | null = null\n\nlet alias = ''\nexport function setAlias(value: string) {\n  alias = value\n}\n\nexport function load(...pluginsToLoad: DatastarPlugin[]) {\n  for (const plugin of pluginsToLoad) {\n    const ctx: InitContext = {\n      plugin,\n      signals,\n      effect: (args: any[], cb: () => void): OnRemovalFn => effect(args, cb),\n      actions,\n      removals,\n      applyToElement,\n    }\n\n    let globalInitializer: GlobalInitializer | undefined\n    switch (plugin.type) {\n      case PluginType.Action: {\n        actions[plugin.name] = plugin as ActionPlugin\n        break\n      }\n      case PluginType.Attribute: {\n        const ap = plugin as AttributePlugin\n        plugins.push(ap)\n        globalInitializer = ap.onGlobalInit\n        break\n      }\n      case PluginType.Watcher: {\n        const wp = plugin as WatcherPlugin\n        globalInitializer = wp.onGlobalInit\n        break\n      }\n      default: {\n        throw initErr('InvalidPluginType', ctx)\n      }\n    }\n    if (globalInitializer) {\n      globalInitializer(ctx)\n    }\n  }\n\n  // Sort attribute plugins by descending length then alphabetically\n  plugins.sort((a, b) => {\n    const lenDiff = b.name.length - a.name.length\n    if (lenDiff !== 0) return lenDiff\n    return a.name.localeCompare(b.name)\n  })\n}\n\n// Apply all plugins to all elements in the DOM\nexport function apply() {\n  // Delay applying plugins to give custom plugins a chance to load\n  queueMicrotask(() => {\n    applyToElement(document.documentElement)\n    observe()\n  })\n}\n\n// Apply all plugins to the element and its children\nfunction applyToElement(rootElement: HTMLorSVGElement) {\n  walkDOM(rootElement, (el) => {\n    // Check if the element has any data attributes already\n    const toApply = new Array<string>()\n    const elCleanups = removals.get(el.id) || new Map()\n    const toCleanup = new Map<number, OnRemovalFn>([...elCleanups])\n    const hashes = new Map<string, number>()\n\n    // Apply the plugins to the element in order of application\n    // since DOMStringMap is ordered, we can be deterministic\n    for (const datasetKey of Object.keys(el.dataset)) {\n      // Ignore data attributes that don\u2019t start with the alias\n      if (!datasetKey.startsWith(alias)) {\n        break\n      }\n\n      const datasetValue = el.dataset[datasetKey] || ''\n      const currentHash = attrHash(datasetKey, datasetValue)\n      hashes.set(datasetKey, currentHash)\n\n      // If the hash hasn't changed, ignore\n      // otherwise keep the old cleanup and add new to applys\n      if (elCleanups.has(currentHash)) {\n        toCleanup.delete(currentHash)\n      } else {\n        toApply.push(datasetKey)\n      }\n    }\n\n    // Clean up any old plugins and apply the new ones\n    for (const [_, cleanup] of toCleanup) {\n      cleanup()\n    }\n    for (const key of toApply) {\n      const h = hashes.get(key)!\n      applyAttributePlugin(el, key, h)\n    }\n  })\n}\n\n// Set up a mutation observer to run plugin removal and apply functions\nfunction observe() {\n  if (mutationObserver) {\n    return\n  }\n\n  mutationObserver = new MutationObserver((mutations) => {\n    const toRemove = new Set<HTMLorSVGElement>()\n    const toApply = new Set<HTMLorSVGElement>()\n    for (const { target, type, addedNodes, removedNodes } of mutations) {\n      switch (type) {\n        case 'childList':\n          {\n            for (const node of removedNodes) {\n              toRemove.add(node as HTMLorSVGElement)\n            }\n            for (const node of addedNodes) {\n              toApply.add(node as HTMLorSVGElement)\n            }\n          }\n          break\n        case 'attributes': {\n          toApply.add(target as HTMLorSVGElement)\n\n          break\n        }\n      }\n    }\n    for (const el of toRemove) {\n      const elTracking = removals.get(el.id)\n      if (elTracking) {\n        for (const [hash, cleanup] of elTracking) {\n          cleanup()\n          elTracking.delete(hash)\n        }\n        if (elTracking.size === 0) {\n          removals.delete(el.id)\n        }\n      }\n    }\n    for (const el of toApply) {\n      applyToElement(el)\n    }\n  })\n\n  mutationObserver.observe(document.body, {\n    attributes: true,\n    attributeOldValue: true,\n    childList: true,\n    subtree: true,\n  })\n}\n\nfunction applyAttributePlugin(\n  el: HTMLorSVGElement,\n  camelCasedKey: string,\n  hash: number,\n) {\n  // Extract the raw key from the dataset\n  const rawKey = camel(camelCasedKey.slice(alias.length))\n\n  // Find the plugin that matches, since the plugins are sorted by length descending and alphabetically. The first match will be the most specific.\n  const plugin = plugins.find((p) => {\n    // Ignore keys with the plugin name as a prefix (ignores `classes` but not `classBold`)\n    const regex = new RegExp(`^${p.name}([A-Z]|_|$)`)\n    return regex.test(rawKey)\n  })\n\n  // Skip if no plugin is found\n  if (!plugin) return\n\n  // Ensure the element has an id\n  if (!el.id.length) el.id = elUniqId(el)\n\n  // Extract the key and modifiers\n  let [key, ...rawModifiers] = rawKey.slice(plugin.name.length).split(/\\_\\_+/)\n\n  const hasKey = key.length > 0\n  if (hasKey) {\n    key = camel(key)\n  }\n  const value = el.dataset[camelCasedKey] || ''\n  const hasValue = value.length > 0\n\n  // Create the runtime context\n  const ctx: RuntimeContext = {\n    signals,\n    applyToElement,\n    effect: (args: any[], cb: () => void): OnRemovalFn => effect(args, cb),\n    actions,\n    removals,\n    genRX: () => genRX(ctx, ...(plugin.argNames || [])),\n    plugin,\n    el,\n    rawKey,\n    key,\n    value,\n    mods: new Map(),\n  }\n\n  // Check the requirements\n  const keyReq = plugin.keyReq || Requirement.Allowed\n  if (hasKey) {\n    if (keyReq === Requirement.Denied) {\n      throw runtimeErr(`${plugin.name}KeyNotAllowed`, ctx)\n    }\n  } else if (keyReq === Requirement.Must) {\n    throw runtimeErr(`${plugin.name}KeyRequired`, ctx)\n  }\n\n  const valReq = plugin.valReq || Requirement.Allowed\n  if (hasValue) {\n    if (valReq === Requirement.Denied) {\n      throw runtimeErr(`${plugin.name}ValueNotAllowed`, ctx)\n    }\n  } else if (valReq === Requirement.Must) {\n    throw runtimeErr(`${plugin.name}ValueRequired`, ctx)\n  }\n\n  // Check for exclusive requirements\n  if (keyReq === Requirement.Exclusive || valReq === Requirement.Exclusive) {\n    if (hasKey && hasValue) {\n      throw runtimeErr(`${plugin.name}KeyAndValueProvided`, ctx)\n    }\n    if (!hasKey && !hasValue) {\n      throw runtimeErr(`${plugin.name}KeyOrValueRequired`, ctx)\n    }\n  }\n\n  for (const rawMod of rawModifiers) {\n    const [label, ...mod] = rawMod.split('.')\n    ctx.mods.set(camel(label), new Set(mod.map((t) => t.toLowerCase())))\n  }\n\n  // Load the plugin\n  const cleanup = plugin.onLoad(ctx) ?? (() => {})\n\n  // Store the cleanup function\n  let elTracking = removals.get(el.id)\n  if (!elTracking) {\n    elTracking = new Map()\n    removals.set(el.id, elTracking)\n  }\n  elTracking.set(hash, cleanup)\n}\n\nfunction genRX(\n  ctx: RuntimeContext,\n  ...argNames: string[]\n): {\n  deps: Dependency[]\n  rxFn: RuntimeExpressionFunction\n} {\n  let userExpression = ''\n\n  // Use a set to ensure unique dependencies\n  const depSignalNames = new Set<string>()\n\n  // This regex allows Datastar expressions to support nested\n  // regex and strings that contain ; without breaking.\n  //\n  // Each of these regex defines a block type we want to match\n  // (importantly we ignore the content within these blocks):\n  //\n  // regex            \\/(\\\\\\/|[^\\/])*\\/\n  // double quotes      \"(\\\\\"|[^\\\"])*\"\n  // single quotes      '(\\\\'|[^'])*'\n  // ticks              `(\\\\`|[^`])*`\n  //\n  // We also want to match the non delimiter part of statements\n  // note we only support ; statement delimiters:\n  //\n  // [^;]\n  //\n  const statementRe =\n    /(\\/(\\\\\\/|[^\\/])*\\/|\"(\\\\\"|[^\\\"])*\"|'(\\\\'|[^'])*'|`(\\\\`|[^`])*`|[^;])+/gm\n  const statements = ctx.value.trim().match(statementRe)\n  if (statements) {\n    const lastIdx = statements.length - 1\n    const last = statements[lastIdx].trim()\n    if (!last.startsWith('return')) {\n      statements[lastIdx] = `return (${last});`\n    }\n    userExpression = statements.join(';\\n')\n  }\n\n  // Ignore any escaped values\n  const escaped = new Map<string, string>()\n  const escapeRe = new RegExp(`(?:${DSP})(.*?)(?:${DSS})`, 'gm')\n  for (const match of userExpression.matchAll(escapeRe)) {\n    const k = match[1]\n    const v = new Hash('dsEscaped').with(k).string\n    escaped.set(v, k)\n    userExpression = userExpression.replace(DSP + k + DSS, v)\n  }\n\n  const fnCall = /@(\\w*)\\(/gm\n  const matches = userExpression.matchAll(fnCall)\n  const methodsCalled = new Set<string>()\n  for (const match of matches) {\n    methodsCalled.add(match[1])\n  }\n\n  // Replace any action calls\n  const actionsRe = new RegExp(`@(${Object.keys(actions).join('|')})\\\\(`, 'gm')\n\n  // Add ctx to action calls\n  userExpression = userExpression.replaceAll(\n    actionsRe,\n    'ctx.actions.$1.fn(ctx,',\n  )\n\n  // Replace any signal calls\n  const signalNames = ctx.signals.paths()\n  if (signalNames.length) {\n    // Match any valid `$signalName` followed by a non-word character or end of string\n    const signalsRe = new RegExp(`\\\\$(${signalNames.join('|')})(\\\\W|$)`, 'gm')\n    userExpression = userExpression.replaceAll(\n      signalsRe,\n      `ctx.signals.signal('$1').value$2`,\n    )\n    // Add dependencies for signal value usages\n    const signalValueRe = /ctx.signals.signal\\('(.+?)'\\).value/gm\n    for (const match of userExpression.matchAll(signalValueRe)) {\n      depSignalNames.add(match[1])\n    }\n    // Add dependencies for `signals.JSON()` usage\n    if (userExpression.includes('ctx.signals.JSON()')) {\n      for (const signalName of ctx.signals.paths()) {\n        depSignalNames.add(signalName)\n      }\n    }\n  }\n\n\n  // Add signal dependencies\n  const deps = new Array<Dependency>()\n  for (const signalName of depSignalNames) {\n    const signal = ctx.signals.signal(signalName)\n    if (signal) {\n      deps.push(signal)\n    }\n  }\n\n  // Replace any escaped values\n  for (const [k, v] of escaped) {\n    userExpression = userExpression.replace(k, v)\n  }\n\n  const fnContent = `return (() => {\\n${userExpression}\\n})()` // Wrap in IIFE\n  ctx.fnContent = fnContent\n\n  try {\n    const fn = new Function('ctx', ...argNames, fnContent)\n    return {\n      deps,\n      rxFn: (...args: any[]) => {\n        try {\n          return fn(ctx, ...args)\n        } catch (error: any) {\n          throw runtimeErr('ExecuteExpression', ctx, {\n            error: error.message,\n          })\n        }\n      },\n    }\n  } catch (error: any) {\n    throw runtimeErr('GenerateExpression', ctx, {\n      error: error.message,\n    })\n  }\n}\n", "import { DSP } from '../engine/consts'\n// @ts-ignore\nconst _ = DSP // This is to force the import of DSP first in the compiled code\n\nimport { Computed } from '../plugins/official/core/attributes/computed'\nimport { Signals } from '../plugins/official/core/attributes/signals'\nimport { Star } from '../plugins/official/core/attributes/star'\nimport { apply, load, setAlias } from './engine'\n\nload(Star, Signals, Computed)\n\nexport { apply, load, setAlias }\n", "import { runtimeErr } from '../engine/errors'\nimport type { RuntimeContext } from '../engine/types'\n\n/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\nexport interface EventSourceMessage {\n  /** The event ID to set the EventSource object's last event ID value. */\n  id: string\n  /** A string identifying the type of event described. */\n  event: string\n  /** The event data */\n  data: string\n  /** The reconnection interval (in milliseconds) to wait before retrying the connection */\n  retry?: number\n}\n\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nexport async function getBytes(\n  stream: ReadableStream<Uint8Array>,\n  onChunk: (arr: Uint8Array) => void,\n) {\n  const reader = stream.getReader()\n  let result: ReadableStreamReadResult<Uint8Array>\n  while (!(result = await reader.read()).done) {\n    onChunk(result.value)\n  }\n}\n\nenum ControlChars {\n  NewLine = 10,\n  CarriageReturn = 13,\n  Space = 32,\n  Colon = 58,\n}\n\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nexport function getLines(\n  onLine: (line: Uint8Array, fieldLength: number) => void,\n) {\n  let buffer: Uint8Array | undefined\n  let position: number // current read position\n  let fieldLength: number // length of the `field` portion of the line\n  let discardTrailingNewline = false\n\n  // return a function that can process each incoming byte chunk:\n  return function onChunk(arr: Uint8Array) {\n    if (buffer === undefined) {\n      buffer = arr\n      position = 0\n      fieldLength = -1\n    } else {\n      // we're still parsing the old line. Append the new bytes into buffer:\n      buffer = concat(buffer, arr)\n    }\n\n    const bufLength = buffer.length\n    let lineStart = 0 // index where the current line starts\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === ControlChars.NewLine) {\n          lineStart = ++position // skip to next char\n        }\n\n        discardTrailingNewline = false\n      }\n\n      // start looking forward till the end of line:\n      let lineEnd = -1 // index of the \\r or \\n char\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case ControlChars.Colon:\n            if (fieldLength === -1) {\n              // first colon in line\n              fieldLength = position - lineStart\n            }\n            break\n          // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n          // biome-ignore lint/suspicious/noFallthroughSwitchClause: <explanation>\n          case ControlChars.CarriageReturn:\n            discardTrailingNewline = true\n          case ControlChars.NewLine:\n            lineEnd = position\n            break\n        }\n      }\n\n      if (lineEnd === -1) {\n        // We reached the end of the buffer but the line hasn't ended.\n        // Wait for the next arr and then continue parsing:\n        break\n      }\n\n      // we've reached the line end, send it out:\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength)\n      lineStart = position // we're now on the next line\n      fieldLength = -1\n    }\n\n    if (lineStart === bufLength) {\n      buffer = undefined // we've finished reading it\n    } else if (lineStart !== 0) {\n      // Create a new view into buffer beginning at lineStart so we don't\n      // need to copy over the previous lines when we get the new arr:\n      buffer = buffer.subarray(lineStart)\n      position -= lineStart\n    }\n  }\n}\n\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nexport function getMessages(\n  onId: (id: string) => void,\n  onRetry: (retry: number) => void,\n  onMessage?: (msg: EventSourceMessage) => void,\n) {\n  let message = newMessage()\n  const decoder = new TextDecoder()\n\n  // return a function that can process each incoming line buffer:\n  return function onLine(line: Uint8Array, fieldLength: number) {\n    if (line.length === 0) {\n      // empty line denotes end of message. Trigger the callback and start a new message:\n      onMessage?.(message)\n      message = newMessage()\n    } else if (fieldLength > 0) {\n      // exclude comments and lines with no values\n      // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n      // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n      const field = decoder.decode(line.subarray(0, fieldLength))\n      const valueOffset =\n        fieldLength + (line[fieldLength + 1] === ControlChars.Space ? 2 : 1)\n      const value = decoder.decode(line.subarray(valueOffset))\n\n      switch (field) {\n        case 'data':\n          // if this message already has data, append the new value to the old.\n          // otherwise, just set to the new value:\n          message.data = message.data ? `${message.data}\\n${value}` : value // otherwise,\n          break\n        case 'event':\n          message.event = value\n          break\n        case 'id':\n          onId((message.id = value))\n          break\n        case 'retry': {\n          const retry = Number.parseInt(value, 10)\n          if (!Number.isNaN(retry)) {\n            // per spec, ignore non-integers\n            onRetry((message.retry = retry))\n          }\n          break\n        }\n      }\n    }\n  }\n}\n\nfunction concat(a: Uint8Array, b: Uint8Array) {\n  const res = new Uint8Array(a.length + b.length)\n  res.set(a)\n  res.set(b, a.length)\n  return res\n}\n\nfunction newMessage(): EventSourceMessage {\n  // data, event, and id must be initialized to empty strings:\n  // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n  // retry should be initialized to undefined so we return a consistent shape\n  // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n  return {\n    data: '',\n    event: '',\n    id: '',\n    retry: undefined,\n  }\n}\n\nexport const EventStreamContentType = 'text/event-stream'\n\nconst LastEventId = 'last-event-id'\n\nexport interface FetchEventSourceInit extends RequestInit {\n  /**\n   * The request headers. FetchEventSource only supports the Record<string,string> format.\n   */\n  headers?: Record<string, string>\n\n  /**\n   * Called when a response is received. Use this to validate that the response\n   * actually matches what you expect (and throw if it doesn't.) If not provided,\n   * will default to a basic validation to ensure the content-type is text/event-stream.\n   */\n  onopen?: (response: Response) => Promise<void>\n\n  /**\n   * Called when a message is received. NOTE: Unlike the default browser\n   * EventSource.onmessage, this callback is called for _all_ events,\n   * even ones with a custom `event` field.\n   */\n  onmessage?: (ev: EventSourceMessage) => void\n\n  /**\n   * Called when a response finishes. If you don't expect the server to kill\n   * the connection, you can throw an exception here and retry using onerror.\n   */\n  onclose?: () => void\n\n  /**\n   * Called when there is any error making the request / processing messages /\n   * handling callbacks etc. Use this to control the retry strategy: if the\n   * error is fatal, rethrow the error inside the callback to stop the entire\n   * operation. Otherwise, you can return an interval (in milliseconds) after\n   * which the request will automatically retry (with the last-event-id).\n   * If this callback is not specified, or it returns undefined, fetchEventSource\n   * will treat every error as retriable and will try again after 1 second.\n   */\n  onerror?: (err: any) => number | null | undefined | void\n\n  /**\n   * If true, will keep the request open even if the document is hidden.\n   * By default, fetchEventSource will close the request and reopen it\n   * automatically when the document becomes visible again.\n   */\n  openWhenHidden?: boolean\n\n  /** The Fetch function to use. Defaults to window.fetch */\n  fetch?: typeof fetch\n\n  /** The retry interval in milliseconds. Defaults to 1_000 */\n  retryInterval?: number\n\n  /** The scaler for the retry interval. Defaults to 2 */\n  retryScaler?: number\n\n  /** The maximum retry interval in milliseconds. Defaults to 30_000 */\n  retryMaxWaitMs?: number\n\n  /** The maximum number of retries before giving up. Defaults to 10 */\n  retryMaxCount?: number\n}\n\nexport function fetchEventSource(\n  input: RequestInfo,\n  {\n    signal: inputSignal,\n    headers: inputHeaders,\n    onopen: inputOnOpen,\n    onmessage,\n    onclose,\n    onerror,\n    openWhenHidden,\n    fetch: inputFetch,\n    retryInterval = 1_000,\n    retryScaler = 2,\n    retryMaxWaitMs = 30_000,\n    retryMaxCount = 10,\n    ...rest\n  }: FetchEventSourceInit,\n) {\n  return new Promise<void>((resolve, reject) => {\n    let retries = 0\n\n    // make a copy of the input headers since we may modify it below:\n    const headers = { ...inputHeaders }\n    if (!headers.accept) {\n      headers.accept = EventStreamContentType\n    }\n\n    let curRequestController: AbortController\n    function onVisibilityChange() {\n      curRequestController.abort() // close existing request on every visibility change\n      if (!document.hidden) {\n        create() // page is now visible again, recreate request.\n      }\n    }\n\n    if (!openWhenHidden) {\n      document.addEventListener('visibilitychange', onVisibilityChange)\n    }\n\n    let retryTimer = 0\n    function dispose() {\n      document.removeEventListener('visibilitychange', onVisibilityChange)\n      window.clearTimeout(retryTimer)\n      curRequestController.abort()\n    }\n\n    // if the incoming signal aborts, dispose resources and resolve:\n    inputSignal?.addEventListener('abort', () => {\n      dispose()\n      resolve() // don't waste time constructing/logging errors\n    })\n\n    const fetch = inputFetch ?? window.fetch\n    const onopen = inputOnOpen ?? function defaultOnOpen() {}\n\n    async function create() {\n      curRequestController = new AbortController()\n      try {\n        const response = await fetch(input, {\n          ...rest,\n          headers,\n          signal: curRequestController.signal,\n        })\n\n        await onopen(response)\n\n        await getBytes(\n          response.body!,\n          getLines(\n            getMessages(\n              (id) => {\n                if (id) {\n                  // signals the id and send it back on the next retry:\n                  headers[LastEventId] = id\n                } else {\n                  // don't send the last-event-id header anymore:\n                  delete headers[LastEventId]\n                }\n              },\n              (retry) => {\n                retryInterval = retry\n              },\n              onmessage,\n            ),\n          ),\n        )\n\n        onclose?.()\n        dispose()\n        resolve()\n      } catch (err) {\n        if (!curRequestController.signal.aborted) {\n          // if we haven't aborted the request ourselves:\n          try {\n            // check if we need to retry:\n            const interval: any = onerror?.(err) ?? retryInterval\n            window.clearTimeout(retryTimer)\n            retryTimer = window.setTimeout(create, interval)\n            retryInterval *= retryScaler // exponential backoff\n            retryInterval = Math.min(retryInterval, retryMaxWaitMs)\n            retries++\n            if (retries > retryMaxCount) {\n              // we should not retry anymore:\n              dispose()\n              // Max retries reached, check your server or network connection\n              reject('Max retries reached.')\n            } else {\n              console.error(\n                `Datastar failed to reach ${input.toString()} retrying in ${interval}ms.`,\n              )\n            }\n          } catch (innerErr) {\n            // we should not retry anymore:\n            dispose()\n            reject(innerErr)\n          }\n        }\n      }\n    }\n\n    create()\n  })\n}\n", "import { DATASTAR } from '../../../engine/consts'\n\nexport const DATASTAR_SSE_EVENT = `${DATASTAR}-sse`\nexport const STARTED = 'started'\nexport const FINISHED = 'finished'\nexport const ERROR = 'error'\nexport const RETRYING = 'retrying'\n\nexport interface DatastarSSEEvent {\n  type: string\n  argsRaw: Record<string, string>\n}\n\nexport interface CustomEventMap {\n  [DATASTAR_SSE_EVENT]: CustomEvent<DatastarSSEEvent>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\n\ndeclare global {\n  interface Document {\n    //adds definition to Document, but you can do the same with HTMLElement\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n  }\n}\n\nexport function datastarSSEEventWatcher(\n  eventType: string,\n  fn: (argsRaw: Record<string, string>) => void,\n) {\n  document.addEventListener(\n    DATASTAR_SSE_EVENT,\n    (event: CustomEvent<DatastarSSEEvent>) => {\n      if (event.detail.type !== eventType) return\n      const { argsRaw } = event.detail\n      fn(argsRaw)\n    },\n  )\n}\n", "// Icon: ic:baseline-get-app\n// Slug: Use a GET request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { DATASTAR, DATASTAR_REQUEST, DefaultSseRetryDurationMs } from '../../../../engine/consts'\nimport { runtimeErr } from '../../../../engine/errors'\nimport type { HTMLorSVGElement, RuntimeContext } from '../../../../engine/types'\nimport {\n  type FetchEventSourceInit,\n  fetchEventSource,\n} from '../../../../vendored/fetch-event-source'\nimport {\n  DATASTAR_SSE_EVENT,\n  type DatastarSSEEvent,\n  ERROR,\n  FINISHED,\n  RETRYING,\n  STARTED,\n} from '../shared'\n\nfunction dispatchSSE(el: HTMLorSVGElement, type: string, argsRaw: Record<string, string>) {\n  el.dispatchEvent(\n    new CustomEvent<DatastarSSEEvent>(DATASTAR_SSE_EVENT, {\n      detail: { type, argsRaw },\n      bubbles: true,\n    }),\n  )\n}\n\nconst isWrongContent = (err: any) => `${err}`.includes('text/event-stream')\n\nexport type SSEArgs = {\n  headers?: Record<string, string>\n  openWhenHidden?: boolean\n  retryInterval?: number\n  retryScaler?: number\n  retryMaxWaitMs?: number\n  retryMaxCount?: number\n  abort?: AbortSignal\n} & (\n  | {\n      contentType: 'json'\n      includeLocal?: boolean\n    }\n  | {\n      contentType: 'form'\n      selector?: string\n    }\n)\n\nexport const sse = async (\n  ctx: RuntimeContext,\n  method: string,\n  url: string,\n  args: SSEArgs,\n) => {\n  const {\n    el: { id: elId },\n    el,\n    signals,\n  } = ctx\n  const {\n    headers: userHeaders,\n    contentType,\n    includeLocal,\n    selector,\n    openWhenHidden,\n    retryInterval,\n    retryScaler,\n    retryMaxWaitMs,\n    retryMaxCount,\n    abort,\n  } = Object.assign(\n    {\n      headers: {},\n      contentType: 'json',\n      includeLocal: false,\n      selector: null,\n      openWhenHidden: false, // will keep the request open even if the document is hidden.\n      retryInterval: DefaultSseRetryDurationMs, // the retry interval in milliseconds\n      retryScaler: 2, // the amount to multiply the retry interval by each time\n      retryMaxWaitMs: 30_000, // the maximum retry interval in milliseconds\n      retryMaxCount: 10, // the maximum number of retries before giving up\n      abort: undefined,\n    },\n    args,\n  )\n  const action = method.toLowerCase()\n  let cleanupFn = (): void => {}\n  try {\n    dispatchSSE(el, STARTED, { elId })\n    if (!url?.length) {\n      throw runtimeErr('SseNoUrlProvided', ctx, { action })\n    }\n\n    const initialHeaders: Record<string, any> = {}\n    initialHeaders[DATASTAR_REQUEST] = true\n    // We ignore the content-type header if using form data\n    // if missing the boundary will be set automatically\n    if (contentType === 'json') {\n      initialHeaders['Content-Type'] = 'application/json'\n    }\n    const headers = Object.assign({}, initialHeaders, userHeaders)\n\n    const req: FetchEventSourceInit = {\n      method,\n      headers,\n      openWhenHidden,\n      retryInterval,\n      retryScaler,\n      retryMaxWaitMs,\n      retryMaxCount,\n      signal: abort,\n      onopen: async (response: Response) => {\n        if (response.status >= 400) {\n          const status = response.status.toString()\n          dispatchSSE(el, ERROR, { status })\n        }\n      },\n      onmessage: (evt) => {\n        if (!evt.event.startsWith(DATASTAR)) {\n          return\n        }\n        const type = evt.event\n        const argsRawLines: Record<string, string[]> = {}\n\n        const lines = evt.data.split('\\n')\n        for (const line of lines) {\n          const colonIndex = line.indexOf(' ')\n          const key = line.slice(0, colonIndex)\n          let argLines = argsRawLines[key]\n          if (!argLines) {\n            argLines = []\n            argsRawLines[key] = argLines\n          }\n          const value = line.slice(colonIndex + 1)\n          argLines.push(value)\n        }\n\n        const argsRaw: Record<string, string> = {}\n        for (const [key, lines] of Object.entries(argsRawLines)) {\n          argsRaw[key] = lines.join('\\n')\n        }\n\n        // if you aren't seeing your event you can debug by using this line in the console\n        dispatchSSE(el, type, argsRaw)\n      },\n      onerror: (error) => {\n        if (isWrongContent(error)) {\n          // don't retry if the content-type is wrong\n          throw runtimeErr('InvalidContentType', ctx, { url })\n        }\n        // do nothing and it will retry\n        if (error) {\n          console.error(error.message)\n          dispatchSSE(el, RETRYING, { message: error.message })\n        }\n      },\n    }\n\n    const urlInstance = new URL(url, window.location.origin)\n    const queryParams = new URLSearchParams(urlInstance.search)\n\n    if (contentType === 'json') {\n      const json = signals.JSON(false, !includeLocal)\n      if (method === 'GET') {\n        queryParams.set(DATASTAR, json)\n      } else {\n        req.body = json\n      }\n    } else if (contentType === 'form') {\n      const formEl = selector\n        ? document.querySelector(selector)\n        : el.closest('form')\n      if (formEl === null) {\n        if (selector) {\n          throw runtimeErr('SseFormNotFound', ctx, { action, selector })\n        }\n        throw runtimeErr('SseClosestFormNotFound', ctx, { action })\n      }\n      if (el !== formEl) {\n        const preventDefault = (evt: Event) => evt.preventDefault()\n        formEl.addEventListener('submit', preventDefault)\n        cleanupFn = (): void =>\n          formEl.removeEventListener('submit', preventDefault)\n      }\n      if (!formEl.checkValidity()) {\n        formEl.reportValidity()\n        cleanupFn()\n        return\n      }\n      const formData = new FormData(formEl)\n      if (method === 'GET') {\n        const formParams = new URLSearchParams(formData as any)\n        for (const [key, value] of formParams) {\n          queryParams.set(key, value)\n        }\n      } else {\n        req.body = formData\n      }\n    } else {\n      throw runtimeErr('SseInvalidContentType', ctx, { action, contentType })\n    }\n\n    urlInstance.search = queryParams.toString()\n\n    try {\n      await fetchEventSource(urlInstance.toString(), req)\n    } catch (error) {\n      if (!isWrongContent(error)) {\n        throw runtimeErr('SseFetchFailed', ctx, { method, url, error })\n      }\n      // exit gracefully and do nothing if the content-type is wrong\n      // this can happen if the client is sending a request\n      // where no response is expected, and they haven't\n      // set the content-type to text/event-stream\n    }\n  } finally {\n    dispatchSSE(el, FINISHED, { elId })\n    cleanupFn()\n  }\n}\n", "// Icon: material-symbols:delete-outline\n// Slug: Use a DELETE request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  type ActionPlugin,\n  PluginType,\n  type RuntimeContext,\n} from '../../../../engine/types'\nimport { type SSEArgs, sse } from './sse'\n\nexport const DELETE: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'delete',\n  fn: async (ctx: RuntimeContext, url: string, args: SSEArgs) => {\n    return sse(ctx, 'DELETE', url, { ...args })\n  },\n}\n", "// Icon: ic:baseline-get-app\n// Slug: Use a GET request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  type ActionPlugin,\n  PluginType,\n  type RuntimeContext,\n} from '../../../../engine/types'\nimport { type SSEArgs, sse } from './sse'\n\nexport const GET: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'get',\n  fn: async (ctx: RuntimeContext, url: string, args: SSEArgs) => {\n    return sse(ctx, 'GET', url, { ...args })\n  },\n}\n", "// Icon: fluent:patch-24-filled\n// Slug: Use a PATCH request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  type ActionPlugin,\n  PluginType,\n  type RuntimeContext,\n} from '../../../../engine/types'\nimport { type SSEArgs, sse } from './sse'\n\nexport const PATCH: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'patch',\n  fn: async (ctx: RuntimeContext, url: string, args: SSEArgs) => {\n    return sse(ctx, 'PATCH', url, { ...args })\n  },\n}\n", "// Icon: ri:signpost-fill\n// Slug: Use a POST request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  type ActionPlugin,\n  PluginType,\n  type RuntimeContext,\n} from '../../../../engine/types'\nimport { type SSEArgs, sse } from './sse'\n\nexport const POST: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'post',\n  fn: async (ctx: RuntimeContext, url: string, args: SSEArgs) => {\n    return sse(ctx, 'POST', url, { ...args })\n  },\n}\n", "// Icon: material-symbols:arrows-input\n// Slug: Use a PUT request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  type ActionPlugin,\n  PluginType,\n  type RuntimeContext,\n} from '../../../../engine/types'\nimport { type SSEArgs, sse } from './sse'\n\nexport const PUT: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'put',\n  fn: async (ctx: RuntimeContext, url: string, args: SSEArgs) => {\n    return sse(ctx, 'PUT', url, { ...args })\n  },\n}\n", "// Icon: material-symbols:network-wifi\n// Slug: Sets the indicator signal used when fetching data via SSE\n// Description: must be a valid signal name\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { modifyCasing, trimDollarSignPrefix } from '../../../../utils/text'\nimport {\n  DATASTAR_SSE_EVENT,\n  type DatastarSSEEvent,\n  FINISHED,\n  STARTED,\n} from '../shared'\n\nexport const Indicator: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'indicator',\n  keyReq: Requirement.Exclusive,\n  valReq: Requirement.Exclusive,\n  onLoad: ({ el, key, mods, signals, value }) => {\n    const signalName = key ? modifyCasing(key, mods) : trimDollarSignPrefix(value)\n    const { signal } = signals.upsertIfMissing(signalName, false)\n    const watcher = (event: CustomEvent<DatastarSSEEvent>) => {\n      const {\n        type,\n        argsRaw: { elId },\n      } = event.detail\n      if (elId !== el.id) return\n      switch (type) {\n        case STARTED:\n          signal.value = true\n          break\n        case FINISHED:\n          signal.value = false\n          break\n      }\n    }\n    document.addEventListener(DATASTAR_SSE_EVENT, watcher)\n\n    return () => {\n      // Reset the signal\n      signal.value = false\n      \n      document.removeEventListener(DATASTAR_SSE_EVENT, watcher)\n    }\n  },\n}\n", "// Icon: tabler:file-type-js\n// Slug: Execute JavaScript using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DefaultExecuteScriptAttributes,\n  DefaultExecuteScriptAutoRemove,\n  EventTypes,\n} from '../../../../engine/consts'\nimport { initErr } from '../../../../engine/errors'\nimport { PluginType, type WatcherPlugin } from '../../../../engine/types'\nimport { isBoolString } from '../../../../utils/text'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const ExecuteScript: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypes.ExecuteScript,\n  onGlobalInit: async (ctx) => {\n    datastarSSEEventWatcher(\n      EventTypes.ExecuteScript,\n      ({\n        autoRemove: autoRemoveRaw = `${DefaultExecuteScriptAutoRemove}`,\n        attributes: attributesRaw = DefaultExecuteScriptAttributes,\n        script,\n      }) => {\n        const autoRemove = isBoolString(autoRemoveRaw)\n        if (!script?.length) {\n          throw initErr('NoScriptProvided', ctx)\n        }\n        const scriptEl = document.createElement('script')\n        for (const attr of attributesRaw.split('\\n')) {\n          const pivot = attr.indexOf(' ')\n          const key = pivot ? attr.slice(0, pivot) : attr\n          const value = pivot ? attr.slice(pivot) : ''\n          scriptEl.setAttribute(key.trim(), value.trim())\n        }\n        scriptEl.text = script\n        document.head.appendChild(scriptEl)\n        if (autoRemove) {\n          scriptEl.remove()\n        }\n      },\n    )\n  },\n}\n", "export interface DocumentSupportingViewTransitionAPI {\n  startViewTransition(\n    updateCallback: () => Promise<void> | void,\n  ): IViewTransition\n}\n\nexport interface IViewTransition {\n  finished: Promise<void>\n  ready: Promise<void>\n  updateCallbackDone: Promise<void>\n  skipTransition(): void\n}\n\nexport const docWithViewTransitionAPI =\n  document as unknown as DocumentSupportingViewTransitionAPI\nexport const supportsViewTransitions =\n  !!docWithViewTransitionAPI.startViewTransition\n", "/**\n * @typedef {object} ConfigHead\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} [style]\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {function(Element): boolean} [shouldPreserve]\n * @property {function(Element): boolean} [shouldReAppend]\n * @property {function(Element): boolean} [shouldRemove]\n * @property {function(Element, {added: Node[], kept: Element[], removed: Element[]}): void} [afterHeadMorphed]\n */\n\n/**\n * @typedef {object} ConfigCallbacks\n *\n * @property {function(Node): boolean} [beforeNodeAdded]\n * @property {function(Node): void} [afterNodeAdded]\n * @property {function(Element, Node): boolean} [beforeNodeMorphed]\n * @property {function(Element, Node): void} [afterNodeMorphed]\n * @property {function(Element): boolean} [beforeNodeRemoved]\n * @property {function(Element): void} [afterNodeRemoved]\n * @property {function(string, Element, \"update\" | \"remove\"): boolean} [beforeAttributeUpdated]\n */\n\n/**\n * @typedef {object} Config\n *\n * @property {'outerHTML' | 'innerHTML'} [morphStyle]\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {boolean} [restoreFocus]\n * @property {ConfigCallbacks} [callbacks]\n * @property {ConfigHead} [head]\n */\n\n/**\n * @typedef {function} NoOp\n *\n * @returns {void}\n */\n\n/**\n * @typedef {object} ConfigHeadInternal\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} style\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {(function(Element): boolean) | NoOp} shouldPreserve\n * @property {(function(Element): boolean) | NoOp} shouldReAppend\n * @property {(function(Element): boolean) | NoOp} shouldRemove\n * @property {(function(Element, {added: Node[], kept: Element[], removed: Element[]}): void) | NoOp} afterHeadMorphed\n */\n\n/**\n * @typedef {object} ConfigCallbacksInternal\n *\n * @property {(function(Node): boolean) | NoOp} beforeNodeAdded\n * @property {(function(Node): void) | NoOp} afterNodeAdded\n * @property {(function(Node, Node): boolean) | NoOp} beforeNodeMorphed\n * @property {(function(Node, Node): void) | NoOp} afterNodeMorphed\n * @property {(function(Node): boolean) | NoOp} beforeNodeRemoved\n * @property {(function(Node): void) | NoOp} afterNodeRemoved\n * @property {(function(string, Element, \"update\" | \"remove\"): boolean) | NoOp} beforeAttributeUpdated\n */\n\n/**\n * @typedef {object} ConfigInternal\n *\n * @property {'outerHTML' | 'innerHTML'} morphStyle\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {boolean} [restoreFocus]\n * @property {ConfigCallbacksInternal} callbacks\n * @property {ConfigHeadInternal} head\n */\n\n/**\n * @typedef {Object} IdSets\n * @property {Set<string>} persistentIds\n * @property {Map<Node, Set<string>>} idMap\n */\n\n/**\n * @typedef {Function} Morph\n *\n * @param {Element | Document} oldNode\n * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n * @param {Config} [config]\n * @returns {undefined | Node[]}\n */\n\n// base IIFE to define idiomorph\n/**\n *\n * @type {{defaults: ConfigInternal, morph: Morph}}\n */\nvar Idiomorph = (function () {\n  \"use strict\";\n\n  /**\n   * @typedef {object} MorphContext\n   *\n   * @property {Element} target\n   * @property {Element} newContent\n   * @property {ConfigInternal} config\n   * @property {ConfigInternal['morphStyle']} morphStyle\n   * @property {ConfigInternal['ignoreActive']} ignoreActive\n   * @property {ConfigInternal['ignoreActiveValue']} ignoreActiveValue\n   * @property {ConfigInternal['restoreFocus']} restoreFocus\n   * @property {Map<Node, Set<string>>} idMap\n   * @property {Set<string>} persistentIds\n   * @property {ConfigInternal['callbacks']} callbacks\n   * @property {ConfigInternal['head']} head\n   * @property {HTMLDivElement} pantry\n   */\n\n  //=============================================================================\n  // AND NOW IT BEGINS...\n  //=============================================================================\n\n  const noOp = () => {};\n  /**\n   * Default configuration values, updatable by users now\n   * @type {ConfigInternal}\n   */\n  const defaults = {\n    morphStyle: \"outerHTML\",\n    callbacks: {\n      beforeNodeAdded: noOp,\n      afterNodeAdded: noOp,\n      beforeNodeMorphed: noOp,\n      afterNodeMorphed: noOp,\n      beforeNodeRemoved: noOp,\n      afterNodeRemoved: noOp,\n      beforeAttributeUpdated: noOp,\n    },\n    head: {\n      style: \"merge\",\n      shouldPreserve: (elt) => elt.getAttribute(\"im-preserve\") === \"true\",\n      shouldReAppend: (elt) => elt.getAttribute(\"im-re-append\") === \"true\",\n      shouldRemove: noOp,\n      afterHeadMorphed: noOp,\n    },\n    restoreFocus: true,\n  };\n\n  /**\n   * Core idiomorph function for morphing one DOM tree to another\n   *\n   * @param {Element | Document} oldNode\n   * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n   * @param {Config} [config]\n   * @returns {Promise<Node[]> | Node[]}\n   */\n  function morph(oldNode, newContent, config = {}) {\n    oldNode = normalizeElement(oldNode);\n    const newNode = normalizeParent(newContent);\n    const ctx = createMorphContext(oldNode, newNode, config);\n\n    const morphedNodes = saveAndRestoreFocus(ctx, () => {\n      return withHeadBlocking(\n        ctx,\n        oldNode,\n        newNode,\n        /** @param {MorphContext} ctx */ (ctx) => {\n          if (ctx.morphStyle === \"innerHTML\") {\n            morphChildren(ctx, oldNode, newNode);\n            return Array.from(oldNode.childNodes);\n          } else {\n            return morphOuterHTML(ctx, oldNode, newNode);\n          }\n        },\n      );\n    });\n\n    ctx.pantry.remove();\n    return morphedNodes;\n  }\n\n  /**\n   * Morph just the outerHTML of the oldNode to the newContent\n   * We have to be careful because the oldNode could have siblings which need to be untouched\n   * @param {MorphContext} ctx\n   * @param {Element} oldNode\n   * @param {Element} newNode\n   * @returns {Node[]}\n   */\n  function morphOuterHTML(ctx, oldNode, newNode) {\n    const oldParent = normalizeParent(oldNode);\n    morphChildren(\n      ctx,\n      oldParent,\n      newNode,\n      // these two optional params are the secret sauce\n      oldNode, // start point for iteration\n      oldNode.nextSibling, // end point for iteration\n    );\n    // this is safe even with siblings, because normalizeParent returns a SlicedParentNode if needed.\n    return Array.from(oldParent.childNodes);\n  }\n\n  /**\n   * @param {MorphContext} ctx\n   * @param {Function} fn\n   * @returns {Promise<Node[]> | Node[]}\n   */\n  function saveAndRestoreFocus(ctx, fn) {\n    if (!ctx.config.restoreFocus) return fn();\n    let activeElement =\n      /** @type {HTMLInputElement|HTMLTextAreaElement|null} */ (\n        document.activeElement\n      );\n\n    // don't bother if the active element is not an input or textarea\n    if (\n      !(\n        activeElement instanceof HTMLInputElement ||\n        activeElement instanceof HTMLTextAreaElement\n      )\n    ) {\n      return fn();\n    }\n\n    const { id: activeElementId, selectionStart, selectionEnd } = activeElement;\n\n    const results = fn();\n\n    if (activeElementId && activeElementId !== document.activeElement?.id) {\n      activeElement = ctx.target.querySelector(`[id=\"${activeElementId}\"]`);\n      activeElement?.focus();\n    }\n    if (activeElement && !activeElement.selectionEnd && selectionEnd) {\n      activeElement.setSelectionRange(selectionStart, selectionEnd);\n    }\n\n    return results;\n  }\n\n  const morphChildren = (function () {\n    /**\n     * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n     * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n     * by using id sets, we are able to better match up with content deeper in the DOM.\n     *\n     * Basic algorithm:\n     * - for each node in the new content:\n     *   - search self and siblings for an id set match, falling back to a soft match\n     *   - if match found\n     *     - remove any nodes up to the match:\n     *       - pantry persistent nodes\n     *       - delete the rest\n     *     - morph the match\n     *   - elsif no match found, and node is persistent\n     *     - find its match by querying the old root (future) and pantry (past)\n     *     - move it and its children here\n     *     - morph it\n     *   - else\n     *     - create a new node from scratch as a last result\n     *\n     * @param {MorphContext} ctx the merge context\n     * @param {Element} oldParent the old content that we are merging the new content into\n     * @param {Element} newParent the parent element of the new content\n     * @param {Node|null} [insertionPoint] the point in the DOM we start morphing at (defaults to first child)\n     * @param {Node|null} [endPoint] the point in the DOM we stop morphing at (defaults to after last child)\n     */\n    function morphChildren(\n      ctx,\n      oldParent,\n      newParent,\n      insertionPoint = null,\n      endPoint = null,\n    ) {\n      // normalize\n      if (\n        oldParent instanceof HTMLTemplateElement &&\n        newParent instanceof HTMLTemplateElement\n      ) {\n        // @ts-ignore we can pretend the DocumentFragment is an Element\n        oldParent = oldParent.content;\n        // @ts-ignore ditto\n        newParent = newParent.content;\n      }\n      insertionPoint ||= oldParent.firstChild;\n\n      // run through all the new content\n      for (const newChild of newParent.childNodes) {\n        // once we reach the end of the old parent content skip to the end and insert the rest\n        if (insertionPoint && insertionPoint != endPoint) {\n          const bestMatch = findBestMatch(\n            ctx,\n            newChild,\n            insertionPoint,\n            endPoint,\n          );\n          if (bestMatch) {\n            // if the node to morph is not at the insertion point then remove/move up to it\n            if (bestMatch !== insertionPoint) {\n              removeNodesBetween(ctx, insertionPoint, bestMatch);\n            }\n            morphNode(bestMatch, newChild, ctx);\n            insertionPoint = bestMatch.nextSibling;\n            continue;\n          }\n        }\n\n        // if the matching node is elsewhere in the original content\n        if (newChild instanceof Element && ctx.persistentIds.has(newChild.id)) {\n          // move it and all its children here and morph\n          const movedChild = moveBeforeById(\n            oldParent,\n            newChild.id,\n            insertionPoint,\n            ctx,\n          );\n          morphNode(movedChild, newChild, ctx);\n          insertionPoint = movedChild.nextSibling;\n          continue;\n        }\n\n        // last resort: insert the new node from scratch\n        const insertedNode = createNode(\n          oldParent,\n          newChild,\n          insertionPoint,\n          ctx,\n        );\n        // could be null if beforeNodeAdded prevented insertion\n        if (insertedNode) {\n          insertionPoint = insertedNode.nextSibling;\n        }\n      }\n\n      // remove any remaining old nodes that didn't match up with new content\n      while (insertionPoint && insertionPoint != endPoint) {\n        const tempNode = insertionPoint;\n        insertionPoint = insertionPoint.nextSibling;\n        removeNode(ctx, tempNode);\n      }\n    }\n\n    /**\n     * This performs the action of inserting a new node while handling situations where the node contains\n     * elements with persistent ids and possible state info we can still preserve by moving in and then morphing\n     *\n     * @param {Element} oldParent\n     * @param {Node} newChild\n     * @param {Node|null} insertionPoint\n     * @param {MorphContext} ctx\n     * @returns {Node|null}\n     */\n    function createNode(oldParent, newChild, insertionPoint, ctx) {\n      if (ctx.callbacks.beforeNodeAdded(newChild) === false) return null;\n      if (ctx.idMap.has(newChild)) {\n        // node has children with ids with possible state so create a dummy elt of same type and apply full morph algorithm\n        const newEmptyChild = document.createElement(\n          /** @type {Element} */ (newChild).tagName,\n        );\n        oldParent.insertBefore(newEmptyChild, insertionPoint);\n        morphNode(newEmptyChild, newChild, ctx);\n        ctx.callbacks.afterNodeAdded(newEmptyChild);\n        return newEmptyChild;\n      } else {\n        // optimisation: no id state to preserve so we can just insert a clone of the newChild and its descendants\n        const newClonedChild = document.importNode(newChild, true); // importNode to not mutate newParent\n        oldParent.insertBefore(newClonedChild, insertionPoint);\n        ctx.callbacks.afterNodeAdded(newClonedChild);\n        return newClonedChild;\n      }\n    }\n\n    //=============================================================================\n    // Matching Functions\n    //=============================================================================\n    const findBestMatch = (function () {\n      /**\n       * Scans forward from the startPoint to the endPoint looking for a match\n       * for the node. It looks for an id set match first, then a soft match.\n       * We abort softmatching if we find two future soft matches, to reduce churn.\n       * @param {Node} node\n       * @param {MorphContext} ctx\n       * @param {Node | null} startPoint\n       * @param {Node | null} endPoint\n       * @returns {Node | null}\n       */\n      function findBestMatch(ctx, node, startPoint, endPoint) {\n        let softMatch = null;\n        let nextSibling = node.nextSibling;\n        let siblingSoftMatchCount = 0;\n\n        let cursor = startPoint;\n        while (cursor && cursor != endPoint) {\n          // soft matching is a prerequisite for id set matching\n          if (isSoftMatch(cursor, node)) {\n            if (isIdSetMatch(ctx, cursor, node)) {\n              return cursor; // found an id set match, we're done!\n            }\n\n            // we haven't yet saved a soft match fallback\n            if (softMatch === null) {\n              // the current soft match will hard match something else in the future, leave it\n              if (!ctx.idMap.has(cursor)) {\n                // save this as the fallback if we get through the loop without finding a hard match\n                softMatch = cursor;\n              }\n            }\n          }\n          if (\n            softMatch === null &&\n            nextSibling &&\n            isSoftMatch(cursor, nextSibling)\n          ) {\n            // The next new node has a soft match with this node, so\n            // increment the count of future soft matches\n            siblingSoftMatchCount++;\n            nextSibling = nextSibling.nextSibling;\n\n            // If there are two future soft matches, block soft matching for this node to allow\n            // future siblings to soft match. This is to reduce churn in the DOM when an element\n            // is prepended.\n            if (siblingSoftMatchCount >= 2) {\n              softMatch = undefined;\n            }\n          }\n\n          // if the current node contains active element, stop looking for better future matches,\n          // because if one is found, this node will be moved to the pantry, reparenting it and thus losing focus\n          if (cursor.contains(document.activeElement)) break;\n\n          cursor = cursor.nextSibling;\n        }\n\n        return softMatch || null;\n      }\n\n      /**\n       *\n       * @param {MorphContext} ctx\n       * @param {Node} oldNode\n       * @param {Node} newNode\n       * @returns {boolean}\n       */\n      function isIdSetMatch(ctx, oldNode, newNode) {\n        let oldSet = ctx.idMap.get(oldNode);\n        let newSet = ctx.idMap.get(newNode);\n\n        if (!newSet || !oldSet) return false;\n\n        for (const id of oldSet) {\n          // a potential match is an id in the new and old nodes that\n          // has not already been merged into the DOM\n          // But the newNode content we call this on has not been\n          // merged yet and we don't allow duplicate IDs so it is simple\n          if (newSet.has(id)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      /**\n       *\n       * @param {Node} oldNode\n       * @param {Node} newNode\n       * @returns {boolean}\n       */\n      function isSoftMatch(oldNode, newNode) {\n        // ok to cast: if one is not element, `id` and `tagName` will be undefined and we'll just compare that.\n        const oldElt = /** @type {Element} */ (oldNode);\n        const newElt = /** @type {Element} */ (newNode);\n\n        return (\n          oldElt.nodeType === newElt.nodeType &&\n          oldElt.tagName === newElt.tagName &&\n          // If oldElt has an `id` with possible state and it doesn't match newElt.id then avoid morphing.\n          // We'll still match an anonymous node with an IDed newElt, though, because if it got this far,\n          // its not persistent, and new nodes can't have any hidden state.\n          (!oldElt.id || oldElt.id === newElt.id)\n        );\n      }\n\n      return findBestMatch;\n    })();\n\n    //=============================================================================\n    // DOM Manipulation Functions\n    //=============================================================================\n\n    /**\n     * Gets rid of an unwanted DOM node; strategy depends on nature of its reuse:\n     * - Persistent nodes will be moved to the pantry for later reuse\n     * - Other nodes will have their hooks called, and then are removed\n     * @param {MorphContext} ctx\n     * @param {Node} node\n     */\n    function removeNode(ctx, node) {\n      // are we going to id set match this later?\n      if (ctx.idMap.has(node)) {\n        // skip callbacks and move to pantry\n        moveBefore(ctx.pantry, node, null);\n      } else {\n        // remove for realsies\n        if (ctx.callbacks.beforeNodeRemoved(node) === false) return;\n        node.parentNode?.removeChild(node);\n        ctx.callbacks.afterNodeRemoved(node);\n      }\n    }\n\n    /**\n     * Remove nodes between the start and end nodes\n     * @param {MorphContext} ctx\n     * @param {Node} startInclusive\n     * @param {Node} endExclusive\n     * @returns {Node|null}\n     */\n    function removeNodesBetween(ctx, startInclusive, endExclusive) {\n      /** @type {Node | null} */\n      let cursor = startInclusive;\n      // remove nodes until the endExclusive node\n      while (cursor && cursor !== endExclusive) {\n        let tempNode = /** @type {Node} */ (cursor);\n        cursor = cursor.nextSibling;\n        removeNode(ctx, tempNode);\n      }\n      return cursor;\n    }\n\n    /**\n     * Search for an element by id within the document and pantry, and move it using moveBefore.\n     *\n     * @param {Element} parentNode - The parent node to which the element will be moved.\n     * @param {string} id - The ID of the element to be moved.\n     * @param {Node | null} after - The reference node to insert the element before.\n     *                              If `null`, the element is appended as the last child.\n     * @param {MorphContext} ctx\n     * @returns {Element} The found element\n     */\n    function moveBeforeById(parentNode, id, after, ctx) {\n      const target =\n        /** @type {Element} - will always be found */\n        (\n          (ctx.target.id === id && ctx.target) ||\n            ctx.target.querySelector(`[id=\"${id}\"]`) ||\n            ctx.pantry.querySelector(`[id=\"${id}\"]`)\n        );\n      removeElementFromAncestorsIdMaps(target, ctx);\n      moveBefore(parentNode, target, after);\n      return target;\n    }\n\n    /**\n     * Removes an element from its ancestors' id maps. This is needed when an element is moved from the\n     * \"future\" via `moveBeforeId`. Otherwise, its erstwhile ancestors could be mistakenly moved to the\n     * pantry rather than being deleted, preventing their removal hooks from being called.\n     *\n     * @param {Element} element - element to remove from its ancestors' id maps\n     * @param {MorphContext} ctx\n     */\n    function removeElementFromAncestorsIdMaps(element, ctx) {\n      const id = element.id;\n      /** @ts-ignore - safe to loop in this way **/\n      while ((element = element.parentNode)) {\n        let idSet = ctx.idMap.get(element);\n        if (idSet) {\n          idSet.delete(id);\n          if (!idSet.size) {\n            ctx.idMap.delete(element);\n          }\n        }\n      }\n    }\n\n    /**\n     * Moves an element before another element within the same parent.\n     * Uses the proposed `moveBefore` API if available (and working), otherwise falls back to `insertBefore`.\n     * This is essentialy a forward-compat wrapper.\n     *\n     * @param {Element} parentNode - The parent node containing the after element.\n     * @param {Node} element - The element to be moved.\n     * @param {Node | null} after - The reference node to insert `element` before.\n     *                              If `null`, `element` is appended as the last child.\n     */\n    function moveBefore(parentNode, element, after) {\n      // @ts-ignore - use proposed moveBefore feature\n      if (parentNode.moveBefore) {\n        try {\n          // @ts-ignore - use proposed moveBefore feature\n          parentNode.moveBefore(element, after);\n        } catch (e) {\n          // fall back to insertBefore as some browsers may fail on moveBefore when trying to move Dom disconnected nodes to pantry\n          parentNode.insertBefore(element, after);\n        }\n      } else {\n        parentNode.insertBefore(element, after);\n      }\n    }\n\n    return morphChildren;\n  })();\n\n  //=============================================================================\n  // Single Node Morphing Code\n  //=============================================================================\n  const morphNode = (function () {\n    /**\n     * @param {Node} oldNode root node to merge content into\n     * @param {Node} newContent new content to merge\n     * @param {MorphContext} ctx the merge context\n     * @returns {Node | null} the element that ended up in the DOM\n     */\n    function morphNode(oldNode, newContent, ctx) {\n      if (ctx.ignoreActive && oldNode === document.activeElement) {\n        // don't morph focused element\n        return null;\n      }\n\n      if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) {\n        return oldNode;\n      }\n\n      if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n        // ignore the head element\n      } else if (\n        oldNode instanceof HTMLHeadElement &&\n        ctx.head.style !== \"morph\"\n      ) {\n        // ok to cast: if newContent wasn't also a <head>, it would've got caught in the `!isSoftMatch` branch above\n        handleHeadElement(\n          oldNode,\n          /** @type {HTMLHeadElement} */ (newContent),\n          ctx,\n        );\n      } else {\n        morphAttributes(oldNode, newContent, ctx);\n        if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n          // @ts-ignore newContent can be a node here because .firstChild will be null\n          morphChildren(ctx, oldNode, newContent);\n        }\n      }\n      ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n      return oldNode;\n    }\n\n    /**\n     * syncs the oldNode to the newNode, copying over all attributes and\n     * inner element state from the newNode to the oldNode\n     *\n     * @param {Node} oldNode the node to copy attributes & state to\n     * @param {Node} newNode the node to copy attributes & state from\n     * @param {MorphContext} ctx the merge context\n     */\n    function morphAttributes(oldNode, newNode, ctx) {\n      let type = newNode.nodeType;\n\n      // if is an element type, sync the attributes from the\n      // new node into the new node\n      if (type === 1 /* element type */) {\n        const oldElt = /** @type {Element} */ (oldNode);\n        const newElt = /** @type {Element} */ (newNode);\n\n        const oldAttributes = oldElt.attributes;\n        const newAttributes = newElt.attributes;\n        for (const newAttribute of newAttributes) {\n          if (ignoreAttribute(newAttribute.name, oldElt, \"update\", ctx)) {\n            continue;\n          }\n          if (oldElt.getAttribute(newAttribute.name) !== newAttribute.value) {\n            oldElt.setAttribute(newAttribute.name, newAttribute.value);\n          }\n        }\n        // iterate backwards to avoid skipping over items when a delete occurs\n        for (let i = oldAttributes.length - 1; 0 <= i; i--) {\n          const oldAttribute = oldAttributes[i];\n\n          // toAttributes is a live NamedNodeMap, so iteration+mutation is unsafe\n          // e.g. custom element attribute callbacks can remove other attributes\n          if (!oldAttribute) continue;\n\n          if (!newElt.hasAttribute(oldAttribute.name)) {\n            if (ignoreAttribute(oldAttribute.name, oldElt, \"remove\", ctx)) {\n              continue;\n            }\n            oldElt.removeAttribute(oldAttribute.name);\n          }\n        }\n\n        if (!ignoreValueOfActiveElement(oldElt, ctx)) {\n          syncInputValue(oldElt, newElt, ctx);\n        }\n      }\n\n      // sync text nodes\n      if (type === 8 /* comment */ || type === 3 /* text */) {\n        if (oldNode.nodeValue !== newNode.nodeValue) {\n          oldNode.nodeValue = newNode.nodeValue;\n        }\n      }\n    }\n\n    /**\n     * NB: many bothans died to bring us information:\n     *\n     *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n     *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n     *\n     * @param {Element} oldElement the element to sync the input value to\n     * @param {Element} newElement the element to sync the input value from\n     * @param {MorphContext} ctx the merge context\n     */\n    function syncInputValue(oldElement, newElement, ctx) {\n      if (\n        oldElement instanceof HTMLInputElement &&\n        newElement instanceof HTMLInputElement &&\n        newElement.type !== \"file\"\n      ) {\n        let newValue = newElement.value;\n        let oldValue = oldElement.value;\n\n        // sync boolean attributes\n        syncBooleanAttribute(oldElement, newElement, \"checked\", ctx);\n        syncBooleanAttribute(oldElement, newElement, \"disabled\", ctx);\n\n        if (!newElement.hasAttribute(\"value\")) {\n          if (!ignoreAttribute(\"value\", oldElement, \"remove\", ctx)) {\n            oldElement.value = \"\";\n            oldElement.removeAttribute(\"value\");\n          }\n        } else if (oldValue !== newValue) {\n          if (!ignoreAttribute(\"value\", oldElement, \"update\", ctx)) {\n            oldElement.setAttribute(\"value\", newValue);\n            oldElement.value = newValue;\n          }\n        }\n        // TODO: QUESTION(1cg): this used to only check `newElement` unlike the other branches -- why?\n        // did I break something?\n      } else if (\n        oldElement instanceof HTMLOptionElement &&\n        newElement instanceof HTMLOptionElement\n      ) {\n        syncBooleanAttribute(oldElement, newElement, \"selected\", ctx);\n      } else if (\n        oldElement instanceof HTMLTextAreaElement &&\n        newElement instanceof HTMLTextAreaElement\n      ) {\n        let newValue = newElement.value;\n        let oldValue = oldElement.value;\n        if (ignoreAttribute(\"value\", oldElement, \"update\", ctx)) {\n          return;\n        }\n        if (newValue !== oldValue) {\n          oldElement.value = newValue;\n        }\n        if (\n          oldElement.firstChild &&\n          oldElement.firstChild.nodeValue !== newValue\n        ) {\n          oldElement.firstChild.nodeValue = newValue;\n        }\n      }\n    }\n\n    /**\n     * @param {Element} oldElement element to write the value to\n     * @param {Element} newElement element to read the value from\n     * @param {string} attributeName the attribute name\n     * @param {MorphContext} ctx the merge context\n     */\n    function syncBooleanAttribute(oldElement, newElement, attributeName, ctx) {\n      // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n      const newLiveValue = newElement[attributeName],\n        // @ts-ignore ditto\n        oldLiveValue = oldElement[attributeName];\n      if (newLiveValue !== oldLiveValue) {\n        const ignoreUpdate = ignoreAttribute(\n          attributeName,\n          oldElement,\n          \"update\",\n          ctx,\n        );\n        if (!ignoreUpdate) {\n          // update attribute's associated DOM property\n          // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n          oldElement[attributeName] = newElement[attributeName];\n        }\n        if (newLiveValue) {\n          if (!ignoreUpdate) {\n            // https://developer.mozilla.org/en-US/docs/Glossary/Boolean/HTML\n            // this is the correct way to set a boolean attribute to \"true\"\n            oldElement.setAttribute(attributeName, \"\");\n          }\n        } else {\n          if (!ignoreAttribute(attributeName, oldElement, \"remove\", ctx)) {\n            oldElement.removeAttribute(attributeName);\n          }\n        }\n      }\n    }\n\n    /**\n     * @param {string} attr the attribute to be mutated\n     * @param {Element} element the element that is going to be updated\n     * @param {\"update\" | \"remove\"} updateType\n     * @param {MorphContext} ctx the merge context\n     * @returns {boolean} true if the attribute should be ignored, false otherwise\n     */\n    function ignoreAttribute(attr, element, updateType, ctx) {\n      if (\n        attr === \"value\" &&\n        ctx.ignoreActiveValue &&\n        element === document.activeElement\n      ) {\n        return true;\n      }\n      return (\n        ctx.callbacks.beforeAttributeUpdated(attr, element, updateType) ===\n        false\n      );\n    }\n\n    /**\n     * @param {Node} possibleActiveElement\n     * @param {MorphContext} ctx\n     * @returns {boolean}\n     */\n    function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n      return (\n        !!ctx.ignoreActiveValue &&\n        possibleActiveElement === document.activeElement &&\n        possibleActiveElement !== document.body\n      );\n    }\n\n    return morphNode;\n  })();\n\n  //=============================================================================\n  // Head Management Functions\n  //=============================================================================\n  /**\n   * @param {MorphContext} ctx\n   * @param {Element} oldNode\n   * @param {Element} newNode\n   * @param {function} callback\n   * @returns {Node[] | Promise<Node[]>}\n   */\n  function withHeadBlocking(ctx, oldNode, newNode, callback) {\n    if (ctx.head.block) {\n      const oldHead = oldNode.querySelector(\"head\");\n      const newHead = newNode.querySelector(\"head\");\n      if (oldHead && newHead) {\n        const promises = handleHeadElement(oldHead, newHead, ctx);\n        // when head promises resolve, proceed ignoring the head tag\n        return Promise.all(promises).then(() => {\n          const newCtx = Object.assign(ctx, {\n            head: {\n              block: false,\n              ignore: true,\n            },\n          });\n          return callback(newCtx);\n        });\n      }\n    }\n    // just proceed if we not head blocking\n    return callback(ctx);\n  }\n\n  /**\n   *  The HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n   *\n   * @param {Element} oldHead\n   * @param {Element} newHead\n   * @param {MorphContext} ctx\n   * @returns {Promise<void>[]}\n   */\n  function handleHeadElement(oldHead, newHead, ctx) {\n    let added = [];\n    let removed = [];\n    let preserved = [];\n    let nodesToAppend = [];\n\n    // put all new head elements into a Map, by their outerHTML\n    let srcToNewHeadNodes = new Map();\n    for (const newHeadChild of newHead.children) {\n      srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n    }\n\n    // for each elt in the current head\n    for (const currentHeadElt of oldHead.children) {\n      // If the current head element is in the map\n      let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n      let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n      let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n      if (inNewContent || isPreserved) {\n        if (isReAppended) {\n          // remove the current version and let the new version replace it and re-execute\n          removed.push(currentHeadElt);\n        } else {\n          // this element already exists and should not be re-appended, so remove it from\n          // the new content map, preserving it in the DOM\n          srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n          preserved.push(currentHeadElt);\n        }\n      } else {\n        if (ctx.head.style === \"append\") {\n          // we are appending and this existing element is not new content\n          // so if and only if it is marked for re-append do we do anything\n          if (isReAppended) {\n            removed.push(currentHeadElt);\n            nodesToAppend.push(currentHeadElt);\n          }\n        } else {\n          // if this is a merge, we remove this content since it is not in the new head\n          if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n            removed.push(currentHeadElt);\n          }\n        }\n      }\n    }\n\n    // Push the remaining new head elements in the Map into the\n    // nodes to append to the head tag\n    nodesToAppend.push(...srcToNewHeadNodes.values());\n\n    let promises = [];\n    for (const newNode of nodesToAppend) {\n      // TODO: This could theoretically be null, based on type\n      let newElt = /** @type {ChildNode} */ (\n        document.createRange().createContextualFragment(newNode.outerHTML)\n          .firstChild\n      );\n      if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n        if (\n          (\"href\" in newElt && newElt.href) ||\n          (\"src\" in newElt && newElt.src)\n        ) {\n          /** @type {(result?: any) => void} */ let resolve;\n          let promise = new Promise(function (_resolve) {\n            resolve = _resolve;\n          });\n          newElt.addEventListener(\"load\", function () {\n            resolve();\n          });\n          promises.push(promise);\n        }\n        oldHead.appendChild(newElt);\n        ctx.callbacks.afterNodeAdded(newElt);\n        added.push(newElt);\n      }\n    }\n\n    // remove all removed elements, after we have appended the new elements to avoid\n    // additional network requests for things like style sheets\n    for (const removedElement of removed) {\n      if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n        oldHead.removeChild(removedElement);\n        ctx.callbacks.afterNodeRemoved(removedElement);\n      }\n    }\n\n    ctx.head.afterHeadMorphed(oldHead, {\n      added: added,\n      kept: preserved,\n      removed: removed,\n    });\n    return promises;\n  }\n\n  //=============================================================================\n  // Create Morph Context Functions\n  //=============================================================================\n  const createMorphContext = (function () {\n    /**\n     *\n     * @param {Element} oldNode\n     * @param {Element} newContent\n     * @param {Config} config\n     * @returns {MorphContext}\n     */\n    function createMorphContext(oldNode, newContent, config) {\n      const { persistentIds, idMap } = createIdMaps(oldNode, newContent);\n\n      const mergedConfig = mergeDefaults(config);\n      const morphStyle = mergedConfig.morphStyle || \"outerHTML\";\n      if (![\"innerHTML\", \"outerHTML\"].includes(morphStyle)) {\n        throw `Do not understand how to morph style ${morphStyle}`;\n      }\n\n      return {\n        target: oldNode,\n        newContent: newContent,\n        config: mergedConfig,\n        morphStyle: morphStyle,\n        ignoreActive: mergedConfig.ignoreActive,\n        ignoreActiveValue: mergedConfig.ignoreActiveValue,\n        restoreFocus: mergedConfig.restoreFocus,\n        idMap: idMap,\n        persistentIds: persistentIds,\n        pantry: createPantry(),\n        callbacks: mergedConfig.callbacks,\n        head: mergedConfig.head,\n      };\n    }\n\n    /**\n     * Deep merges the config object and the Idiomorph.defaults object to\n     * produce a final configuration object\n     * @param {Config} config\n     * @returns {ConfigInternal}\n     */\n    function mergeDefaults(config) {\n      let finalConfig = Object.assign({}, defaults);\n\n      // copy top level stuff into final config\n      Object.assign(finalConfig, config);\n\n      // copy callbacks into final config (do this to deep merge the callbacks)\n      finalConfig.callbacks = Object.assign(\n        {},\n        defaults.callbacks,\n        config.callbacks,\n      );\n\n      // copy head config into final config  (do this to deep merge the head)\n      finalConfig.head = Object.assign({}, defaults.head, config.head);\n\n      return finalConfig;\n    }\n\n    /**\n     * @returns {HTMLDivElement}\n     */\n    function createPantry() {\n      const pantry = document.createElement(\"div\");\n      pantry.hidden = true;\n      document.body.insertAdjacentElement(\"afterend\", pantry);\n      return pantry;\n    }\n\n    /**\n     * Returns all elements with an ID contained within the root element and its descendants\n     *\n     * @param {Element} root\n     * @returns {Element[]}\n     */\n    function findIdElements(root) {\n      let elements = Array.from(root.querySelectorAll(\"[id]\"));\n      if (root.id) {\n        elements.push(root);\n      }\n      return elements;\n    }\n\n    /**\n     * A bottom-up algorithm that populates a map of Element -> IdSet.\n     * The idSet for a given element is the set of all IDs contained within its subtree.\n     * As an optimzation, we filter these IDs through the given list of persistent IDs,\n     * because we don't need to bother considering IDed elements that won't be in the new content.\n     *\n     * @param {Map<Node, Set<string>>} idMap\n     * @param {Set<string>} persistentIds\n     * @param {Element} root\n     * @param {Element[]} elements\n     */\n    function populateIdMapWithTree(idMap, persistentIds, root, elements) {\n      for (const elt of elements) {\n        if (persistentIds.has(elt.id)) {\n          /** @type {Element|null} */\n          let current = elt;\n          // walk up the parent hierarchy of that element, adding the id\n          // of element to the parent's id set\n          while (current) {\n            let idSet = idMap.get(current);\n            // if the id set doesn't exist, create it and insert it in the map\n            if (idSet == null) {\n              idSet = new Set();\n              idMap.set(current, idSet);\n            }\n            idSet.add(elt.id);\n\n            if (current === root) break;\n            current = current.parentElement;\n          }\n        }\n      }\n    }\n\n    /**\n     * This function computes a map of nodes to all ids contained within that node (inclusive of the\n     * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n     * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n     * to contribute to a parent nodes matching.\n     *\n     * @param {Element} oldContent  the old content that will be morphed\n     * @param {Element} newContent  the new content to morph to\n     * @returns {IdSets}\n     */\n    function createIdMaps(oldContent, newContent) {\n      const oldIdElements = findIdElements(oldContent);\n      const newIdElements = findIdElements(newContent);\n\n      const persistentIds = createPersistentIds(oldIdElements, newIdElements);\n\n      /** @type {Map<Node, Set<string>>} */\n      let idMap = new Map();\n      populateIdMapWithTree(idMap, persistentIds, oldContent, oldIdElements);\n\n      /** @ts-ignore - if newContent is a duck-typed parent, pass its single child node as the root to halt upwards iteration */\n      const newRoot = newContent.__idiomorphRoot || newContent;\n      populateIdMapWithTree(idMap, persistentIds, newRoot, newIdElements);\n\n      return { persistentIds, idMap };\n    }\n\n    /**\n     * This function computes the set of ids that persist between the two contents excluding duplicates\n     *\n     * @param {Element[]} oldIdElements\n     * @param {Element[]} newIdElements\n     * @returns {Set<string>}\n     */\n    function createPersistentIds(oldIdElements, newIdElements) {\n      let duplicateIds = new Set();\n\n      /** @type {Map<string, string>} */\n      let oldIdTagNameMap = new Map();\n      for (const { id, tagName } of oldIdElements) {\n        if (oldIdTagNameMap.has(id)) {\n          duplicateIds.add(id);\n        } else {\n          oldIdTagNameMap.set(id, tagName);\n        }\n      }\n\n      let persistentIds = new Set();\n      for (const { id, tagName } of newIdElements) {\n        if (persistentIds.has(id)) {\n          duplicateIds.add(id);\n        } else if (oldIdTagNameMap.get(id) === tagName) {\n          persistentIds.add(id);\n        }\n        // skip if tag types mismatch because its not possible to morph one tag into another\n      }\n\n      for (const id of duplicateIds) {\n        persistentIds.delete(id);\n      }\n      return persistentIds;\n    }\n\n    return createMorphContext;\n  })();\n\n  //=============================================================================\n  // HTML Normalization Functions\n  //=============================================================================\n  const { normalizeElement, normalizeParent } = (function () {\n    /** @type {WeakSet<Node>} */\n    const generatedByIdiomorph = new WeakSet();\n\n    /**\n     *\n     * @param {Element | Document} content\n     * @returns {Element}\n     */\n    function normalizeElement(content) {\n      if (content instanceof Document) {\n        return content.documentElement;\n      } else {\n        return content;\n      }\n    }\n\n    /**\n     *\n     * @param {null | string | Node | HTMLCollection | Node[] | Document & {generatedByIdiomorph:boolean}} newContent\n     * @returns {Element}\n     */\n    function normalizeParent(newContent) {\n      if (newContent == null) {\n        return document.createElement(\"div\"); // dummy parent element\n      } else if (typeof newContent === \"string\") {\n        return normalizeParent(parseContent(newContent));\n      } else if (\n        generatedByIdiomorph.has(/** @type {Element} */ (newContent))\n      ) {\n        // the template tag created by idiomorph parsing can serve as a dummy parent\n        return /** @type {Element} */ (newContent);\n      } else if (newContent instanceof Node) {\n        if (newContent.parentNode) {\n          // we can't use the parent directly because newContent may have siblings\n          // that we don't want in the morph, and reparenting might be expensive (TODO is it?),\n          // so instead we create a fake parent node that only sees a slice of its children.\n          /** @type {Element} */\n          return /** @type {any} */ (new SlicedParentNode(newContent));\n        } else {\n          // a single node is added as a child to a dummy parent\n          const dummyParent = document.createElement(\"div\");\n          dummyParent.append(newContent);\n          return dummyParent;\n        }\n      } else {\n        // all nodes in the array or HTMLElement collection are consolidated under\n        // a single dummy parent element\n        const dummyParent = document.createElement(\"div\");\n        for (const elt of [...newContent]) {\n          dummyParent.append(elt);\n        }\n        return dummyParent;\n      }\n    }\n\n    /**\n     * A fake duck-typed parent element to wrap a single node, without actually reparenting it.\n     * This is useful because the node may have siblings that we don't want in the morph, and it may also be moved\n     * or replaced with one or more elements during the morph. This class effectively allows us a window into\n     * a slice of a node's children.\n     * \"If it walks like a duck, and quacks like a duck, then it must be a duck!\" -- James Whitcomb Riley (1849\u20131916)\n     */\n    class SlicedParentNode {\n      /** @param {Node} node */\n      constructor(node) {\n        this.originalNode = node;\n        this.realParentNode = /** @type {Element} */ (node.parentNode);\n        this.previousSibling = node.previousSibling;\n        this.nextSibling = node.nextSibling;\n      }\n\n      /** @returns {Node[]} */\n      get childNodes() {\n        // return slice of realParent's current childNodes, based on previousSibling and nextSibling\n        const nodes = [];\n        let cursor = this.previousSibling\n          ? this.previousSibling.nextSibling\n          : this.realParentNode.firstChild;\n        while (cursor && cursor != this.nextSibling) {\n          nodes.push(cursor);\n          cursor = cursor.nextSibling;\n        }\n        return nodes;\n      }\n\n      /**\n       * @param {string} selector\n       * @returns {Element[]}\n       */\n      querySelectorAll(selector) {\n        return this.childNodes.reduce((results, node) => {\n          if (node instanceof Element) {\n            if (node.matches(selector)) results.push(node);\n            const nodeList = node.querySelectorAll(selector);\n            for (let i = 0; i < nodeList.length; i++) {\n              results.push(nodeList[i]);\n            }\n          }\n          return results;\n        }, /** @type {Element[]} */ ([]));\n      }\n\n      /**\n       * @param {Node} node\n       * @param {Node} referenceNode\n       * @returns {Node}\n       */\n      insertBefore(node, referenceNode) {\n        return this.realParentNode.insertBefore(node, referenceNode);\n      }\n\n      /**\n       * @param {Node} node\n       * @param {Node} referenceNode\n       * @returns {Node}\n       */\n      moveBefore(node, referenceNode) {\n        // @ts-ignore - use new moveBefore feature\n        return this.realParentNode.moveBefore(node, referenceNode);\n      }\n\n      /**\n       * for later use with populateIdMapWithTree to halt upwards iteration\n       * @returns {Node}\n       */\n      get __idiomorphRoot() {\n        return this.originalNode;\n      }\n    }\n\n    /**\n     *\n     * @param {string} newContent\n     * @returns {Node | null | DocumentFragment}\n     */\n    function parseContent(newContent) {\n      let parser = new DOMParser();\n\n      // remove svgs to avoid false-positive matches on head, etc.\n      let contentWithSvgsRemoved = newContent.replace(\n        /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n        \"\",\n      );\n\n      // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n      if (\n        contentWithSvgsRemoved.match(/<\\/html>/) ||\n        contentWithSvgsRemoved.match(/<\\/head>/) ||\n        contentWithSvgsRemoved.match(/<\\/body>/)\n      ) {\n        let content = parser.parseFromString(newContent, \"text/html\");\n        // if it is a full HTML document, return the document itself as the parent container\n        if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n          generatedByIdiomorph.add(content);\n          return content;\n        } else {\n          // otherwise return the html element as the parent container\n          let htmlElement = content.firstChild;\n          if (htmlElement) {\n            generatedByIdiomorph.add(htmlElement);\n          }\n          return htmlElement;\n        }\n      } else {\n        // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n        // deal with touchy tags like tr, tbody, etc.\n        let responseDoc = parser.parseFromString(\n          \"<body><template>\" + newContent + \"</template></body>\",\n          \"text/html\",\n        );\n        let content = /** @type {HTMLTemplateElement} */ (\n          responseDoc.body.querySelector(\"template\")\n        ).content;\n        generatedByIdiomorph.add(content);\n        return content;\n      }\n    }\n\n    return { normalizeElement, normalizeParent };\n  })();\n\n  //=============================================================================\n  // This is what ends up becoming the Idiomorph global object\n  //=============================================================================\n  return {\n    morph,\n    defaults,\n  };\n})();\n\nexport {Idiomorph};\n", "// Icon: material-symbols:cloud-download\n// Slug: Merge fragments into the DOM using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DefaultFragmentMergeMode,\n  DefaultFragmentsUseViewTransitions,\n  EventTypes,\n  FragmentMergeModes,\n} from '../../../../engine/consts'\nimport { initErr } from '../../../../engine/errors'\nimport {\n  type HTMLorSVGElement,\n  type InitContext,\n  PluginType,\n  type WatcherPlugin,\n} from '../../../../engine/types'\nimport { attrHash, elUniqId, walkDOM } from '../../../../utils/dom'\nimport { isBoolString } from '../../../../utils/text'\nimport {\n  docWithViewTransitionAPI,\n  supportsViewTransitions,\n} from '../../../../utils/view-transtions'\nimport { Idiomorph } from '../../../../vendored/idiomorph.esm'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const MergeFragments: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypes.MergeFragments,\n  onGlobalInit: async (ctx) => {\n    const fragmentContainer = document.createElement('template')\n    datastarSSEEventWatcher(\n      EventTypes.MergeFragments,\n      ({\n        fragments: fragmentsRaw = '<div></div>',\n        selector = '',\n        mergeMode = DefaultFragmentMergeMode,\n        useViewTransition:\n          useViewTransitionRaw = `${DefaultFragmentsUseViewTransitions}`,\n      }) => {\n        const useViewTransition = isBoolString(useViewTransitionRaw)\n\n        fragmentContainer.innerHTML = fragmentsRaw.trim()\n        const fragments = [...fragmentContainer.content.children]\n        for (const fragment of fragments) {\n          if (!(fragment instanceof Element)) {\n            throw initErr('NoFragmentsFound', ctx)\n          }\n\n          const selectorOrID = selector || `#${fragment.getAttribute('id')}`\n          const targets = [...(document.querySelectorAll(selectorOrID) || [])]\n          if (!targets.length) {\n            throw initErr('NoTargetsFound', ctx, { selectorOrID })\n          }\n\n          if (useViewTransition && supportsViewTransitions) {\n            docWithViewTransitionAPI.startViewTransition(() =>\n              applyToTargets(ctx, mergeMode, fragment, targets),\n            )\n          } else {\n            applyToTargets(ctx, mergeMode, fragment, targets)\n          }\n        }\n      },\n    )\n  },\n}\n\nfunction applyToTargets(\n  ctx: InitContext,\n  mergeMode: string,\n  fragment: Element,\n  capturedTargets: Element[],\n) {\n  for (const target of capturedTargets) {\n    switch (mergeMode) {\n      case FragmentMergeModes.Morph: {\n        const fragmentWithIDs = fragment.cloneNode(true) as HTMLorSVGElement\n        walkDOM(fragmentWithIDs, (el) => {\n          if (!el.id?.length && Object.keys(el.dataset).length) {\n            el.id = elUniqId(el)\n          }\n          // Rehash the cleanup functions for this element to ensure that plugins are cleaned up and reapplied after merging.\n          const elTracking = ctx.removals.get(el.id)\n          if (elTracking) {\n            const newElTracking = new Map()\n            for (const [key, cleanup] of elTracking) {\n              const newKey = attrHash(key, key)\n              newElTracking.set(newKey, cleanup)\n              elTracking.delete(key)\n            }\n            ctx.removals.set(el.id, newElTracking)\n          }\n        })\n\n        Idiomorph.morph(target, fragmentWithIDs)\n        break\n      }\n      case FragmentMergeModes.Inner:\n        // Replace the contents of the target element with the outer HTML of the response\n        target.innerHTML = fragment.outerHTML\n        break\n      case FragmentMergeModes.Outer:\n        // Replace the entire target element with the response\n        target.replaceWith(fragment)\n        break\n      case FragmentMergeModes.Prepend:\n        // Insert the response before the first child of the target element\n        target.prepend(fragment)\n        break\n      case FragmentMergeModes.Append:\n        // Insert the response after the last child of the target element\n        target.append(fragment)\n        break\n      case FragmentMergeModes.Before:\n        // Insert the response before the target element\n        target.before(fragment)\n        break\n      case FragmentMergeModes.After:\n        // Insert the response after the target element\n        target.after(fragment)\n        break\n      case FragmentMergeModes.UpsertAttributes:\n        // Upsert the attributes of the target element\n        for (const attrName of fragment.getAttributeNames()) {\n          const value = fragment.getAttribute(attrName)!\n          target.setAttribute(attrName, value)\n        }\n        break\n      default:\n        throw initErr('InvalidMergeMode', ctx, { mergeMode })\n    }\n  }\n}\n", "// Icon: material-symbols:settings-input-antenna\n// Slug: Merge signals using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DefaultMergeSignalsOnlyIfMissing,\n  EventTypes,\n} from '../../../../engine/consts'\nimport { PluginType, type WatcherPlugin } from '../../../../engine/types'\nimport { isBoolString, jsStrToObject } from '../../../../utils/text'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const MergeSignals: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypes.MergeSignals,\n  onGlobalInit: async (ctx) => {\n    datastarSSEEventWatcher(\n      EventTypes.MergeSignals,\n      ({\n        signals: raw = '{}',\n        onlyIfMissing: onlyIfMissingRaw = `${DefaultMergeSignalsOnlyIfMissing}`,\n      }) => {\n        const { signals } = ctx\n        const onlyIfMissing = isBoolString(onlyIfMissingRaw)\n        signals.merge(jsStrToObject(raw), onlyIfMissing)\n      },\n    )\n  },\n}\n", "// Icon: material-symbols:settings-input-antenna\n// Slug: Remove fragments from the DOM using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DefaultFragmentsUseViewTransitions,\n  EventTypes,\n} from '../../../../engine/consts'\nimport { initErr } from '../../../../engine/errors'\nimport { PluginType, type WatcherPlugin } from '../../../../engine/types'\nimport { isBoolString } from '../../../../utils/text'\nimport {\n  docWithViewTransitionAPI,\n  supportsViewTransitions,\n} from '../../../../utils/view-transtions'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const RemoveFragments: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypes.RemoveFragments,\n  onGlobalInit: async (ctx) => {\n    datastarSSEEventWatcher(\n      EventTypes.RemoveFragments,\n      ({\n        selector,\n        useViewTransition:\n          useViewTransitionRaw = `${DefaultFragmentsUseViewTransitions}`,\n      }) => {\n        if (!selector.length) {\n          throw initErr('NoSelectorProvided', ctx)\n        }\n\n        const useViewTransition = isBoolString(useViewTransitionRaw)\n        const removeTargets = document.querySelectorAll(selector)\n\n        const applyToTargets = () => {\n          for (const target of removeTargets) {\n            target.remove()\n          }\n        }\n\n        if (useViewTransition && supportsViewTransitions) {\n          docWithViewTransitionAPI.startViewTransition(() => applyToTargets())\n        } else {\n          applyToTargets()\n        }\n      },\n    )\n  },\n}\n", "// Icon: material-symbols:settings-input-antenna\n// Slug: Remove signals using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { EventTypes } from '../../../../engine/consts'\nimport { initErr } from '../../../../engine/errors'\nimport { PluginType, type WatcherPlugin } from '../../../../engine/types'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const RemoveSignals: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypes.RemoveSignals,\n  onGlobalInit: async (ctx) => {\n    datastarSSEEventWatcher(\n      EventTypes.RemoveSignals,\n      ({ paths: pathsRaw = '' }) => {\n        const paths = pathsRaw.split('\\n').map((p) => p.trim())\n        if (!paths?.length) {\n          throw initErr('NoPathsProvided', ctx)\n        }\n        ctx.signals.remove(...paths)\n      },\n    )\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: mdi:clipboard\n// Slug: Copy text to the clipboard\n// Description: This action copies text to the clipboard using the Clipboard API.\n\nimport { runtimeErr } from '../../../../engine/errors'\nimport { type ActionPlugin, PluginType } from '../../../../engine/types'\n\nexport const Clipboard: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'clipboard',\n  fn: (ctx, text) => {\n    if (!navigator.clipboard) {\n      throw runtimeErr('ClipboardNotAvailable', ctx)\n    }\n    navigator.clipboard.writeText(text)\n  },\n}\n", "// Authors: Ben Croker\n// Icon: mdi-message-alert\n// Slug: Add custom validity to an element using an expression\n// Description: This plugin allows you to add custom validity to an element using an expression. The expression should evaluate to a string that will be set as the custom validity message. This can be used to provide custom error messages for form validation.\n\nimport { runtimeErr } from '../../../../engine/errors'\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nexport const CustomValidity: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'customValidity',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Must,\n  onLoad: (ctx) => {\n    const { el, genRX, effect } = ctx\n    if (\n      !(\n        el instanceof HTMLInputElement ||\n        el instanceof HTMLSelectElement ||\n        el instanceof HTMLTextAreaElement\n      )\n    ) {\n      throw runtimeErr('CustomValidityInvalidElement', ctx)\n    }\n    const { deps, rxFn } = genRX()\n    return effect(deps, () => {\n      const result = rxFn<string>()\n      if (typeof result !== 'string') {\n        throw runtimeErr('CustomValidityInvalidExpression', ctx, { result })\n      }\n      el.setCustomValidity(result)\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: mdi-light:vector-intersection\n// Slug: Run expression when element intersects with viewport\n// Description: An attribute that runs an expression when the element intersects with the viewport.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nconst ONCE = 'once'\nconst HALF = 'half'\nconst FULL = 'full'\n\n// Run expression when element intersects with viewport\nexport const Intersects: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'intersects',\n  keyReq: Requirement.Denied,\n  mods: new Set([ONCE, HALF, FULL]),\n  onLoad: ({ el, rawKey, mods, genRX }) => {\n    const options = { threshold: 0 }\n    if (mods.has(FULL)) options.threshold = 1\n    else if (mods.has(HALF)) options.threshold = 0.5\n\n    const { rxFn } = genRX()\n    const observer = new IntersectionObserver((entries) => {\n      for (const entry of entries) {\n        if (entry.isIntersecting) {\n          rxFn()\n          if (mods.has(ONCE)) {\n            observer.disconnect()\n            delete el.dataset[rawKey]\n          }\n        }\n      }\n    }, options)\n\n    observer.observe(el)\n    return () => observer.disconnect()\n  },\n}\n", "export function tagToMs(args: Set<string>) {\n  if (!args || args.size <= 0) return 0\n  for (const arg of args) {\n    if (arg.endsWith('ms')) {\n      return Number(arg.replace('ms', ''))\n    }\n    if (arg.endsWith('s')) {\n      return Number(arg.replace('s', '')) * 1000\n    }\n    try {\n      return Number.parseFloat(arg)\n    } catch (e) {}\n  }\n  return 0\n}\n\nexport function tagHas(tags: Set<string>, tag: string, defaultValue = false) {\n  if (!tags) return defaultValue\n  return tags.has(tag.toLowerCase())\n}\n", "export type TimerHandler = (...args: any[]) => void\n\nexport function delay(\n  callback: TimerHandler,\n  wait: number,\n): TimerHandler {\n  return (...args: any[]) => {\n    setTimeout(() => {\n      callback(...args)\n    }, wait)\n  }\n}\n\nexport function debounce(\n  callback: TimerHandler,\n  wait: number,\n  leading = false,\n  trailing = true,\n): TimerHandler {\n  let timer = -1\n\n  const resetTimer = () => timer && clearTimeout(timer)\n\n  return (...args: any[]) => {\n    resetTimer()\n\n    if (leading && !timer) {\n      callback(...args)\n    }\n\n    timer = setTimeout(() => {\n      if (trailing) {\n        callback(...args)\n      }\n      resetTimer()\n    }, wait)\n  }\n}\n\nexport function throttle(\n  callback: TimerHandler,\n  wait: number,\n  leading = true,\n  trailing = false,\n): TimerHandler {\n  let waiting = false\n\n  return (...args: any[]) => {\n    if (waiting) return\n\n    if (leading) {\n      callback(...args)\n    }\n\n    waiting = true\n    setTimeout(() => {\n      waiting = false\n      if (trailing) {\n        callback(...args)\n      }\n    }, wait)\n  }\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:mail\n// Slug: Add an event listener to an element\n// Description: This action adds an event listener to an element. The event listener can be triggered by a variety of events, such as clicks, keypresses, and more. The event listener can also be set to trigger only once, or to be passive or capture. The event listener can also be debounced or throttled. The event listener can also be set to trigger only when the event target is outside the element.\n\nimport {\n  type AttributePlugin,\n  DATASTAR_SIGNAL_EVENT,\n  type DatastarSignalEvent,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { tagHas, tagToMs } from '../../../../utils/tags'\nimport { camel, kebab, modifyCasing } from '../../../../utils/text'\nimport { debounce, delay, throttle } from '../../../../utils/timing'\nimport { supportsViewTransitions } from '../../../../utils/view-transtions'\n\nconst EVT = 'evt'\nexport const SIGNALS_CHANGE_PREFIX = 'signalsChange'\nconst signalChangeKeyLength = SIGNALS_CHANGE_PREFIX.length\n\nexport const On: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'on',\n  keyReq: Requirement.Must,\n  valReq: Requirement.Must,\n  argNames: [EVT],\n  onLoad: ({ el, key, mods, genRX }) => {\n    const { rxFn } = genRX()\n    let target: Element | Window | Document = el\n    if (mods.has('window')) target = window\n\n    let callback = (evt?: Event) => {\n      if (evt) {\n        // Always prevent default on submit events (because forms)\n        if (mods.has('prevent') || key === 'submit') evt.preventDefault()\n        if (mods.has('stop')) evt.stopPropagation()\n      }\n      rxFn(evt)\n    }\n\n    const delayArgs = mods.get('delay')\n    if (delayArgs) {\n      const wait = tagToMs(delayArgs)\n      callback = delay(callback, wait)\n    }\n\n    const debounceArgs = mods.get('debounce')\n    if (debounceArgs) {\n      const wait = tagToMs(debounceArgs)\n      const leading = tagHas(debounceArgs, 'leading', false)\n      const trailing = !tagHas(debounceArgs, 'notrail', false)\n      callback = debounce(callback, wait, leading, trailing)\n    }\n\n    const throttleArgs = mods.get('throttle')\n    if (throttleArgs) {\n      const wait = tagToMs(throttleArgs)\n      const leading = !tagHas(throttleArgs, 'noleading', false)\n      const trailing = tagHas(throttleArgs, 'trail', false)\n      callback = throttle(callback, wait, leading, trailing)\n    }\n\n    if (mods.has('viewtransition') && supportsViewTransitions) {\n      const cb = callback // I hate javascript\n      callback = (...args: any[]) =>\n        document.startViewTransition(() => cb(...args))\n    }\n\n    const evtListOpts: AddEventListenerOptions = {\n      capture: true,\n      passive: false,\n      once: false,\n    }\n    if (!mods.has('capture')) evtListOpts.capture = false\n    if (mods.has('passive')) evtListOpts.passive = true\n    if (mods.has('once')) evtListOpts.once = true\n\n    if (key === 'load') {\n      // Delay the callback to the next microtask so that indicators can be set\n      setTimeout(callback, 0)\n      return () => {}\n    }\n\n    if (key === 'interval') {\n      let duration = 1000\n      const durationArgs = mods.get('duration')\n      if (durationArgs) {\n        duration = tagToMs(durationArgs)\n        const leading = tagHas(durationArgs, 'leading', false)\n        if (leading) {\n          callback()\n        }\n      }\n      const intervalId = setInterval(callback, duration)\n\n      return () => {\n        clearInterval(intervalId)\n      }\n    }\n\n    if (key === 'raf') {\n      let rafId: number | undefined\n      const raf = () => {\n        callback()\n        rafId = requestAnimationFrame(raf)\n      }\n      rafId = requestAnimationFrame(raf)\n\n      return () => {\n        if (rafId) {\n          cancelAnimationFrame(rafId)\n        }\n      }\n    }\n\n    if (key.startsWith(SIGNALS_CHANGE_PREFIX)) {\n      const hasPrefix = key !== SIGNALS_CHANGE_PREFIX\n      const signalPath = modifyCasing(\n        camel(key.slice(signalChangeKeyLength)),\n        mods,\n      )\n      const signalFn = (event: CustomEvent<DatastarSignalEvent>) => {\n        if (hasPrefix) {\n          const { added, removed, updated } = event.detail\n          if (\n            ![...added, ...removed, ...updated].some((d) =>\n              d.startsWith(signalPath),\n            )\n          ) {\n            return\n          }\n        }\n        callback(event)\n      }\n      document.addEventListener(DATASTAR_SIGNAL_EVENT, signalFn)\n      return () => {\n        document.removeEventListener(DATASTAR_SIGNAL_EVENT, signalFn)\n      }\n    }\n\n    const testOutside = mods.has('outside')\n    if (testOutside) {\n      target = document\n      const cb = callback\n      const targetOutsideCallback = (e?: Event) => {\n        const targetHTML = e?.target as HTMLElement\n        if (!el.contains(targetHTML)) {\n          cb(e)\n        }\n      }\n      callback = targetOutsideCallback\n    }\n\n    // Default to kebab-case and allow modifying\n    let eventName = kebab(key)\n    eventName = modifyCasing(eventName, mods)\n\n    target.addEventListener(eventName, callback, evtListOpts)\n    return () => {\n      target.removeEventListener(eventName, callback)\n    }\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: mdi:floppy-variant\n// Slug: Persist data to local storage or session storage\n// Description: This plugin allows you to persist data to local storage or session storage.  Once you add this attribute the data will be persisted to local storage or session storage.\n\nimport { DATASTAR } from '../../../../engine/consts'\nimport {\n  type AttributePlugin,\n  DATASTAR_SIGNAL_EVENT,\n  type DatastarSignalEvent,\n  type NestedValues,\n  PluginType,\n} from '../../../../engine/types'\nimport {\n  camel,\n  modifyCasing,\n  trimDollarSignPrefix,\n} from '../../../../utils/text'\nimport { SIGNALS_CHANGE_PREFIX } from '../../dom/attributes/on'\n\nconst SESSION = 'session'\n\nexport const Persist: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'persist',\n  mods: new Set([SESSION]),\n  onLoad: ({ key, mods, signals, value }) => {\n    key = modifyCasing(key, mods)\n    if (key === '') {\n      key = DATASTAR\n    }\n\n    const storage = mods.has(SESSION) ? sessionStorage : localStorage\n    let paths = value.split(/\\s+/).filter((p) => p !== '')\n    paths = paths.map((p) => trimDollarSignPrefix(p))\n\n    const storageToSignals = () => {\n      const data = storage.getItem(key) || '{}'\n      const nestedValues = JSON.parse(data)\n      signals.merge(nestedValues)\n    }\n\n    const signalsToStorage = () => {\n      let nv: NestedValues\n      if (!paths.length) {\n        nv = signals.values()\n      } else {\n        nv = signals.subset(...paths)\n      }\n      storage.setItem(key, JSON.stringify(nv))\n    }\n\n    const hasPrefix = key !== SIGNALS_CHANGE_PREFIX\n    const signalPath = modifyCasing(\n      camel(key.slice(SIGNALS_CHANGE_PREFIX.length)),\n      mods,\n    )\n    const signalFn = (event: CustomEvent<DatastarSignalEvent>) => {\n      if (hasPrefix) {\n        const { added, removed, updated } = event.detail\n        if (\n          ![...added, ...removed, ...updated].some((d) =>\n            d.startsWith(signalPath),\n          )\n        ) {\n          return\n        }\n      }\n      signalsToStorage()\n    }\n    document.addEventListener(DATASTAR_SIGNAL_EVENT, signalFn)\n    storageToSignals()\n    return () => {\n      document.removeEventListener(DATASTAR_SIGNAL_EVENT, signalFn)\n    }\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: carbon:url\n// Slug: Replace the current URL with a new URL\n// Description: This plugin allows you to replace the current URL with a new URL.  Once you add this attribute the current URL will be replaced with the new URL.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nexport const ReplaceUrl: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'replaceUrl',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Must,\n  onLoad: ({ effect, genRX }) => {\n    const { deps, rxFn } = genRX()\n    return effect(deps, () => {\n      const url = rxFn<string>()\n      const baseUrl = window.location.href\n      const fullUrl = new URL(url, baseUrl).toString()\n      window.history.replaceState({}, '', fullUrl)\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: hugeicons:mouse-scroll-01\n// Slug: Scroll an element into view\n// Description: This attribute scrolls the element into view.\n\nimport { runtimeErr } from '../../../../engine/errors'\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nconst SMOOTH = 'smooth'\nconst INSTANT = 'instant'\nconst AUTO = 'auto'\nconst HSTART = 'hstart'\nconst HCENTER = 'hcenter'\nconst HEND = 'hend'\nconst HNEAREST = 'hnearest'\nconst VSTART = 'vstart'\nconst VCENTER = 'vcenter'\nconst VEND = 'vend'\nconst VNEAREST = 'vnearest'\nconst FOCUS = 'focus'\n\nconst CENTER = 'center'\nconst START = 'start'\nconst END = 'end'\nconst NEAREST = 'nearest'\n\n// Scrolls the element into view\nexport const ScrollIntoView: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'scrollIntoView',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Denied,\n  mods: new Set([\n    SMOOTH,\n    INSTANT,\n    AUTO,\n    HSTART,\n    HCENTER,\n    HEND,\n    HNEAREST,\n    VSTART,\n    VCENTER,\n    VEND,\n    VNEAREST,\n    FOCUS,\n  ]),\n\n  onLoad: (ctx) => {\n    const { el, mods, rawKey } = ctx\n    if (!el.tabIndex) el.setAttribute('tabindex', '0')\n    const opts: ScrollIntoViewOptions = {\n      behavior: SMOOTH,\n      block: CENTER,\n      inline: CENTER,\n    }\n    if (mods.has(SMOOTH)) opts.behavior = SMOOTH\n    if (mods.has(INSTANT)) opts.behavior = INSTANT\n    if (mods.has(AUTO)) opts.behavior = AUTO\n    if (mods.has(HSTART)) opts.inline = START\n    if (mods.has(HCENTER)) opts.inline = CENTER\n    if (mods.has(HEND)) opts.inline = END\n    if (mods.has(HNEAREST)) opts.inline = NEAREST\n    if (mods.has(VSTART)) opts.block = START\n    if (mods.has(VCENTER)) opts.block = CENTER\n    if (mods.has(VEND)) opts.block = END\n    if (mods.has(VNEAREST)) opts.block = NEAREST\n\n    if (!(el instanceof HTMLElement || el instanceof SVGElement)) {\n      throw runtimeErr('ScrollIntoViewInvalidElement', ctx)\n    }\n    if (!el.tabIndex) {\n      el.setAttribute('tabindex', '0')\n    }\n\n    el.scrollIntoView(opts)\n    if (mods.has('focus')) {\n      el.focus()\n    }\n\n    delete el.dataset[rawKey]\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: streamline:interface-edit-view-eye-eyeball-open-view\n// Slug: Show or hide an element\n// Description: This attribute shows or hides an element based on the value of the expression. If the expression is true, the element is shown. If the expression is false, the element is hidden. The element is hidden by setting the display property to none.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nconst NONE = 'none'\nconst DISPLAY = 'display'\n\nexport const Show: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'show',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Must,\n  onLoad: ({ el: { style: s }, genRX, effect }) => {\n    const { deps, rxFn } = genRX()\n    return effect(deps, async () => {\n      const shouldShow = rxFn<boolean>()\n      if (shouldShow) {\n        if (s.display === NONE) {\n          s.removeProperty(DISPLAY)\n        }\n      } else {\n        s.setProperty(DISPLAY, NONE)\n      }\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:masked-transitions\n// Slug: Setup view transitions\n// Description: This attribute plugin sets up view transitions for the current view. This plugin requires the view transition API to be enabled in the browser. If the browser does not support view transitions, an error will be logged to the console.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { supportsViewTransitions } from '../../../../utils/view-transtions'\n\nconst VIEW_TRANSITION = 'view-transition'\n\nexport const ViewTransition: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'viewTransition',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Must,\n  onGlobalInit() {\n    let hasViewTransitionMeta = false\n    for (const node of document.head.childNodes) {\n      if (node instanceof HTMLMetaElement && node.name === VIEW_TRANSITION) {\n        hasViewTransitionMeta = true\n      }\n    }\n\n    if (!hasViewTransitionMeta) {\n      const meta = document.createElement('meta')\n      meta.name = VIEW_TRANSITION\n      meta.content = 'same-origin'\n      document.head.appendChild(meta)\n    }\n  },\n  onLoad: ({ effect, el, genRX }) => {\n    if (!supportsViewTransitions) {\n      console.error('Browser does not support view transitions')\n      return\n    }\n    const { deps, rxFn } = genRX()\n    return effect(deps, () => {\n      const name = rxFn<string>()\n      if (!name?.length) return\n      const elVTASTyle = el.style as unknown as CSSStyleDeclaration\n      elVTASTyle.viewTransitionName = name\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: akar-icons:link-chain\n// Slug: Bind attributes to expressions\n// Description: Any attribute can be bound to an expression. The attribute will be updated reactively whenever the expression signal changes.\n\nimport {\n  type AttributePlugin,\n  type NestedValues,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { kebab } from '../../../../utils/text'\n\nexport const Attr: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'attr',\n  valReq: Requirement.Must,\n  onLoad: ({ el, key, effect, genRX }) => {\n    const { deps, rxFn } = genRX()\n    if (key === '') {\n      return effect(deps, async () => {\n        const binds = rxFn<NestedValues>()\n        for (const [key, val] of Object.entries(binds)) {\n          if (val === false) {\n            el.removeAttribute(key)\n          } else {\n            el.setAttribute(key, val)\n          }\n        }\n      })\n    }\n\n    // Attributes are always kebab-case\n    key = kebab(key)\n\n    return effect(deps, async () => {\n      let value = false\n      try {\n        value = rxFn()\n      } catch (e) {} //\n      let v: string\n      if (typeof value === 'string') {\n        v = value\n      } else {\n        v = JSON.stringify(value)\n      }\n      if (!v || v === 'false' || v === 'null' || v === 'undefined') {\n        el.removeAttribute(key)\n      } else {\n        el.setAttribute(key, v)\n      }\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: akar-icons:link-chain\n// Slug: Bind attributes to expressions\n// Description: Any attribute can be bound to an expression. The attribute will be updated reactively whenever the expression signal changes.\n\nimport { runtimeErr } from '../../../../engine/errors'\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { modifyCasing, trimDollarSignPrefix } from '../../../../utils/text'\n\nconst dataURIRegex = /^data:(?<mime>[^;]+);base64,(?<contents>.*)$/\nconst updateEvents = ['change', 'input', 'keydown']\n\nexport const Bind: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'bind',\n  keyReq: Requirement.Exclusive,\n  valReq: Requirement.Exclusive,\n  onLoad: (ctx) => {\n    const { el, key, mods, signals, value, effect } = ctx\n    const input = el as HTMLInputElement\n    const signalName = key\n      ? modifyCasing(key, mods)\n      : trimDollarSignPrefix(value)\n\n    const tnl = el.tagName.toLowerCase()\n    const isInput = tnl.includes('input')\n    const isSelect = tnl.includes('select')\n    const type = el.getAttribute('type')\n    const hasValueAttribute = el.hasAttribute('value')\n\n    let signalDefault: string | boolean | number | File = ''\n    const isCheckbox = isInput && type === 'checkbox'\n    if (isCheckbox) {\n      signalDefault = hasValueAttribute ? '' : false\n    }\n    const isNumber = isInput && type === 'number'\n    if (isNumber) {\n      signalDefault = 0\n    }\n    const isRadio = isInput && type === 'radio'\n    if (isRadio) {\n      const name = el.getAttribute('name')\n      if (!name?.length) {\n        el.setAttribute('name', signalName)\n      }\n    }\n    // Can't set a default value for a file input, yet\n    const isFile = isInput && type === 'file'\n\n    const { signal, inserted } = signals.upsertIfMissing(\n      signalName,\n      signalDefault,\n    )\n\n    let arrayIndex = -1\n    if (Array.isArray(signal.value)) {\n      if (el.getAttribute('name') === null) {\n        el.setAttribute('name', signalName)\n      }\n      arrayIndex = [\n        ...document.querySelectorAll(`[name=\"${signalName}\"]`),\n      ].findIndex((el) => el === ctx.el)\n    }\n    const isArray = arrayIndex >= 0\n\n    const signalArray = () => [...(signals.value(signalName) as any[])]\n\n    const setElementFromSignal = () => {\n      let value = signals.value(signalName)\n      if (isArray && !isSelect) {\n        // May be undefined if the array is shorter than the index\n        value = (value as any)[arrayIndex] || signalDefault\n      }\n      const stringValue = `${value}`\n      if (isCheckbox || isRadio) {\n        if (typeof value === 'boolean') {\n          input.checked = value\n        } else {\n          input.checked = stringValue === input.value\n        }\n      } else if (isSelect) {\n        const select = el as HTMLSelectElement\n        if (select.multiple) {\n          if (!isArray) {\n            throw runtimeErr('BindSelectMultiple', ctx)\n          }\n          for (const opt of select.options) {\n            if (opt?.disabled) return\n            const incoming = isNumber ? Number(opt.value) : opt.value\n            opt.selected = (value as any[]).includes(incoming)\n          }\n        } else {\n          select.value = stringValue\n        }\n      } else if (isFile) {\n        // File input reading from a signal is not supported\n      } else if ('value' in el) {\n        el.value = stringValue\n      } else {\n        el.setAttribute('value', stringValue)\n      }\n    }\n\n    const setSignalFromElement = async () => {\n      let currentValue = signals.value(signalName)\n      if (isArray) {\n        // Push as many default signal values onto the array as necessary to reach the index\n        const currentArray = currentValue as any[]\n        while (arrayIndex >= currentArray.length) {\n          currentArray.push(signalDefault)\n        }\n        currentValue = currentArray[arrayIndex] || signalDefault\n      }\n\n      const update = (signalName: string, value: any) => {\n        let newValue = value\n        if (isArray && !isSelect) {\n          newValue = signalArray()\n          newValue[arrayIndex] = value\n        }\n        signals.setValue(signalName, newValue)\n      }\n\n      // Files are a special flower\n      if (isFile) {\n        const files = [...(input?.files || [])]\n        const allContents: string[] = []\n        const allMimes: string[] = []\n        const allNames: string[] = []\n\n        await Promise.all(\n          files.map((f) => {\n            return new Promise<void>((resolve) => {\n              const reader = new FileReader()\n              reader.onload = () => {\n                if (typeof reader.result !== 'string') {\n                  throw runtimeErr('InvalidFileResultType', ctx, {\n                    resultType: typeof reader.result,\n                  })\n                }\n                const match = reader.result.match(dataURIRegex)\n                if (!match?.groups) {\n                  throw runtimeErr('InvalidDataUri', ctx, {\n                    result: reader.result,\n                  })\n                }\n                allContents.push(match.groups.contents)\n                allMimes.push(match.groups.mime)\n                allNames.push(f.name)\n              }\n              reader.onloadend = () => resolve(void 0)\n              reader.readAsDataURL(f)\n            })\n          }),\n        )\n        update(signalName, allContents)\n        update(`${signalName}Mimes`, allMimes)\n        update(`${signalName}Names`, allNames)\n        return\n      }\n\n      const value = input.value || ''\n      let newValue: any\n\n      if (isCheckbox) {\n        const checked =\n          input.checked || input.getAttribute('checked') === 'true'\n\n        // We must check for an attribute value because a checked value defaults to `on`.\n        if (hasValueAttribute) {\n          newValue = checked ? value : ''\n        } else {\n          newValue = checked\n        }\n      } else if (isSelect) {\n        const select = el as HTMLSelectElement\n        const selectedOptions = [...select.selectedOptions]\n        if (isArray) {\n          newValue = selectedOptions\n            .filter((opt) => opt.selected)\n            .map((opt) => opt.value)\n        } else {\n          newValue = selectedOptions[0]?.value || signalDefault\n        }\n      } else if (typeof currentValue === 'boolean') {\n        newValue = Boolean(value)\n      } else if (typeof currentValue === 'number') {\n        newValue = Number(value)\n      } else {\n        newValue = value || ''\n      }\n\n      update(signalName, newValue)\n    }\n\n    // If the signal was inserted, attempt to set the the signal value from the element.\n    if (inserted) {\n      setSignalFromElement()\n    }\n\n    for (const event of updateEvents) {\n      el.addEventListener(event, setSignalFromElement)\n    }\n\n    /*\n     * The signal value needs to be updated after the \"pageshow\" event.\n     * Sometimes, the browser might populate inputs with previous values\n     * when navigating between pages using the back/forward navigation.\n     *\n     * For more information, read about bfcache:\n     * https://web.dev/articles/bfcache\n     */\n    const onPageshow = (ev: PageTransitionEvent) => {\n      if (!ev.persisted) return\n      setSignalFromElement()\n    }\n    window.addEventListener('pageshow', onPageshow)\n\n    const reset = effect([signal], () => {\n      setElementFromSignal()\n    })\n\n    return () => {\n      reset()\n\n      for (const event of updateEvents) {\n        el.removeEventListener(event, setSignalFromElement)\n      }\n\n      window.removeEventListener('pageshow', onPageshow)\n    }\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: ic:baseline-format-paint\n// Slug: Add or remove classes from an element reactively\n// Description: This action adds or removes classes from an element reactively based on the expression provided. The expression should be an object where the keys are the class names and the values are booleans. If the value is true, the class is added. If the value is false, the class is removed.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { kebab, modifyCasing } from '../../../../utils/text'\n\nexport const Class: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'class',\n  valReq: Requirement.Must,\n  onLoad: ({ el, key, mods, effect, genRX }) => {\n    const cl = el.classList\n    const { deps, rxFn } = genRX()\n    return effect(deps, () => {\n      if (key === '') {\n        const classes = rxFn<Record<string, boolean>>()\n        for (const [k, v] of Object.entries(classes)) {\n          const classNames = k.split(/\\s+/)\n          if (v) {\n            cl.add(...classNames)\n          } else {\n            cl.remove(...classNames)\n          }\n        }\n      } else {\n        // Default to kebab-case and allow modifying\n        let className = kebab(key)\n        className = modifyCasing(className, mods)\n\n        const shouldInclude = rxFn<boolean>()\n        if (shouldInclude) {\n          cl.add(className)\n        } else {\n          cl.remove(className)\n        }\n      }\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: mdi:cursor-pointer\n// Slug: Create a reference to an element\n// Description: This attribute creates a reference to an element that can be used in other expressions.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { modifyCasing, trimDollarSignPrefix } from '../../../../utils/text'\n\n// Sets the value of the element\nexport const Ref: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'ref',\n  keyReq: Requirement.Exclusive,\n  valReq: Requirement.Exclusive,\n  onLoad: ({ el, key, mods, signals, value }) => {\n    const signalName = key ? modifyCasing(key, mods) : trimDollarSignPrefix(value)\n    signals.setValue(signalName, el)\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: tabler:typography\n// Slug: Set the text content of an element\n// Description: This attribute sets the text content of an element to the result of the expression.\n\nimport { runtimeErr } from '../../../../engine/errors'\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nexport const Text: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'text',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Must,\n  onLoad: (ctx) => {\n    const { el, effect, genRX } = ctx\n    const { deps, rxFn } = genRX()\n    if (!(el instanceof HTMLElement)) {\n      runtimeErr('TextInvalidElement', ctx)\n    }\n    return effect(deps, () => {\n      const res = rxFn(ctx)\n      el.textContent = `${res}`\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:fit-screen-outline\n// Slug: Clamp a value to a new range\n// Description: This action clamps a value to a new range. The value is first scaled to the new range, then clamped to the new range. This is useful for scaling a value to a new range, then clamping it to that range.\n\nimport {\n  type ActionPlugin,\n  PluginType,\n  type RuntimeContext,\n} from '../../../../engine/types'\n\nconst { round, max, min } = Math\nexport const Fit: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'fit',\n  fn: (\n    _: RuntimeContext,\n    v: number,\n    oldMin: number,\n    oldMax: number,\n    newMin: number,\n    newMax: number,\n    shouldClamp = false,\n    shouldRound = false,\n  ) => {\n    let fitted = ((v - oldMin) / (oldMax - oldMin)) * (newMax - newMin) + newMin\n    if (shouldRound) {\n      fitted = round(fitted)\n    }\n    if (shouldClamp) {\n      fitted = max(newMin, min(newMax, fitted))\n    }\n    return fitted\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: ion:checkmark-round\n// Slug: Set all signals that match a regular expression\n\nimport type { Signal } from '../../../../engine/signals'\nimport { type ActionPlugin, PluginType } from '../../../../engine/types'\n\nexport const SetAll: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'setAll',\n  fn: ({ signals }, prefix: string, newValue) => {\n    signals.walk((path, signal) => {\n      if (!path.startsWith(prefix)) return\n      ;(signal as Signal<any>).value = newValue\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:toggle-off\n// Slug: Toggle all signals that match a regular expression\n\nimport type { Signal } from '../../../../engine/signals'\nimport { type ActionPlugin, PluginType } from '../../../../engine/types'\n\nexport const ToggleAll: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'toggleAll',\n  fn: ({ signals }, prefix: string) => {\n    signals.walk((path, signal) => {\n      if (!path.startsWith(prefix)) return\n      ;(signal as Signal<any>).value = !signal.value\n    })\n  },\n}\n", "import { apply, load, setAlias } from '../engine'\nimport { DELETE } from '../plugins/official/backend/actions/delete'\nimport { GET } from '../plugins/official/backend/actions/get'\nimport { PATCH } from '../plugins/official/backend/actions/patch'\nimport { POST } from '../plugins/official/backend/actions/post'\nimport { PUT } from '../plugins/official/backend/actions/put'\nimport { Indicator } from '../plugins/official/backend/attributes/indicator'\nimport { ExecuteScript } from '../plugins/official/backend/watchers/executeScript'\nimport { MergeFragments } from '../plugins/official/backend/watchers/mergeFragments'\nimport { MergeSignals } from '../plugins/official/backend/watchers/mergeSignals'\nimport { RemoveFragments } from '../plugins/official/backend/watchers/removeFragments'\nimport { RemoveSignals } from '../plugins/official/backend/watchers/removeSignals'\nimport { Clipboard } from '../plugins/official/browser/actions/clipboard'\nimport { CustomValidity } from '../plugins/official/browser/attributes/customValidity'\nimport { Intersects } from '../plugins/official/browser/attributes/intersects'\nimport { Persist } from '../plugins/official/browser/attributes/persist'\nimport { ReplaceUrl } from '../plugins/official/browser/attributes/replaceUrl'\nimport { ScrollIntoView } from '../plugins/official/browser/attributes/scrollIntoView'\nimport { Show } from '../plugins/official/browser/attributes/show'\nimport { ViewTransition } from '../plugins/official/browser/attributes/viewTransition'\nimport { Attr } from '../plugins/official/dom/attributes/attr'\nimport { Bind } from '../plugins/official/dom/attributes/bind'\nimport { Class } from '../plugins/official/dom/attributes/class'\nimport { On } from '../plugins/official/dom/attributes/on'\nimport { Ref } from '../plugins/official/dom/attributes/ref'\nimport { Text } from '../plugins/official/dom/attributes/text'\nimport { Fit } from '../plugins/official/logic/actions/fit'\nimport { SetAll } from '../plugins/official/logic/actions/setAll'\nimport { ToggleAll } from '../plugins/official/logic/actions/toggleAll'\n\nload(\n  // DOM\n  Attr,\n  Bind,\n  Class,\n  On,\n  Ref,\n  Show,\n  Text,\n  // Backend\n  Indicator,\n  GET,\n  POST,\n  PUT,\n  PATCH,\n  DELETE,\n  MergeFragments,\n  MergeSignals,\n  RemoveFragments,\n  RemoveSignals,\n  ExecuteScript,\n  // Browser\n  Clipboard,\n  CustomValidity,\n  Intersects,\n  Persist,\n  ReplaceUrl,\n  ScrollIntoView,\n  ViewTransition,\n  // Logic\n  Fit,\n  SetAll,\n  ToggleAll,\n)\n\napply()\n\nexport { apply, load, setAlias }\n"],
  "mappings": "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",
  "names": ["lol", "DSP", "DSS", "DATASTAR", "DATASTAR_REQUEST", "DefaultSseRetryDurationMs", "DefaultExecuteScriptAttributes", "DefaultFragmentsUseViewTransitions", "DefaultMergeSignalsOnlyIfMissing", "DefaultExecuteScriptAutoRemove", "FragmentMergeModes", "DefaultFragmentMergeMode", "EventTypes", "PluginType", "DATASTAR_SIGNAL_EVENT", "DATASTAR", "isBoolString", "str", "kebab", "$", "ofs", "camel", "x", "snake", "pascal", "jsStrToObject", "raw", "trimDollarSignPrefix", "caseFns", "modifyCasing", "mods", "c", "fn", "name", "Computed", "key", "mods", "signals", "genRX", "modifyCasing", "deps", "rxFn", "Signals", "ctx", "key", "mods", "signals", "value", "genRX", "ifMissing", "rxFn", "k", "modifyCasing", "obj", "jsStrToObject", "nv", "Star", "Hash", "#value", "#prefix", "prefix", "DATASTAR", "x", "c", "elUniqId", "el", "hash", "currentEl", "p", "attrHash", "key", "val", "walkDOM", "element", "callback", "dataset", "url", "dserr", "type", "reason", "metadata", "e", "DATASTAR", "r", "snake", "q", "c", "internalErr", "from", "args", "initErr", "ctx", "errCtx", "PluginType", "runtimeErr", "from", "dispatchSignalEvent", "evt", "DATASTAR_SIGNAL_EVENT", "nestedValues", "signal", "onlyPublic", "kv", "key", "value", "Dependency", "mergeNested", "target", "values", "pathPrefix", "onlyIfMissing", "internalErr", "path", "subEvt", "k", "t", "Signal", "oldValue", "s", "walkNestedSignal", "cb", "nestedSubset", "original", "keys", "subset", "parts", "subOriginal", "subSubset", "i", "part", "last", "SignalsRoot", "#signals", "dotDelimitedPath", "parts", "subDeps", "i", "part", "last", "dep", "internalErr", "from", "signal", "subSignals", "deps", "fn", "c", "computed", "value", "oldValue", "dispatchSignalEvent", "defaultValue", "current", "Signal", "dotDelimitedPaths", "removed", "path", "other", "onlyIfMissing", "evt", "mergeNested", "keys", "nestedSubset", "cb", "walkNestedSignal", "signalNames", "onlyPublic", "nestedValues", "shouldIndent", "values", "Dependency", "Signal", "val", "onChange", "sub", "subscribers", "Derived", "Dependency", "deps", "fn", "dep", "depsVersionSum", "args", "currentVal", "sub", "subscribers", "computed", "Effect", "effect", "e", "signals", "SignalsRoot", "actions", "plugins", "removals", "mutationObserver", "alias", "setAlias", "value", "load", "pluginsToLoad", "plugin", "ctx", "args", "cb", "effect", "applyToElement", "globalInitializer", "ap", "initErr", "a", "b", "lenDiff", "apply", "observe", "rootElement", "walkDOM", "el", "toApply", "elCleanups", "toCleanup", "hashes", "datasetKey", "datasetValue", "currentHash", "attrHash", "_", "cleanup", "key", "h", "applyAttributePlugin", "mutations", "toRemove", "target", "type", "addedNodes", "removedNodes", "node", "elTracking", "hash", "camelCasedKey", "rawKey", "camel", "p", "elUniqId", "rawModifiers", "hasKey", "hasValue", "genRX", "keyReq", "runtimeErr", "valReq", "rawMod", "label", "mod", "t", "argNames", "userExpression", "depSignalNames", "statementRe", "statements", "lastIdx", "last", "escaped", "escapeRe", "DSP", "DSS", "match", "k", "v", "Hash", "fnCall", "matches", "methodsCalled", "actionsRe", "signalNames", "signalsRe", "signalValueRe", "signalName", "deps", "signal", "fnContent", "fn", "error", "load", "Star", "Signals", "Computed", "getBytes", "stream", "onChunk", "reader", "result", "getLines", "onLine", "buffer", "position", "fieldLength", "discardTrailingNewline", "arr", "concat", "bufLength", "lineStart", "lineEnd", "getMessages", "onId", "onRetry", "onMessage", "message", "newMessage", "decoder", "line", "field", "valueOffset", "value", "retry", "a", "b", "res", "EventStreamContentType", "LastEventId", "fetchEventSource", "input", "inputSignal", "inputHeaders", "inputOnOpen", "onmessage", "onclose", "onerror", "openWhenHidden", "inputFetch", "retryInterval", "retryScaler", "retryMaxWaitMs", "retryMaxCount", "rest", "resolve", "reject", "retries", "headers", "curRequestController", "onVisibilityChange", "create", "retryTimer", "dispose", "fetch", "onopen", "response", "getBytes", "id", "err", "interval", "innerErr", "DATASTAR_SSE_EVENT", "DATASTAR", "STARTED", "FINISHED", "ERROR", "RETRYING", "datastarSSEEventWatcher", "eventType", "fn", "event", "argsRaw", "dispatchSSE", "el", "type", "argsRaw", "DATASTAR_SSE_EVENT", "isWrongContent", "err", "sse", "ctx", "method", "url", "args", "elId", "signals", "userHeaders", "contentType", "includeLocal", "selector", "openWhenHidden", "retryInterval", "retryScaler", "retryMaxWaitMs", "retryMaxCount", "abort", "DefaultSseRetryDurationMs", "action", "cleanupFn", "STARTED", "runtimeErr", "initialHeaders", "DATASTAR_REQUEST", "headers", "req", "response", "status", "ERROR", "evt", "DATASTAR", "argsRawLines", "lines", "line", "colonIndex", "key", "argLines", "value", "error", "RETRYING", "urlInstance", "queryParams", "json", "formEl", "preventDefault", "formData", "formParams", "fetchEventSource", "FINISHED", "DELETE", "ctx", "url", "args", "sse", "GET", "ctx", "url", "args", "sse", "PATCH", "ctx", "url", "args", "sse", "POST", "ctx", "url", "args", "sse", "PUT", "ctx", "url", "args", "sse", "Indicator", "el", "key", "mods", "signals", "value", "signalName", "modifyCasing", "trimDollarSignPrefix", "signal", "watcher", "event", "type", "elId", "STARTED", "FINISHED", "DATASTAR_SSE_EVENT", "ExecuteScript", "EventTypes", "ctx", "datastarSSEEventWatcher", "autoRemoveRaw", "DefaultExecuteScriptAutoRemove", "attributesRaw", "DefaultExecuteScriptAttributes", "script", "autoRemove", "isBoolString", "initErr", "scriptEl", "attr", "pivot", "key", "value", "docWithViewTransitionAPI", "supportsViewTransitions", "Idiomorph", "noOp", "defaults", "elt", "morph", "oldNode", "newContent", "config", "normalizeElement", "newNode", "normalizeParent", "ctx", "createMorphContext", "morphedNodes", "saveAndRestoreFocus", "withHeadBlocking", "morphChildren", "morphOuterHTML", "oldParent", "fn", "activeElement", "activeElementId", "selectionStart", "selectionEnd", "results", "newParent", "insertionPoint", "endPoint", "newChild", "bestMatch", "findBestMatch", "removeNodesBetween", "morphNode", "movedChild", "moveBeforeById", "insertedNode", "createNode", "tempNode", "removeNode", "newEmptyChild", "newClonedChild", "node", "startPoint", "softMatch", "nextSibling", "siblingSoftMatchCount", "cursor", "isSoftMatch", "isIdSetMatch", "oldSet", "newSet", "id", "oldElt", "newElt", "moveBefore", "startInclusive", "endExclusive", "parentNode", "after", "target", "removeElementFromAncestorsIdMaps", "element", "idSet", "handleHeadElement", "morphAttributes", "ignoreValueOfActiveElement", "type", "oldAttributes", "newAttributes", "newAttribute", "ignoreAttribute", "i", "oldAttribute", "syncInputValue", "oldElement", "newElement", "newValue", "oldValue", "syncBooleanAttribute", "attributeName", "newLiveValue", "oldLiveValue", "ignoreUpdate", "attr", "updateType", "possibleActiveElement", "callback", "oldHead", "newHead", "promises", "newCtx", "added", "removed", "preserved", "nodesToAppend", "srcToNewHeadNodes", "newHeadChild", "currentHeadElt", "inNewContent", "isReAppended", "isPreserved", "resolve", "promise", "_resolve", "removedElement", "persistentIds", "idMap", "createIdMaps", "mergedConfig", "mergeDefaults", "morphStyle", "createPantry", "finalConfig", "pantry", "findIdElements", "root", "elements", "populateIdMapWithTree", "current", "oldContent", "oldIdElements", "newIdElements", "createPersistentIds", "newRoot", "duplicateIds", "oldIdTagNameMap", "tagName", "generatedByIdiomorph", "content", "parseContent", "SlicedParentNode", "dummyParent", "nodes", "selector", "nodeList", "referenceNode", "parser", "contentWithSvgsRemoved", "htmlElement", "MergeFragments", "EventTypes", "ctx", "fragmentContainer", "datastarSSEEventWatcher", "fragmentsRaw", "selector", "mergeMode", "DefaultFragmentMergeMode", "useViewTransitionRaw", "DefaultFragmentsUseViewTransitions", "useViewTransition", "isBoolString", "fragments", "fragment", "initErr", "selectorOrID", "targets", "supportsViewTransitions", "docWithViewTransitionAPI", "applyToTargets", "capturedTargets", "target", "FragmentMergeModes", "fragmentWithIDs", "walkDOM", "el", "elUniqId", "elTracking", "newElTracking", "key", "cleanup", "newKey", "attrHash", "Idiomorph", "attrName", "value", "MergeSignals", "EventTypes", "ctx", "datastarSSEEventWatcher", "raw", "onlyIfMissingRaw", "DefaultMergeSignalsOnlyIfMissing", "signals", "onlyIfMissing", "isBoolString", "jsStrToObject", "RemoveFragments", "EventTypes", "ctx", "datastarSSEEventWatcher", "selector", "useViewTransitionRaw", "DefaultFragmentsUseViewTransitions", "initErr", "useViewTransition", "isBoolString", "removeTargets", "applyToTargets", "target", "supportsViewTransitions", "docWithViewTransitionAPI", "RemoveSignals", "EventTypes", "ctx", "datastarSSEEventWatcher", "pathsRaw", "paths", "p", "initErr", "Clipboard", "ctx", "text", "runtimeErr", "CustomValidity", "ctx", "el", "genRX", "effect", "runtimeErr", "deps", "rxFn", "result", "ONCE", "HALF", "FULL", "Intersects", "el", "rawKey", "mods", "genRX", "options", "rxFn", "observer", "entries", "entry", "tagToMs", "args", "arg", "tagHas", "tags", "tag", "defaultValue", "delay", "callback", "wait", "args", "debounce", "leading", "trailing", "timer", "resetTimer", "throttle", "waiting", "EVT", "SIGNALS_CHANGE_PREFIX", "signalChangeKeyLength", "On", "el", "key", "mods", "genRX", "rxFn", "target", "callback", "evt", "delayArgs", "wait", "tagToMs", "delay", "debounceArgs", "leading", "tagHas", "trailing", "debounce", "throttleArgs", "throttle", "supportsViewTransitions", "cb", "args", "evtListOpts", "duration", "durationArgs", "intervalId", "rafId", "raf", "hasPrefix", "signalPath", "modifyCasing", "camel", "signalFn", "event", "added", "removed", "updated", "d", "DATASTAR_SIGNAL_EVENT", "e", "targetHTML", "eventName", "kebab", "SESSION", "Persist", "key", "mods", "signals", "value", "modifyCasing", "DATASTAR", "storage", "paths", "p", "trimDollarSignPrefix", "storageToSignals", "data", "nestedValues", "signalsToStorage", "nv", "hasPrefix", "SIGNALS_CHANGE_PREFIX", "signalPath", "camel", "signalFn", "event", "added", "removed", "updated", "d", "DATASTAR_SIGNAL_EVENT", "ReplaceUrl", "effect", "genRX", "deps", "rxFn", "url", "baseUrl", "fullUrl", "SMOOTH", "INSTANT", "AUTO", "HSTART", "HCENTER", "HEND", "HNEAREST", "VSTART", "VCENTER", "VEND", "VNEAREST", "FOCUS", "CENTER", "START", "END", "NEAREST", "ScrollIntoView", "ctx", "el", "mods", "rawKey", "opts", "runtimeErr", "NONE", "DISPLAY", "Show", "s", "genRX", "effect", "deps", "rxFn", "VIEW_TRANSITION", "ViewTransition", "hasViewTransitionMeta", "node", "meta", "effect", "el", "genRX", "supportsViewTransitions", "deps", "rxFn", "name", "elVTASTyle", "Attr", "el", "key", "effect", "genRX", "deps", "rxFn", "binds", "val", "kebab", "value", "v", "dataURIRegex", "updateEvents", "Bind", "ctx", "el", "key", "mods", "signals", "value", "effect", "input", "signalName", "modifyCasing", "trimDollarSignPrefix", "tnl", "isInput", "isSelect", "type", "hasValueAttribute", "signalDefault", "isCheckbox", "isNumber", "isRadio", "isFile", "signal", "inserted", "arrayIndex", "isArray", "signalArray", "setElementFromSignal", "stringValue", "select", "runtimeErr", "opt", "incoming", "setSignalFromElement", "currentValue", "currentArray", "update", "newValue", "files", "allContents", "allMimes", "allNames", "f", "resolve", "reader", "match", "checked", "selectedOptions", "event", "onPageshow", "ev", "reset", "Class", "el", "key", "mods", "effect", "genRX", "cl", "deps", "rxFn", "classes", "k", "v", "classNames", "className", "kebab", "modifyCasing", "Ref", "el", "key", "mods", "signals", "value", "signalName", "modifyCasing", "trimDollarSignPrefix", "Text", "ctx", "el", "effect", "genRX", "deps", "rxFn", "runtimeErr", "res", "round", "max", "min", "Fit", "_", "v", "oldMin", "oldMax", "newMin", "newMax", "shouldClamp", "shouldRound", "fitted", "SetAll", "signals", "prefix", "newValue", "path", "signal", "ToggleAll", "signals", "prefix", "path", "signal", "load", "Attr", "Bind", "Class", "On", "Ref", "Show", "Text", "Indicator", "GET", "POST", "PUT", "PATCH", "DELETE", "MergeFragments", "MergeSignals", "RemoveFragments", "RemoveSignals", "ExecuteScript", "Clipboard", "CustomValidity", "Intersects", "Persist", "ReplaceUrl", "ScrollIntoView", "ViewTransition", "Fit", "SetAll", "ToggleAll", "apply"]
}
