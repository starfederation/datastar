{
  "version": 3,
  "sources": ["../library/src/engine/consts.ts", "../library/src/utils/paths.ts", "../library/src/utils/dom.ts", "../library/src/utils/text.ts", "../library/src/plugins/core/attributes/computed.ts", "../library/src/plugins/core/attributes/effect.ts", "../library/src/plugins/core/attributes/signals.ts", "../library/src/engine/errors.ts", "../library/src/engine/types.ts", "../library/src/engine/engine.ts", "../library/src/engine/index.ts", "../library/src/plugins/framework/actions/peek.ts", "../library/src/plugins/framework/actions/setAll.ts", "../library/src/plugins/framework/actions/toggleAll.ts", "../library/src/plugins/framework/attributes/attr.ts", "../library/src/plugins/framework/attributes/bind.ts", "../library/src/plugins/framework/attributes/class.ts", "../library/src/plugins/framework/backend/shared.ts", "../library/src/plugins/framework/attributes/indicator.ts", "../library/src/plugins/framework/attributes/jsonSignals.ts", "../library/src/utils/tags.ts", "../library/src/utils/timing.ts", "../library/src/utils/view-transitions.ts", "../library/src/plugins/framework/attributes/on.ts", "../library/src/plugins/framework/attributes/onIntersect.ts", "../library/src/plugins/framework/attributes/onInterval.ts", "../library/src/plugins/framework/attributes/onLoad.ts", "../library/src/plugins/framework/attributes/ref.ts", "../library/src/plugins/framework/attributes/scope.ts", "../library/src/plugins/framework/attributes/show.ts", "../library/src/plugins/framework/attributes/text.ts", "../library/src/plugins/framework/backend/actions/fetch.ts", "../library/src/plugins/framework/backend/actions/httpMethods.ts", "../library/src/plugins/framework/backend/actions/delete.ts", "../library/src/plugins/framework/backend/actions/get.ts", "../library/src/plugins/framework/backend/actions/patch.ts", "../library/src/plugins/framework/backend/actions/post.ts", "../library/src/plugins/framework/backend/actions/put.ts", "../library/src/plugins/framework/backend/watchers/patchElements.ts", "../library/src/plugins/framework/backend/watchers/patchSignals.ts", "../library/src/bundles/datastar.ts"],
  "sourcesContent": ["// This is auto-generated by Datastar. DO NOT EDIT.\nconst lol = /\uD83D\uDD95JS_DS\uD83D\uDE80/.source\nexport const DSP = lol.slice(0, 5)\nexport const DSS = lol.slice(4)\n\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_REQUEST = \"Datastar-Request\";\n\n// #region Defaults\n\n// #region Default durations\n\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000;\n\n// #endregion\n\n\n// #region Default strings\n\n\n// #endregion\n\n\n// #region Default booleans\n\n// Should elements be patched using the ViewTransition API?\nexport const DefaultElementsUseViewTransitions = false;\n\n// Should a given set of signals patch if they are missing?\nexport const DefaultPatchSignalsOnlyIfMissing = false;\n\n// #endregion\n\n\n// #region Enums\n\n// The mode in which a element is patched into the DOM.\n// Morphs the element into the existing element.\nexport const ElementPatchModeOuter = \"outer\"\n// Replaces the inner HTML of the existing element.\nexport const ElementPatchModeInner = \"inner\"\n// Removes the existing element.\nexport const ElementPatchModeRemove = \"remove\"\n// Replaces the existing element with the new element.\nexport const ElementPatchModeReplace = \"replace\"\n// Prepends the element inside to the existing element.\nexport const ElementPatchModePrepend = \"prepend\"\n// Appends the element inside the existing element.\nexport const ElementPatchModeAppend = \"append\"\n// Inserts the element before the existing element.\nexport const ElementPatchModeBefore = \"before\"\n// Inserts the element after the existing element.\nexport const ElementPatchModeAfter = \"after\"\n\n// Default value for ElementPatchMode\nexport const DefaultElementPatchMode = ElementPatchModeOuter;\n\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\n// An event for patching HTML elements into the DOM.\nexport const EventTypePatchElements = \"datastar-patch-elements\"\n// An event for patching signals.\nexport const EventTypePatchSignals = \"datastar-patch-signals\"\n// #endregion\n\n// #endregion", "export const isPojo = (obj: any): obj is Record<string, any> =>\n  obj !== null &&\n  typeof obj === 'object' &&\n  (Object.getPrototypeOf(obj) === Object.prototype ||\n    Object.getPrototypeOf(obj) === null)\n\nexport function isEmpty(obj: Record<string, any>): boolean {\n  for (const prop in obj) {\n    if (Object.hasOwn(obj, prop)) {\n      return false\n    }\n  }\n  return true\n}\n\nexport function updateLeaves(\n  obj: Record<string, any>,\n  fn: (oldValue: any) => any,\n) {\n  for (const key in obj) {\n    const val = obj[key]\n    if (isPojo(val) || Array.isArray(val)) {\n      updateLeaves(val, fn)\n    } else {\n      obj[key] = fn(val)\n    }\n  }\n}\n\nexport const pathToObj = (\n  target: Record<string, any>,\n  paths: Record<string, any>,\n): Record<string, any> => {\n  for (const path in paths) {\n    const keys = path.split('.')\n    const lastKey = keys.pop()!\n    const obj = keys.reduce((acc, key) => (acc[key] ??= {}), target)\n    obj[lastKey] = paths[path]\n  }\n  return target\n}\n", "import type { HTMLOrSVG } from '../engine/types'\n\nexport function isHTMLOrSVG(el: Node): el is HTMLOrSVG {\n  return el instanceof HTMLElement || el instanceof SVGElement\n}\n\nexport function findClosestScoped(el: HTMLOrSVG | null): string | null {\n  return (\n    (el?.closest('[data-scope]') as HTMLOrSVG | null)?.dataset.scope ?? null\n  )\n}\n", "import type { HTMLOrSVG, Modifiers } from '../engine/types'\nimport { findClosestScoped } from './dom'\n\nexport const isBoolString = (str: string) => str.trim() === 'true'\n\nexport const kebab = (str: string) =>\n  str\n    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')\n    .replace(/([a-z])([0-9]+)/gi, '$1-$2')\n    .replace(/([0-9]+)([a-z])/gi, '$1-$2')\n    .toLowerCase()\n\nexport const camel = (str: string) =>\n  kebab(str).replace(/-./g, (x) => x[1].toUpperCase())\n\nexport const snake = (str: string) => kebab(str).replace(/-/g, '_')\n\nexport const pascal = (str: string) =>\n  camel(str).replace(/(^.|(?<=\\.).)/g, (x) => x[0].toUpperCase())\n\nexport const jsStrToObject = (raw: string) => {\n  try {\n    return JSON.parse(raw)\n  } catch {\n    // If JSON parsing fails, try to evaluate as a JavaScript object\n    // This is less safe and should be used with caution\n    return Function(`return (${raw})`)()\n  }\n}\n\nconst caseFns: Record<string, (s: string) => string> = { kebab, snake, pascal }\n\nexport function modifyCasing(str: string, mods: Modifiers) {\n  for (const c of mods.get('case') || []) {\n    const fn = caseFns[c]\n    if (fn) str = fn(str)\n  }\n  return str\n}\n\nexport function modifyScope(\n  signalName: string,\n  el: HTMLOrSVG,\n  mods: Modifiers,\n) {\n  if (mods.has('scoped')) {\n    const scope = findClosestScoped(el)\n    if (scope) {\n      signalName = `${scope}.${signalName}`\n    }\n  }\n  return signalName\n}\n", "import type { AttributePlugin } from '../../../engine/types'\nimport { pathToObj } from '../../../utils/paths'\nimport { modifyCasing, modifyScope } from '../../../utils/text'\n\nexport const Computed: AttributePlugin = {\n  type: 'attribute',\n  name: 'computed',\n  keyReq: 'must',\n  valReq: 'must',\n  isExpr: true,\n  onLoad: ({ el, key, mods, rx, computed, mergePatch }) => {\n    let signalName = modifyCasing(key, mods)\n    signalName = modifyScope(signalName, el, mods)\n    mergePatch(pathToObj({}, { [signalName]: computed(rx) }))\n  },\n}\n", "import type { AttributePlugin } from '../../../engine/types'\n\nexport const Effect: AttributePlugin = {\n  type: 'attribute',\n  name: 'effect',\n  keyReq: 'denied',\n  valReq: 'must',\n  onLoad: ({ effect, rx }) => effect(rx),\n}\n", "import type { AttributePlugin } from '../../../engine/types'\nimport { pathToObj } from '../../../utils/paths'\nimport { modifyCasing, modifyScope } from '../../../utils/text'\n\nexport const Signals: AttributePlugin = {\n  type: 'attribute',\n  name: 'signals',\n  isExpr: true,\n  onLoad: ({ el, key, mods, rx, mergePatch }) => {\n    const ifMissing = mods.has('ifmissing')\n\n    if (key) {\n      key = modifyScope(modifyCasing(key, mods), el, mods)\n      mergePatch(pathToObj({}, { [key]: rx() }), { ifMissing })\n    } else {\n      const patch = rx<Record<string, any>>()\n      const pathObj: Record<string, any> = {}\n      for (const key in patch) {\n        pathObj[modifyScope(key, el, mods)] = patch[key]\n      }\n      mergePatch(pathToObj({}, pathObj), { ifMissing })\n    }\n  },\n}\n", "import { snake } from '../utils/text'\nimport { DATASTAR } from './consts'\nimport type { InitContext, RuntimeContext } from './types'\n\nconst url = 'https://data-star.dev/errors'\n\ninterface Metadata {\n  error?: string\n  [key: string]: any\n}\n\nfunction dserr(type: string, reason: string, metadata: Metadata = {}) {\n  const e = new Error()\n  e.name = `${DATASTAR} ${type} error`\n  const r = snake(reason)\n  const q = new URLSearchParams({\n    metadata: JSON.stringify(metadata),\n  }).toString()\n  const c = JSON.stringify(metadata, null, 2)\n  e.message = `${reason}\\nMore info: ${url}/${type}/${r}?${q}\\nContext: ${c}`\n  return e\n}\n\nexport function internalErr(from: string, reason: string, args = {}) {\n  return dserr('internal', reason, Object.assign({ from }, args))\n}\n\nexport function initErr(reason: string, ctx: InitContext, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: ctx.plugin.type,\n    },\n  }\n  return dserr('init', reason, Object.assign(errCtx, metadata))\n}\n\nexport function runtimeErr(ctx: RuntimeContext, reason: string, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: ctx.plugin.type,\n    },\n    element: {\n      id: ctx.el.id,\n      tag: ctx.el.tagName,\n    },\n    expression: {\n      rawKey: ctx.rawKey,\n      key: ctx.key,\n      value: ctx.value,\n      // validSignals:\n      fnContent: ctx.fnContent,\n    },\n  }\n  return dserr('runtime', reason, Object.assign(errCtx, metadata))\n}\n", "import { DATASTAR } from './consts'\nexport type PluginType = 'attribute' | 'watcher' | 'action'\nexport type Requirement = 'allowed' | 'must' | 'denied' | 'exclusive'\n\n// export type ReactiveNode = Signal | Computed | Effect\n// export type Subscriber = Computed | Effect\nexport type OnRemovalFn = () => void\n\nexport type DatastarPlugin = AttributePlugin | WatcherPlugin | ActionPlugin\n\nexport const DATASTAR_SIGNAL_PATCH_EVENT = `${DATASTAR}-signal-patch`\nexport type JSONPatch = Record<string, any>\n\nexport interface CustomEventMap {\n  [DATASTAR_SIGNAL_PATCH_EVENT]: CustomEvent<JSONPatch>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\ndeclare global {\n  interface Document {\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n  }\n}\n\n// A plugin accessible via a `data-${name}` attribute on an element\nexport type AttributePlugin = {\n  type: 'attribute'\n  name: string // The name of the plugin\n  onGlobalInit?: (ctx: InitContext) => void // Called once on registration of the plugin\n  onLoad: (ctx: RuntimeContext) => OnRemovalFn | void // Return a function to be called on removal\n  keyReq?: Requirement // The rules for the key requirements\n  valReq?: Requirement // The rules for the value requirements\n  isExpr?: boolean // If the value is an expression\n  argNames?: string[] // argument names for the reactive expression\n}\n\n// A plugin that runs on the global scope of the Datastar instance\nexport type WatcherPlugin = {\n  type: 'watcher'\n  name: string // The name of the plugin\n  onGlobalInit?: (ctx: InitContext) => void\n}\n\nexport type ActionPlugins = Record<string, ActionPlugin>\nexport type ActionMethod = (ctx: RuntimeContext, ...args: any[]) => any\n\nexport type ActionPlugin = {\n  type: 'action'\n  name: string // The name of the plugin\n  fn: ActionMethod\n}\n\nexport type GlobalInitializer = (ctx: InitContext) => void\n\nexport type InitContext = {\n  plugin: DatastarPlugin // The plugin instance\n  actions: Readonly<ActionPlugins> // All registered actions\n  root: Record<string, any> // global signals and computed signals\n  filtered: (opts?: SignalFilterOptions, obj?: JSONPatch) => Record<string, any>\n  signal<T>(initialValue?: T | undefined): Signal<T> // creates a signal\n  computed<T>(getter: (previousValue?: T) => T): Computed<T> // creates a computed signal\n  effect(fn: (...args: any[]) => void): OnRemovalFn // creates an effect\n  mergePatch: (patch: any, args?: { ifMissing?: boolean }) => any\n  peek: <T>(fn: () => T) => T // returns the current state of the signal without subscribing\n  getPath: <T = any>(path: string) => T // get a value from the root\n  hasPath: (path: string) => boolean // check if a path exists from the root\n  startBatch: () => void // starts a signal batch\n  endBatch: () => void // ends a signal batch\n}\n\nexport type HTMLOrSVG = Element & (HTMLElement | SVGElement)\nexport type Modifiers = Map<string, Set<string>> // mod name -> tags\nexport type ReactiveExpressionFn = <T>(...argsThenDeps: any[]) => T // a reactive expression\n\nexport type RuntimeContext = InitContext & {\n  el: HTMLOrSVG // The element the attribute is on\n  rawKey: Readonly<string> // no parsing data-* key\n  key: Readonly<string> // data-* key without the prefix or tags\n  value: Readonly<string> // value of data-* attribute\n  mods: Modifiers // the modifiers and their tags\n  rx: ReactiveExpressionFn // function to generate a reactive expression\n  fnContent?: string // the content of the function\n  evt?: Event // the event that triggered the plugin\n  runtimeErr: (reason: string, metadata?: object) => Error\n}\n\nexport type RuntimeExpressionFunction = (\n  ctx: RuntimeContext,\n  ...args: any[]\n) => any\n\nexport type EventCallbackHandler = (...args: any[]) => void\n\nexport type SignalFilter = RegExp\nexport type SignalFilterOptions = {\n  include?: RegExp\n  exclude?: RegExp\n}\n\nexport type Signal<T = any> = {\n  (): T\n  (value: T): boolean\n}\n\nexport type Computed<T = any> = () => T\n\nexport type Effect = () => void\n", "import { findClosestScoped, isHTMLOrSVG } from '../utils/dom'\nimport { isEmpty, isPojo, pathToObj } from '../utils/paths'\nimport { camel, snake } from '../utils/text'\nimport { DATASTAR, DSP, DSS } from './consts'\nimport { initErr, runtimeErr } from './errors'\nimport type {\n  ActionPlugins,\n  AttributePlugin,\n  Computed,\n  DatastarPlugin,\n  Effect,\n  HTMLOrSVG,\n  InitContext,\n  JSONPatch,\n  OnRemovalFn,\n  RuntimeContext,\n  RuntimeExpressionFunction,\n  Signal,\n  SignalFilterOptions,\n} from './types'\nimport { DATASTAR_SIGNAL_PATCH_EVENT } from './types'\n\n/**\n * Custom signals implementation based on Alien Signals\n */\n\ninterface ReactiveNode {\n  deps_?: Link\n  depsTail_?: Link\n  subs_?: Link\n  subsTail_?: Link\n  flags_: ReactiveFlags\n}\n\ninterface Link {\n  dep_: ReactiveNode\n  sub_: ReactiveNode\n  prevSub_?: Link\n  nextSub_?: Link\n  prevDep_?: Link\n  nextDep_?: Link\n}\n\ninterface Stack<T> {\n  value_: T\n  prev_?: Stack<T>\n}\n\nenum ReactiveFlags {\n  None = 0,\n  Mutable = 1 << 0,\n  Watching = 1 << 1,\n  RecursedCheck = 1 << 2,\n  Recursed = 1 << 3,\n  Dirty = 1 << 4,\n  Pending = 1 << 5,\n}\n\nenum EffectFlags {\n  Queued = 1 << 6,\n}\n\ninterface AlienEffect extends ReactiveNode {\n  fn_(): void\n}\n\ninterface AlienComputed<T = any> extends ReactiveNode {\n  value_?: T\n  getter(previousValue?: T): T\n}\n\ninterface AlienSignal<T = any> extends ReactiveNode {\n  previousValue: T\n  value_: T\n}\n\nlet currentPatch: Record<string, any> = {}\nconst queuedEffects: (AlienEffect | undefined)[] = []\nlet batchDepth = 0\nlet notifyIndex = 0\nlet queuedEffectsLength = 0\nlet activeSub: ReactiveNode | undefined\n\nconst startBatch = (): void => {\n  batchDepth++\n}\nconst endBatch = (): void => {\n  if (!--batchDepth) {\n    flush()\n    dispatch()\n  }\n}\n\nconst signal = <T>(initialValue?: T): Signal<T> => {\n  return signalOper.bind(0, {\n    previousValue: initialValue,\n    value_: initialValue,\n    flags_: 1 satisfies ReactiveFlags.Mutable,\n  }) as Signal<T>\n}\n\nconst computedSymbol = Symbol('computed')\nconst computed = <T>(getter: (previousValue?: T) => T): Computed<T> => {\n  const c = computedOper.bind(0, {\n    flags_: 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty,\n    getter,\n  }) as Computed<T>\n  // @ts-ignore\n  c[computedSymbol] = 1\n  return c\n}\n\nconst effect = (fn: () => void): Effect => {\n  const e: AlienEffect = {\n    fn_: fn,\n    flags_: 2 satisfies ReactiveFlags.Watching,\n  }\n  if (activeSub) {\n    link(e, activeSub)\n  }\n  const prev = setCurrentSub(e)\n  startBatch()\n  try {\n    e.fn_()\n  } finally {\n    endBatch()\n    setCurrentSub(prev)\n  }\n  return effectOper.bind(0, e)\n}\n\nconst peek = <T>(fn: () => T): T => {\n  const prev = setCurrentSub(undefined)\n  try {\n    return fn()\n  } finally {\n    setCurrentSub(prev)\n  }\n}\n\nconst flush = () => {\n  while (notifyIndex < queuedEffectsLength) {\n    const effect = queuedEffects[notifyIndex]!\n    queuedEffects[notifyIndex++] = undefined\n    run(effect, (effect.flags_ &= ~EffectFlags.Queued))\n  }\n  notifyIndex = 0\n  queuedEffectsLength = 0\n}\n\nconst update = (signal: AlienSignal | AlienComputed): boolean => {\n  if ('getter' in signal) {\n    return updateComputed(signal)\n  }\n  return updateSignal(signal, signal.value_)\n}\n\nconst setCurrentSub = (sub?: ReactiveNode): ReactiveNode | undefined => {\n  const prevSub = activeSub\n  activeSub = sub\n  return prevSub\n}\n\nconst updateComputed = (c: AlienComputed): boolean => {\n  const prevSub = setCurrentSub(c)\n  startTracking(c)\n  try {\n    const oldValue = c.value_\n    return oldValue !== (c.value_ = c.getter(oldValue))\n  } finally {\n    setCurrentSub(prevSub)\n    endTracking(c)\n  }\n}\n\nconst updateSignal = (s: AlienSignal, value: any): boolean => {\n  s.flags_ = 1 satisfies ReactiveFlags.Mutable\n  return s.previousValue !== (s.previousValue = value)\n}\n\nconst notify = (e: AlienEffect): void => {\n  const flags = e.flags_\n  if (!(flags & EffectFlags.Queued)) {\n    e.flags_ = flags | EffectFlags.Queued\n    const subs = e.subs_\n    if (subs) {\n      notify(subs.sub_ as AlienEffect)\n    } else {\n      queuedEffects[queuedEffectsLength++] = e\n    }\n  }\n}\n\nconst run = (e: AlienEffect, flags: ReactiveFlags): void => {\n  if (\n    flags & (16 satisfies ReactiveFlags.Dirty) ||\n    (flags & (32 satisfies ReactiveFlags.Pending) && checkDirty(e.deps_!, e))\n  ) {\n    const prev = setCurrentSub(e)\n    startTracking(e)\n    startBatch()\n    try {\n      e.fn_()\n    } finally {\n      endBatch()\n      setCurrentSub(prev)\n      endTracking(e)\n    }\n    return\n  }\n  if (flags & (32 satisfies ReactiveFlags.Pending)) {\n    e.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending)\n  }\n  let link = e.deps_\n  while (link) {\n    const dep = link.dep_\n    const depFlags = dep.flags_\n    if (depFlags & EffectFlags.Queued) {\n      run(dep as AlienEffect, (dep.flags_ = depFlags & ~EffectFlags.Queued))\n    }\n    link = link.nextDep_\n  }\n}\n\nconst computedOper = <T>(c: AlienComputed<T>): T => {\n  const flags = c.flags_\n  if (\n    flags & (16 satisfies ReactiveFlags.Dirty) ||\n    (flags & (32 satisfies ReactiveFlags.Pending) && checkDirty(c.deps_!, c))\n  ) {\n    if (updateComputed(c)) {\n      const subs = c.subs_\n      if (subs) {\n        shallowPropagate(subs)\n      }\n    }\n  } else if (flags & (32 satisfies ReactiveFlags.Pending)) {\n    c.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending)\n  }\n  if (activeSub) {\n    link(c, activeSub)\n  }\n  return c.value_!\n}\n\nconst signalOper = <T>(s: AlienSignal<T>, ...value: [T]): T | boolean => {\n  if (value.length) {\n    const newValue = value[0]\n    if (s.value_ !== (s.value_ = newValue)) {\n      s.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty\n      const subs = s.subs_\n      if (subs) {\n        propagate(subs)\n        if (!batchDepth) {\n          flush()\n        }\n      }\n      return true\n    }\n    return false\n  }\n  const currentValue = s.value_\n  if (s.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n    if (updateSignal(s, currentValue)) {\n      const subs_ = s.subs_\n      if (subs_) {\n        shallowPropagate(subs_)\n      }\n    }\n  }\n  if (activeSub) {\n    link(s, activeSub)\n  }\n  return currentValue\n}\n\nconst effectOper = (e: AlienEffect): void => {\n  let dep = e.deps_\n  while (dep) {\n    dep = unlink(dep, e)\n  }\n  const sub = e.subs_\n  if (sub) {\n    unlink(sub)\n  }\n  e.flags_ = 0 satisfies ReactiveFlags.None\n}\n\nconst link = (dep: ReactiveNode, sub: ReactiveNode): void => {\n  const prevDep = sub.depsTail_\n  if (prevDep && prevDep.dep_ === dep) {\n    return\n  }\n  let nextDep: Link | undefined\n  const recursedCheck = sub.flags_ & (4 satisfies ReactiveFlags.RecursedCheck)\n  if (recursedCheck) {\n    nextDep = prevDep ? prevDep.nextDep_ : sub.deps_\n    if (nextDep && nextDep.dep_ === dep) {\n      sub.depsTail_ = nextDep\n      return\n    }\n  }\n  const prevSub = dep.subsTail_\n  if (\n    prevSub &&\n    prevSub.sub_ === sub &&\n    (!recursedCheck || isValidLink(prevSub, sub))\n  ) {\n    return\n  }\n  const newLink =\n    (sub.depsTail_ =\n    dep.subsTail_ =\n      {\n        dep_: dep,\n        sub_: sub,\n        prevDep_: prevDep,\n        nextDep_: nextDep,\n        prevSub_: prevSub,\n      })\n  if (nextDep) {\n    nextDep.prevDep_ = newLink\n  }\n  if (prevDep) {\n    prevDep.nextDep_ = newLink\n  } else {\n    sub.deps_ = newLink\n  }\n  if (prevSub) {\n    prevSub.nextSub_ = newLink\n  } else {\n    dep.subs_ = newLink\n  }\n}\n\nconst unlink = (link: Link, sub_ = link.sub_): Link | undefined => {\n  const dep_ = link.dep_\n  const prevDep_ = link.prevDep_\n  const nextDep_ = link.nextDep_\n  const nextSub_ = link.nextSub_\n  const prevSub_ = link.prevSub_\n  if (nextDep_) {\n    nextDep_.prevDep_ = prevDep_\n  } else {\n    sub_.depsTail_ = prevDep_\n  }\n  if (prevDep_) {\n    prevDep_.nextDep_ = nextDep_\n  } else {\n    sub_.deps_ = nextDep_\n  }\n  if (nextSub_) {\n    nextSub_.prevSub_ = prevSub_\n  } else {\n    dep_.subsTail_ = prevSub_\n  }\n  if (prevSub_) {\n    prevSub_.nextSub_ = nextSub_\n  } else if (!(dep_.subs_ = nextSub_)) {\n    if ('getter' in dep_) {\n      let toRemove = dep_.deps_\n      if (toRemove) {\n        dep_.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty\n        do {\n          toRemove = unlink(toRemove, dep_)\n        } while (toRemove)\n      }\n    } else if (!('previousValue' in dep_)) {\n      effectOper(dep_ as AlienEffect)\n    }\n  }\n  return nextDep_\n}\n\nconst propagate = (link: Link): void => {\n  let next = link.nextSub_\n  let stack: Stack<Link | undefined> | undefined\n\n  top: while (true) {\n    const sub = link.sub_\n\n    let flags = sub.flags_\n\n    if (flags & (3 as ReactiveFlags.Mutable | ReactiveFlags.Watching)) {\n      if (\n        !(\n          flags &\n          (60 as\n            | ReactiveFlags.RecursedCheck\n            | ReactiveFlags.Recursed\n            | ReactiveFlags.Dirty\n            | ReactiveFlags.Pending)\n        )\n      ) {\n        sub.flags_ = flags | (32 satisfies ReactiveFlags.Pending)\n      } else if (\n        !(flags & (12 as ReactiveFlags.RecursedCheck | ReactiveFlags.Recursed))\n      ) {\n        flags = 0 satisfies ReactiveFlags.None\n      } else if (!(flags & (4 satisfies ReactiveFlags.RecursedCheck))) {\n        sub.flags_ =\n          (flags & ~(8 satisfies ReactiveFlags.Recursed)) |\n          (32 satisfies ReactiveFlags.Pending)\n      } else if (\n        !(flags & (48 as ReactiveFlags.Dirty | ReactiveFlags.Pending)) &&\n        isValidLink(link, sub)\n      ) {\n        sub.flags_ =\n          flags | (40 as ReactiveFlags.Recursed | ReactiveFlags.Pending)\n        flags &= 1 satisfies ReactiveFlags.Mutable\n      } else {\n        flags = 0 satisfies ReactiveFlags.None\n      }\n\n      if (flags & (2 satisfies ReactiveFlags.Watching)) {\n        notify(sub as AlienEffect)\n      }\n\n      if (flags & (1 satisfies ReactiveFlags.Mutable)) {\n        const subSubs = sub.subs_\n        if (subSubs) {\n          link = subSubs\n          if (subSubs.nextSub_) {\n            stack = { value_: next, prev_: stack }\n            next = link.nextSub_\n          }\n          continue\n        }\n      }\n    }\n\n    if ((link = next!)) {\n      next = link.nextSub_\n      continue\n    }\n\n    while (stack) {\n      link = stack.value_!\n      stack = stack.prev_\n      if (link) {\n        next = link.nextSub_\n        continue top\n      }\n    }\n\n    break\n  }\n}\n\nconst startTracking = (sub: ReactiveNode): void => {\n  sub.depsTail_ = undefined\n  sub.flags_ =\n    (sub.flags_ &\n      ~(56 as\n        | ReactiveFlags.Recursed\n        | ReactiveFlags.Dirty\n        | ReactiveFlags.Pending)) |\n    (4 satisfies ReactiveFlags.RecursedCheck)\n}\n\nconst endTracking = (sub: ReactiveNode): void => {\n  const depsTail_ = sub.depsTail_\n  let toRemove = depsTail_ ? depsTail_.nextDep_ : sub.deps_\n  while (toRemove) {\n    toRemove = unlink(toRemove, sub)\n  }\n  sub.flags_ &= ~(4 satisfies ReactiveFlags.RecursedCheck)\n}\n\nconst checkDirty = (link: Link, sub: ReactiveNode): boolean => {\n  let stack: Stack<Link> | undefined\n  let checkDepth = 0\n\n  top: while (true) {\n    const dep = link.dep_\n    const depFlags = dep.flags_\n\n    let dirty = false\n\n    if (sub.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n      dirty = true\n    } else if (\n      (depFlags & (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)) ===\n      (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)\n    ) {\n      if (update(dep as AlienSignal | AlienComputed)) {\n        const subs = dep.subs_!\n        if (subs.nextSub_) {\n          shallowPropagate(subs)\n        }\n        dirty = true\n      }\n    } else if (\n      (depFlags & (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)) ===\n      (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)\n    ) {\n      if (link.nextSub_ || link.prevSub_) {\n        stack = { value_: link, prev_: stack }\n      }\n      link = dep.deps_!\n      sub = dep\n      ++checkDepth\n      continue\n    }\n\n    if (!dirty && link.nextDep_) {\n      link = link.nextDep_\n      continue\n    }\n\n    while (checkDepth) {\n      --checkDepth\n      const firstSub = sub.subs_!\n      const hasMultipleSubs = firstSub.nextSub_\n      if (hasMultipleSubs) {\n        link = stack!.value_\n        stack = stack!.prev_\n      } else {\n        link = firstSub\n      }\n      if (dirty) {\n        if (update(sub as AlienSignal | AlienComputed)) {\n          if (hasMultipleSubs) {\n            shallowPropagate(firstSub)\n          }\n          sub = link.sub_\n          continue\n        }\n      } else {\n        sub.flags_ &= ~(32 satisfies ReactiveFlags.Pending)\n      }\n      sub = link.sub_\n      if (link.nextDep_) {\n        link = link.nextDep_\n        continue top\n      }\n      dirty = false\n    }\n\n    return dirty\n  }\n}\n\nconst shallowPropagate = (link: Link): void => {\n  do {\n    const sub = link.sub_\n    const nextSub = link.nextSub_\n    const subFlags = sub.flags_\n    if (\n      (subFlags & (48 as ReactiveFlags.Pending | ReactiveFlags.Dirty)) ===\n      (32 satisfies ReactiveFlags.Pending)\n    ) {\n      sub.flags_ = subFlags | (16 satisfies ReactiveFlags.Dirty)\n      if (subFlags & (2 satisfies ReactiveFlags.Watching)) {\n        notify(sub as AlienEffect)\n      }\n    }\n    link = nextSub!\n  } while (link)\n}\n\nconst isValidLink = (checkLink: Link, sub: ReactiveNode): boolean => {\n  const depsTail = sub.depsTail_\n  if (depsTail) {\n    let link = sub.deps_!\n    do {\n      if (link === checkLink) {\n        return true\n      }\n      if (link === depsTail) {\n        break\n      }\n      link = link.nextDep_!\n    } while (link)\n  }\n  return false\n}\n\nconst getPath = <T = any>(path: string): T =>\n  path.split('.').reduce((acc, key) => acc[key], root) as T\n\nconst hasPath = (path: string): boolean =>\n  peek(\n    () =>\n      path\n        .split('.')\n        .reduce(\n          (obj, key) => (obj && Object.hasOwn(obj, key) ? obj[key] : undefined),\n          root,\n        ) !== undefined,\n  )\n\nconst deep = (value: any, prefix = ''): any => {\n  const isArr = Array.isArray(value)\n  if (isArr || isPojo(value)) {\n    const deepObj = (isArr ? [] : {}) as Record<string, Signal>\n    for (const key in value) {\n      deepObj[key] = signal(\n        deep((value as Record<string, Signal>)[key], `${prefix + key}.`),\n      )\n    }\n    const keys = signal(0)\n    return new Proxy(deepObj, {\n      get: (_, prop: string) => {\n        if (prop === 'toJSON' && !Object.hasOwn(deepObj, prop)) {\n          return\n        }\n        if (isArr && prop in Array.prototype) {\n          keys()\n          return deepObj[prop]\n        }\n        if (!Object.hasOwn(deepObj, prop)) {\n          deepObj[prop] = signal('')\n          dispatch({ [prefix + prop]: '' })\n          keys(keys() + 1)\n        }\n        return deepObj[prop]()\n      },\n      set: (_, prop: string, newValue) => {\n        if (isArr && prop === 'length') {\n          deepObj[prop] = newValue\n          dispatch({ [prefix.slice(0, -1)]: deepObj })\n          keys(keys() + 1)\n          return true\n        }\n\n        if (Object.hasOwn(deepObj, prop)) {\n          if (newValue === null || newValue === undefined) {\n            delete deepObj[prop]\n            dispatch({ [prefix + prop]: null })\n            keys(keys() + 1)\n            return true\n          }\n          if (deepObj[prop](deep(newValue, `${prefix + prop}.`))) {\n            dispatch({ [prefix + prop]: newValue })\n          }\n        } else {\n          if (newValue === null || newValue === undefined) {\n            return true\n          }\n          if (Object.hasOwn(newValue, computedSymbol)) {\n            deepObj[prop] = newValue\n            dispatch({ [prefix + prop]: '' })\n          } else {\n            deepObj[prop] = signal(deep(newValue, `${prefix + prop}.`))\n            dispatch({ [prefix + prop]: newValue })\n          }\n\n          keys(keys() + 1)\n        }\n\n        return true\n      },\n      deleteProperty: (_, prop: string) => {\n        if (Object.hasOwn(deepObj, prop)) {\n          delete deepObj[prop]\n          dispatch({ [prefix + prop]: null })\n          keys(keys() + 1)\n        }\n\n        return true\n      },\n      ownKeys: () => {\n        keys()\n        return Reflect.ownKeys(deepObj)\n      },\n      has(_, prop) {\n        keys()\n        return prop in deepObj\n      },\n    })\n  }\n  return value\n}\n\nconst dispatch = (obj?: Record<string, any>) => {\n  if (obj) {\n    pathToObj(currentPatch, obj)\n  }\n  if (!batchDepth && !isEmpty(currentPatch)) {\n    const oldPatch = currentPatch\n    currentPatch = {}\n    document.dispatchEvent(\n      new CustomEvent<JSONPatch>(DATASTAR_SIGNAL_PATCH_EVENT, {\n        detail: oldPatch,\n      }),\n    )\n  }\n}\n\nconst mergePatch = (\n  patch: Record<string, any>,\n  { ifMissing }: { ifMissing?: boolean } = {},\n): void => {\n  startBatch()\n  for (const key in patch) {\n    if (patch[key] === null || patch[key] === undefined) {\n      if (!ifMissing) {\n        delete root[key]\n      }\n    } else {\n      mergeInner(patch[key], key, root, '', ifMissing)\n    }\n  }\n  endBatch()\n}\n\nconst mergeInner = (\n  patch: any,\n  target: string,\n  targetParent: Record<string, any>,\n  prefix: string,\n  ifMissing: boolean | undefined,\n): void => {\n  if (isPojo(patch)) {\n    if (\n      !(\n        Object.hasOwn(targetParent, target) &&\n        (isPojo(targetParent[target]) || Array.isArray(targetParent[target]))\n      )\n    ) {\n      targetParent[target] = {}\n    }\n\n    for (const key in patch) {\n      if (patch[key] === null || patch[key] === undefined) {\n        if (!ifMissing) {\n          delete targetParent[target][key]\n        }\n      } else {\n        mergeInner(\n          patch[key],\n          key,\n          targetParent[target],\n          `${prefix + target}.`,\n          ifMissing,\n        )\n      }\n    }\n  } else if (!(ifMissing && Object.hasOwn(targetParent, target))) {\n    targetParent[target] = patch\n  }\n}\n\nfunction filtered(\n  { include = /.*/, exclude = /(?!)/ }: SignalFilterOptions = {},\n  obj: JSONPatch = root,\n) {\n  // We need to find all valid signal paths in the object\n  const pathObj: Record<string, any> = {}\n  const stack: Array<[any, string]> = [[obj, '']]\n\n  while (stack.length) {\n    const [node, prefix] = stack.pop()!\n\n    for (const key in node) {\n      if (isPojo(node[key])) {\n        stack.push([node[key], `${prefix + key}.`])\n      } else if (include.test(prefix + key) && !exclude.test(prefix + key)) {\n        pathObj[prefix + key] = getPath(prefix + key)\n      }\n    }\n  }\n\n  return pathToObj({}, pathObj)\n}\n\nconst root: Record<string, any> = deep({})\n\n/**\n * Turn data-* attributes into reactive expressions\n * This is the core of the Datastar\n */\n\nconst actions: ActionPlugins = {}\nconst plugins: AttributePlugin[] = []\nlet pluginRegexs: RegExp[] = []\n\n// Map of cleanup functions by element, keyed by a dataset key-value hash\nconst removals = new Map<HTMLOrSVG, Map<string, OnRemovalFn>>()\n\nlet mutationObserver: MutationObserver | null = null\n\nlet alias = ''\nexport function setAlias(value: string) {\n  alias = value\n}\nexport function aliasify(name: string) {\n  return alias ? `data-${alias}-${name}` : `data-${name}`\n}\n\nexport function load(...pluginsToLoad: DatastarPlugin[]) {\n  for (const plugin of pluginsToLoad) {\n    const ctx: InitContext = {\n      plugin,\n      actions,\n      root,\n      filtered,\n      signal,\n      computed,\n      effect,\n      mergePatch,\n      peek,\n      getPath,\n      hasPath,\n      startBatch,\n      endBatch,\n    }\n    if (plugin.type === 'action') {\n      actions[plugin.name] = plugin\n    } else if (plugin.type === 'attribute') {\n      plugins.push(plugin)\n      plugin.onGlobalInit?.(ctx)\n    } else if (plugin.type === 'watcher') {\n      plugin.onGlobalInit?.(ctx)\n    } else {\n      throw initErr('InvalidPluginType', ctx)\n    }\n  }\n\n  // Sort attribute plugins by descending length then alphabetically\n  plugins.sort((a, b) => {\n    const lenDiff = b.name.length - a.name.length\n    if (lenDiff !== 0) return lenDiff\n    return a.name.localeCompare(b.name)\n  })\n\n  pluginRegexs = plugins.map((plugin) => RegExp(`^${plugin.name}([A-Z]|_|$)`))\n}\n\nfunction applyEls(els: Iterable<HTMLOrSVG>): void {\n  const ignore = `[${aliasify('ignore')}]`\n  for (const el of els) {\n    if (!el.closest(ignore)) {\n      for (const key in el.dataset) {\n        applyAttributePlugin(el, key, el.dataset[key]!)\n      }\n    }\n  }\n}\n\n// Apply all plugins to the entire DOM or a provided element\nexport function apply(root: HTMLOrSVG = document.body) {\n  // Delay applying plugins to give custom plugins a chance to load\n  queueMicrotask(() => {\n    applyEls([root])\n    applyEls(root.querySelectorAll<HTMLOrSVG>('*'))\n\n    // Monitor the entire document body or a provided element for changes\n    // https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe\n    if (!mutationObserver) {\n      mutationObserver = new MutationObserver(observe)\n      mutationObserver.observe(root, {\n        subtree: true,\n        childList: true,\n        attributes: true,\n      })\n    }\n  })\n}\n\nfunction applyAttributePlugin(\n  el: HTMLOrSVG,\n  attrKey: string,\n  value: string,\n): void {\n  const rawKey = camel(alias ? attrKey.slice(alias.length) : attrKey)\n  const plugin = plugins.find((_, i) => pluginRegexs[i].test(rawKey))\n  if (plugin) {\n    // Extract the key and modifiers\n    let [key, ...rawModifiers] = rawKey.slice(plugin.name.length).split(/__+/)\n\n    const hasKey = !!key\n    if (hasKey) {\n      key = camel(key)\n    }\n    const hasValue = !!value\n\n    // Create the runtime context\n    const ctx: RuntimeContext = {\n      plugin,\n      actions,\n      root,\n      filtered,\n      signal,\n      computed,\n      effect,\n      mergePatch,\n      peek,\n      getPath,\n      hasPath,\n      startBatch,\n      endBatch,\n      el,\n      rawKey,\n      key,\n      value,\n      mods: new Map(),\n      runtimeErr: 0 as any,\n      rx: 0 as any,\n    }\n    ctx.runtimeErr = runtimeErr.bind(0, ctx)\n    ctx.rx = generateReactiveExpression(ctx)\n\n    // Check the requirements\n    const keyReq = plugin.keyReq || 'allowed'\n    if (hasKey) {\n      if (keyReq === 'denied') {\n        throw ctx.runtimeErr(`${plugin.name}KeyNotAllowed`)\n      }\n    } else if (keyReq === 'must') {\n      throw ctx.runtimeErr(`${plugin.name}KeyRequired`)\n    }\n\n    const valReq = plugin.valReq || 'allowed'\n    if (hasValue) {\n      if (valReq === 'denied') {\n        throw ctx.runtimeErr(`${plugin.name}ValueNotAllowed`)\n      }\n    } else if (valReq === 'must') {\n      throw ctx.runtimeErr(`${plugin.name}ValueRequired`)\n    }\n\n    // Check for exclusive requirements\n    if (keyReq === 'exclusive' || valReq === 'exclusive') {\n      if (hasKey && hasValue) {\n        throw ctx.runtimeErr(`${plugin.name}KeyAndValueProvided`)\n      }\n      if (!hasKey && !hasValue) {\n        throw ctx.runtimeErr(`${plugin.name}KeyOrValueRequired`)\n      }\n    }\n\n    for (const rawMod of rawModifiers) {\n      const [label, ...mod] = rawMod.split('.')\n      ctx.mods.set(camel(label), new Set(mod.map((t) => t.toLowerCase())))\n    }\n\n    const cleanup = plugin.onLoad(ctx)\n    if (cleanup) {\n      let cleanups = removals.get(el)\n      if (cleanups) {\n        cleanups.get(rawKey)?.()\n      } else {\n        cleanups = new Map()\n        removals.set(el, cleanups)\n      }\n      cleanups.set(rawKey, cleanup)\n    }\n  }\n}\n\n// Set up a mutation observer to run plugin removal and apply functions\nfunction observe(mutations: MutationRecord[]) {\n  const ignore = `[${aliasify('ignore')}]`\n\n  for (const {\n    target,\n    type,\n    attributeName,\n    addedNodes,\n    removedNodes,\n  } of mutations) {\n    if (type === 'childList') {\n      for (const node of removedNodes) {\n        if (isHTMLOrSVG(node)) {\n          const cleanups = removals.get(node)\n          // If removals has el, delete it and run all cleanup functions\n          if (removals.delete(node)) {\n            for (const cleanup of cleanups!.values()) {\n              cleanup()\n            }\n            cleanups!.clear()\n          }\n        }\n      }\n\n      for (const node of addedNodes) {\n        if (isHTMLOrSVG(node)) {\n          applyEls([node])\n          applyEls(node.querySelectorAll<HTMLOrSVG>('*'))\n        }\n      }\n    } else if (type === 'attributes') {\n      // If el has a parent with data-ignore, skip it\n      if (isHTMLOrSVG(target) && !target.closest(ignore)) {\n        const key = camel(attributeName!.slice(5))\n        const value = target.getAttribute(attributeName!)\n        if (value === null) {\n          const cleanups = removals.get(target)\n          if (cleanups) {\n            cleanups.get(key)?.()\n            cleanups.delete(key)\n          }\n        } else {\n          applyAttributePlugin(target, key, value)\n        }\n      }\n    }\n  }\n}\n\nfunction generateReactiveExpression(\n  ctx: RuntimeContext,\n): RuntimeExpressionFunction {\n  let expr = ''\n\n  const attrPlugin = (ctx.plugin as AttributePlugin) || undefined\n\n  // plugin is guaranteed to be an attribute plugin\n  if (attrPlugin?.isExpr) {\n    // This regex allows Datastar expressions to support nested\n    // regex and strings that contain ; without breaking.\n    //\n    // Each of these regex defines a block type we want to match\n    // (importantly we ignore the content within these blocks):\n    //\n    // regex            \\/(\\\\\\/|[^\\/])*\\/\n    // double quotes      \"(\\\\\"|[^\\\"])*\"\n    // single quotes      '(\\\\'|[^'])*'\n    // ticks              `(\\\\`|[^`])*`\n    // iife               \\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;)\\{]*)\\s*\\)\\s*\\(\\s*\\)\n    //\n    // The iife support is (intentionally) limited. It only supports\n    // function and arrow syntax with no arguments, and no nested IIFEs.\n    //\n    // We also want to match the non delimiter part of statements\n    // note we only support ; statement delimiters:\n    //\n    // [^;]\n    //\n    const statementRe =\n      /(\\/(\\\\\\/|[^/])*\\/|\"(\\\\\"|[^\"])*\"|'(\\\\'|[^'])*'|`(\\\\`|[^`])*`|\\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;){]*)\\s*\\)\\s*\\(\\s*\\)|[^;])+/gm\n    const statements = ctx.value.trim().match(statementRe)\n    if (statements) {\n      const lastIdx = statements.length - 1\n      const last = statements[lastIdx].trim()\n      if (!last.startsWith('return')) {\n        statements[lastIdx] = `return (${last});`\n      }\n      expr = statements.join(';\\n')\n    }\n  } else {\n    expr = ctx.value.trim()\n  }\n\n  // Handle $$ syntax - converts $$signal to $context.signal for context signals\n  expr = expr.replace(\n    // Regex: matches $$ followed by valid signal names (including nested like $$foo.bar)\n    /\\$\\$([a-zA-Z_][\\w.-]*(?:\\.[a-zA-Z_][\\w.-]*)*?)(?=\\s|$|[^\\w.-])/g,\n    // s = captured signal name after $$\n    (_, s) => {\n      const scope = findClosestScoped(ctx.el)\n      return scope ? `$${scope}.${s}` : `$${s}` // if no scope: $signal for global scope\n    },\n  )\n\n  expr = expr.replace(\n    /\\$([a-zA-Z_][\\w.-]*(?:\\.[a-zA-Z_][\\w.-]*)*?)(?=\\s|$|[^\\w.-])/g,\n    (match, signalName) => {\n      // If the signal name ends with a hyphen followed by a $, it's likely two separate signals\n      // So we should not include the trailing hyphen in this signal name\n      if (\n        signalName.endsWith('-') &&\n        match.length < expr.length &&\n        expr[expr.indexOf(match) + match.length] === '$'\n      ) {\n        signalName = signalName.slice(0, -1)\n        const parts = signalName.split('.')\n        return `${parts.reduce((acc: string, part: string) => `${acc}['${part}']`, '$')}-`\n      }\n\n      const parts = signalName.split('.')\n      return parts.reduce(\n        (acc: string, part: string) => `${acc}['${part}']`,\n        '$',\n      )\n    },\n  )\n\n  // Ignore any escaped values\n  const escaped = new Map<string, string>()\n  const escapeRe = RegExp(`(?:${DSP})(.*?)(?:${DSS})`, 'gm')\n  for (const match of expr.matchAll(escapeRe)) {\n    const k = match[1]\n    const v = `dsEscaped${djb2(k)}`\n    escaped.set(v, k)\n    expr = expr.replace(DSP + k + DSS, v)\n  }\n\n  const nameGen = (prefix: string, name: string) => {\n    return `${prefix}${snake(name).replaceAll(/\\./g, '_')}`\n  }\n\n  // Replace any action calls\n  const actionsCalled = new Set<string>()\n  const actionsRe = RegExp(`@(${Object.keys(actions).join('|')})\\\\(`, 'gm')\n  const actionMatches = [...expr.matchAll(actionsRe)]\n  const actionNames = new Set<string>()\n  const actionFns = new Set<(...args: any[]) => any>()\n  if (actionMatches.length) {\n    const actionPrefix = `${DATASTAR}Act_`\n    for (const match of actionMatches) {\n      const actionName = match[1]\n      const action = actions[actionName]\n      if (!action) {\n        continue\n      }\n      actionsCalled.add(actionName)\n\n      const name = nameGen(actionPrefix, actionName)\n\n      // Add ctx to action calls\n      expr = expr.replace(`@${actionName}(`, `${name}(`)\n      actionNames.add(name)\n      actionFns.add((...args: any[]) => action.fn(ctx, ...args))\n    }\n  }\n\n  // Replace any escaped values\n  for (const [k, v] of escaped) {\n    expr = expr.replace(k, v)\n  }\n\n  ctx.fnContent = expr\n\n  try {\n    const fn = Function(\n      'el',\n      '$',\n      ...(attrPlugin?.argNames || []),\n      ...actionNames,\n      expr,\n    )\n    return (...args: any[]) => {\n      try {\n        return fn(ctx.el, root, ...args, ...actionFns)\n      } catch (e: any) {\n        throw ctx.runtimeErr('ExecuteExpression', {\n          error: e.message,\n        })\n      }\n    }\n  } catch (error: any) {\n    throw ctx.runtimeErr('GenerateExpression', {\n      error: error.message,\n    })\n  }\n}\n\nfunction djb2(str: string) {\n  let hash = 5831\n  let i = str.length\n  while (i--) {\n    hash += (hash << 5) + str.charCodeAt(i)\n  }\n  return (hash >>> 0).toString(36)\n}\n", "import { DSP } from '../engine/consts'\n\n// @ts-ignore\nconst _ = DSP // This is to force the import of DSP first in the compiled code\n\nimport { Computed } from '../plugins/core/attributes/computed'\nimport { Effect } from '../plugins/core/attributes/effect'\nimport { Signals } from '../plugins/core/attributes/signals'\nimport { apply, load, setAlias } from './engine'\n\nload(Signals, Computed, Effect)\n\nexport { apply, load, setAlias }\n", "// Icon: ion:eye\n// Slug: Peek at signals that match the signal path\n// Description: Use a signal or computed signal without subscribing to it.\n\nimport type { ActionPlugin } from '../../../engine/types'\n\nexport const Peek: ActionPlugin = {\n  type: 'action',\n  name: 'peek',\n  fn: ({ peek }, fn: () => any) => {\n    return peek(fn)\n  },\n}\n", "// Icon: ion:checkmark-round\n// Slug: Set all signals that match the signal path\n// Description: Set all signals that match one or more space-separated paths in which `*` can be used as a wildcard\n\nimport type {\n  ActionPlugin,\n  RuntimeContext,\n  SignalFilterOptions,\n} from '../../../engine/types'\nimport { updateLeaves } from '../../../utils/paths'\n\nexport const SetAll: ActionPlugin = {\n  type: 'action',\n  name: 'setAll',\n  fn: (\n    { filtered, mergePatch, peek }: RuntimeContext,\n    value: any,\n    filter: SignalFilterOptions,\n  ) => {\n    peek(() => {\n      const masked = filtered(filter)\n      updateLeaves(masked, () => value)\n      mergePatch(masked)\n    })\n  },\n}\n", "// Icon: material-symbols:toggle-off\n// Slug: Toggle all signals that match the signal path\n// Description: Toggle all signals that match one or more space-separated paths in which `*` can be used as a wildcard\n\nimport type {\n  ActionPlugin,\n  RuntimeContext,\n  SignalFilterOptions,\n} from '../../../engine/types'\nimport { updateLeaves } from '../../../utils/paths'\n\nexport const ToggleAll: ActionPlugin = {\n  type: 'action',\n  name: 'toggleAll',\n  fn: (\n    { filtered, mergePatch, peek }: RuntimeContext,\n    filter: SignalFilterOptions,\n  ) => {\n    peek(() => {\n      const masked = filtered(filter)\n      updateLeaves(masked, (oldValue: any) => !oldValue)\n      mergePatch(masked)\n    })\n  },\n}\n", "// Icon: material-symbols:edit-attributes-outline\n// Slug: Bind attributes to expressions\n// Description: Any attribute can be bound to an expression. The attribute will be updated reactively whenever the expression signal changes.\n\nimport type { AttributePlugin } from '../../../engine/types'\nimport { kebab } from '../../../utils/text'\n\nexport const Attr: AttributePlugin = {\n  type: 'attribute',\n  name: 'attr',\n  valReq: 'must',\n  isExpr: true,\n  onLoad: ({ el, effect, key, rx }) => {\n    const syncAttr = (key: string, val: any) => {\n      if (val === '' || val === true) {\n        el.setAttribute(key, '')\n      } else if (val === false || val === null || val === undefined) {\n        el.removeAttribute(key)\n      } else {\n        el.setAttribute(key, val)\n      }\n    }\n    if (key === '') {\n      const observer = new MutationObserver(() => {\n        observer.disconnect()\n        const obj = rx() as Record<string, any>\n        for (const [key, val] of Object.entries(obj)) {\n          syncAttr(key, val)\n        }\n        observer.observe(el, {\n          attributeFilter: Object.keys(obj),\n        })\n      })\n      const cleanup = effect(() => {\n        observer.disconnect()\n        const obj = rx() as Record<string, any>\n        for (const key in obj) {\n          syncAttr(key, obj[key])\n        }\n        observer.observe(el, {\n          attributeFilter: Object.keys(obj),\n        })\n      })\n\n      return () => {\n        observer.disconnect()\n        cleanup()\n      }\n    }\n    // Attributes are always kebab-case\n    const k = kebab(key)\n    const observer = new MutationObserver(() => {\n      observer.disconnect()\n      const value = rx<string>()\n      syncAttr(k, value)\n      observer.observe(el, {\n        attributeFilter: [value],\n      })\n    })\n    const cleanup = effect(() => {\n      observer.disconnect()\n      const value = rx<string>()\n      syncAttr(k, value)\n      observer.observe(el, {\n        attributeFilter: [value],\n      })\n    })\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n", "// Icon: akar-icons:link-chain\n// Slug: Bind attributes to expressions\n// Description: Any attribute can be bound to an expression. The attribute will be updated reactively whenever the expression signal changes.\n\nimport { aliasify } from '../../../engine/engine'\nimport type { AttributePlugin } from '../../../engine/types'\nimport { pathToObj } from '../../../utils/paths'\nimport { modifyCasing, modifyScope } from '../../../utils/text'\n\nconst dataURIRegex = /^data:(?<mime>[^;]+);base64,(?<contents>.*)$/\nconst textType = /email|password|search|tel|text|url/\nconst numberType = /number|range/\n\nexport const Bind: AttributePlugin = {\n  type: 'attribute',\n  name: 'bind',\n  keyReq: 'exclusive',\n  valReq: 'exclusive',\n  onLoad: ({\n    el,\n    key,\n    mods,\n    value,\n    effect,\n    mergePatch,\n    runtimeErr,\n    getPath,\n    hasPath,\n  }) => {\n    let signalName = key ? modifyCasing(key, mods) : value\n    signalName = modifyScope(signalName, el, mods)\n\n    if (\n      (el instanceof HTMLInputElement && textType.test(el.type)) ||\n      el instanceof HTMLTextAreaElement\n    ) {\n      if (Array.isArray(hasPath(signalName) && getPath(signalName))) {\n        // For array signals, determine this input's index based on DOM order\n        const scopedModifier = mods.has('scoped') ? '__scoped' : ''\n        const allBoundInputs = document.querySelectorAll(\n          `[${aliasify('bind')}${scopedModifier}-${key}],[${aliasify('bind')}${scopedModifier}=\"${value}\"]`,\n        )\n\n        let inputIndex = 0\n        const pathObj: Record<string, string> = {}\n        for (const input of allBoundInputs) {\n          if (!hasPath(`${signalName}.${inputIndex}`)) {\n            pathObj[`${signalName}.${inputIndex}`] = (\n              input as HTMLInputElement\n            ).value\n          }\n\n          if (el === input) {\n            break\n          }\n          inputIndex++\n        }\n        mergePatch(pathToObj({}, pathObj))\n\n        const syncSignal = () => {\n          mergePatch(\n            pathToObj({}, { [`${signalName}.${inputIndex}`]: el.value }),\n          )\n        }\n\n        el.addEventListener('change', syncSignal)\n        el.addEventListener('input', syncSignal)\n\n        const cleanup = effect(\n          () => (el.value = getPath(signalName)[inputIndex]),\n        )\n\n        return () => {\n          cleanup()\n          el.removeEventListener('change', syncSignal)\n          el.removeEventListener('input', syncSignal)\n        }\n      }\n\n      // Non-array signal handling\n      mergePatch(pathToObj({}, { [signalName]: el.value }), { ifMissing: true })\n\n      const syncSignal = () =>\n        mergePatch(pathToObj({}, { [signalName]: el.value }))\n      el.addEventListener('change', syncSignal)\n      el.addEventListener('input', syncSignal)\n\n      const cleanup = effect(() => (el.value = getPath(signalName)))\n\n      return () => {\n        cleanup()\n        el.removeEventListener('change', syncSignal)\n        el.removeEventListener('input', syncSignal)\n      }\n    }\n\n    if (el instanceof HTMLInputElement) {\n      if (el.type === 'checkbox') {\n        if (Array.isArray(hasPath(signalName) && getPath(signalName))) {\n          // For array signals, determine this input's index based on DOM order\n          const scopedModifier = mods.has('scoped') ? '__scoped' : ''\n          const allBoundInputs = document.querySelectorAll(\n            `[${aliasify('bind')}${scopedModifier}-${key}],[${aliasify('bind')}${scopedModifier}=\"${value}\"]`,\n          )\n\n          let inputIndex = 0\n          const pathObj: Record<string, string | boolean> = {}\n          for (const input of allBoundInputs) {\n            if (!hasPath(`${signalName}.${inputIndex}`)) {\n              const val = input.getAttribute('value')\n              pathObj[`${signalName}.${inputIndex}`] = val\n                ? (input as HTMLInputElement).checked\n                  ? val\n                  : ''\n                : (input as HTMLInputElement).checked\n            }\n\n            if (el === input) {\n              break\n            }\n            inputIndex++\n          }\n          mergePatch(pathToObj({}, pathObj))\n\n          const syncSignal = () => {\n            const val = el.getAttribute('value')\n            mergePatch(\n              pathToObj(\n                {},\n                {\n                  [`${signalName}.${inputIndex}`]: val\n                    ? el.checked\n                      ? val\n                      : ''\n                    : el.checked,\n                },\n              ),\n            )\n          }\n\n          el.addEventListener('change', syncSignal)\n          el.addEventListener('input', syncSignal)\n\n          const cleanup = effect(() => {\n            const val = el.getAttribute('value')\n            el.checked = val\n              ? val === getPath(signalName)[inputIndex]\n              : getPath(signalName)[inputIndex]\n          })\n\n          return () => {\n            cleanup()\n            el.removeEventListener('change', syncSignal)\n            el.removeEventListener('input', syncSignal)\n          }\n        }\n\n        const val = el.getAttribute('value')\n        mergePatch(\n          pathToObj(\n            {},\n            { [signalName]: val ? (el.checked ? val : '') : el.checked },\n          ),\n        )\n\n        const syncSignal = () => {\n          const val = el.getAttribute('value')\n          mergePatch(\n            pathToObj(\n              {},\n              { [signalName]: val ? (el.checked ? val : '') : el.checked },\n            ),\n          )\n        }\n        el.addEventListener('change', syncSignal)\n        el.addEventListener('input', syncSignal)\n\n        const cleanup = effect(() => {\n          const val = el.getAttribute('value')\n          el.checked = val ? val === getPath(signalName) : getPath(signalName)\n        })\n\n        return () => {\n          cleanup()\n          el.removeEventListener('change', syncSignal)\n          el.removeEventListener('input', syncSignal)\n        }\n      }\n\n      if (el.type === 'radio') {\n        // Set up radio button name attribute if not present\n        if (!el.getAttribute('name')?.length) {\n          el.setAttribute('name', signalName)\n        }\n\n        mergePatch(pathToObj({}, { [signalName]: el.value }), {\n          ifMissing: true,\n        })\n\n        const syncSignal = () =>\n          el.checked && mergePatch(pathToObj({}, { [signalName]: el.value }))\n        el.addEventListener('change', syncSignal)\n        el.addEventListener('input', syncSignal)\n\n        const cleanup = effect(\n          () => (el.checked = el.value === getPath(signalName)),\n        )\n\n        return () => {\n          cleanup()\n          el.removeEventListener('change', syncSignal)\n          el.removeEventListener('input', syncSignal)\n        }\n      }\n\n      if (numberType.test(el.type)) {\n        mergePatch(pathToObj({}, { [signalName]: +el.value }), {\n          ifMissing: true,\n        })\n\n        const syncSignal = () =>\n          mergePatch(pathToObj({}, { [signalName]: +el.value }))\n        el.addEventListener('change', syncSignal)\n        el.addEventListener('input', syncSignal)\n\n        const cleanup = effect(() => (el.value = getPath(signalName)))\n\n        return () => {\n          cleanup()\n          el.removeEventListener('change', syncSignal)\n          el.removeEventListener('input', syncSignal)\n        }\n      }\n\n      if (el.type === 'file') {\n        const syncSignal = () => {\n          const files = [...(el.files || [])]\n          const allContents: string[] = []\n          const allMimes: string[] = []\n          const allNames: string[] = []\n          Promise.all(\n            files.map(\n              (f) =>\n                new Promise<void>((resolve) => {\n                  const reader = new FileReader()\n                  reader.onload = () => {\n                    if (typeof reader.result !== 'string') {\n                      throw runtimeErr('InvalidFileResultType', {\n                        resultType: typeof reader.result,\n                      })\n                    }\n                    const match = reader.result.match(dataURIRegex)\n                    if (!match?.groups) {\n                      throw runtimeErr('InvalidDataUri', {\n                        result: reader.result,\n                      })\n                    }\n                    allContents.push(match.groups.contents)\n                    allMimes.push(match.groups.mime)\n                    allNames.push(f.name)\n                  }\n                  reader.onloadend = () => resolve()\n                  reader.readAsDataURL(f)\n                }),\n            ),\n          ).then(() => {\n            mergePatch(\n              pathToObj(\n                {},\n                {\n                  [signalName]: allContents,\n                  [`${signalName}Mimes`]: allMimes,\n                  [`${signalName}Names`]: allNames,\n                },\n              ),\n            )\n          })\n        }\n\n        el.addEventListener('change', syncSignal)\n        el.addEventListener('input', syncSignal)\n\n        return () => {\n          el.removeEventListener('change', syncSignal)\n          el.removeEventListener('input', syncSignal)\n        }\n      }\n      // else unsupported type\n    }\n\n    if (el instanceof HTMLSelectElement) {\n      if (el.multiple) {\n        // Multi-select handling\n        mergePatch(\n          pathToObj(\n            {},\n            {\n              [signalName]: [...el.selectedOptions].map(\n                (option) => option.value,\n              ),\n            },\n          ),\n          {\n            ifMissing: true,\n          },\n        )\n\n        const syncSignal = () =>\n          mergePatch(\n            pathToObj(\n              {},\n              {\n                [signalName]: [...el.selectedOptions].map(\n                  (option) => option.value,\n                ),\n              },\n            ),\n          )\n        el.addEventListener('change', syncSignal)\n        el.addEventListener('input', syncSignal)\n\n        const cleanup = effect(() => {\n          const signalValue: string[] = getPath(signalName)\n          for (const option of el.options) {\n            option.selected = signalValue.includes(option.value)\n          }\n        })\n\n        return () => {\n          cleanup()\n          el.removeEventListener('change', syncSignal)\n          el.removeEventListener('input', syncSignal)\n        }\n      }\n\n      // Single-select handling\n      mergePatch(\n        pathToObj(\n          {},\n          {\n            [signalName]: el.value,\n          },\n        ),\n        {\n          ifMissing: true,\n        },\n      )\n\n      const syncSignal = () =>\n        mergePatch(\n          pathToObj(\n            {},\n            {\n              [signalName]: el.value,\n            },\n          ),\n        )\n      el.addEventListener('change', syncSignal)\n      el.addEventListener('input', syncSignal)\n\n      const syncElement = () => (el.value = getPath(signalName))\n      const cleanup = effect(syncElement)\n\n      return () => {\n        cleanup()\n        el.removeEventListener('change', syncSignal)\n        el.removeEventListener('input', syncSignal)\n      }\n    }\n\n    mergePatch(\n      pathToObj(\n        {},\n        {\n          [signalName]: el.getAttribute('value'),\n        },\n      ),\n      { ifMissing: true },\n    )\n\n    const observer = new MutationObserver(() => {\n      mergePatch(\n        pathToObj(\n          {},\n          {\n            [signalName]: el.getAttribute('value'),\n          },\n        ),\n      )\n    })\n    observer.observe(el, {\n      attributeFilter: ['value'],\n    })\n\n    const cleanup = effect(() => el.setAttribute('value', getPath(signalName)))\n\n    return () => {\n      cleanup()\n      observer.disconnect()\n    }\n  },\n}\n", "// Icon: ic:baseline-format-paint\n// Slug: Add or remove classes from an element reactively\n// Description: This action adds or removes classes from an element reactively based on the expression provided. The expression should be an object where the keys are the class names and the values are booleans. If the value is true, the class is added. If the value is false, the class is removed.\n\nimport type { AttributePlugin } from '../../../engine/types'\nimport { kebab, modifyCasing } from '../../../utils/text'\n\nexport const Class: AttributePlugin = {\n  type: 'attribute',\n  name: 'class',\n  valReq: 'must',\n  isExpr: true,\n  onLoad: ({ key, el, effect, mods, rx }) => {\n    // Track classes added by this attribute\n    const addedClasses = new Set<string>()\n    let isUpdating = false\n\n    // Watch for external class changes (e.g., from morphing)\n    const observer = new MutationObserver(() => {\n      if (!isUpdating) {\n        // External change detected, clear our tracking\n        addedClasses.clear()\n      }\n    })\n\n    const cleanup = effect(() => {\n      isUpdating = true\n      observer.disconnect()\n\n      // Remove all previously added classes\n      for (const className of addedClasses) {\n        el.classList.remove(className)\n      }\n      addedClasses.clear()\n\n      // Get classes - either from object expression or single key\n      const classes = key === '' \n        ? rx<Record<string, boolean>>()\n        : { [modifyCasing(kebab(key), mods)]: rx<boolean>() }\n\n      // Add new classes and track them\n      for (const [k, v] of Object.entries(classes)) {\n        // We don't remove classes when v is false because\n        // we're already removing ALL previously added classes above\n        if (v) {\n          const classNames = k.split(/\\s+/).filter((cn) => cn.length > 0)\n          for (const className of classNames) {\n            el.classList.add(className)\n            addedClasses.add(className)\n          }\n        }\n      }\n\n      isUpdating = false\n      observer.observe(el, { attributeFilter: ['class'] })\n    })\n\n    return () => {\n      observer.disconnect()\n      // Clean up by removing all tracked classes\n      for (const className of addedClasses) {\n        el.classList.remove(className)\n      }\n      cleanup()\n    }\n  },\n}\n", "import { DATASTAR } from '../../../engine/consts'\nimport type { HTMLOrSVG } from '../../../engine/types'\n\nexport const DATASTAR_SSE_EVENT = `${DATASTAR}-sse`\nexport const STARTED = 'started'\nexport const FINISHED = 'finished'\nexport const ERROR = 'error'\nexport const RETRYING = 'retrying'\nexport const RETRIES_FAILED = 'retrying'\n\nexport interface DatastarSSEEvent {\n  type: string\n  el: HTMLOrSVG\n  argsRaw: Record<string, string>\n}\n\nexport interface CustomEventMap {\n  [DATASTAR_SSE_EVENT]: CustomEvent<DatastarSSEEvent>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\n\ndeclare global {\n  interface Document {\n    //adds definition to Document, but you can do the same with HTMLElement\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n  }\n}\n\nexport function datastarSSEEventWatcher(\n  eventType: string,\n  fn: (argsRaw: Record<string, string>) => void,\n) {\n  document.addEventListener(\n    DATASTAR_SSE_EVENT,\n    (event: CustomEvent<DatastarSSEEvent>) => {\n      if (event.detail.type === eventType) {\n        const { argsRaw } = event.detail\n        fn(argsRaw)\n      }\n    },\n  )\n}\n", "// Icon: material-symbols:network-wifi\n// Slug: Sets the indicator signal used when fetching data via SSE\n// Description: must be a valid signal name\n\nimport type { AttributePlugin } from '../../../engine/types'\nimport { pathToObj } from '../../../utils/paths'\nimport { modifyCasing, modifyScope } from '../../../utils/text'\nimport {\n  DATASTAR_SSE_EVENT,\n  type DatastarSSEEvent,\n  FINISHED,\n  STARTED,\n} from '../backend/shared'\n\nexport const Indicator: AttributePlugin = {\n  type: 'attribute',\n  name: 'indicator',\n  keyReq: 'exclusive',\n  valReq: 'exclusive',\n  onLoad: ({ el, key, mods, mergePatch, value }) => {\n    let signalName = key ? modifyCasing(key, mods) : value\n    signalName = modifyScope(signalName, el, mods)\n\n    mergePatch(pathToObj({}, { [signalName]: false }), { ifMissing: true })\n\n    const watcher = ((event: CustomEvent<DatastarSSEEvent>) => {\n      const { type, el: elt } = event.detail\n      if (elt !== el) {\n        return\n      }\n      switch (type) {\n        case STARTED:\n          mergePatch(pathToObj({}, { [signalName]: true }))\n          break\n        case FINISHED:\n          mergePatch(pathToObj({}, { [signalName]: false }))\n          break\n      }\n    }) as EventListener\n    document.addEventListener(DATASTAR_SSE_EVENT, watcher)\n    return () => {\n      mergePatch(pathToObj({}, { [signalName]: false }))\n      document.removeEventListener(DATASTAR_SSE_EVENT, watcher)\n    }\n  },\n}\n", "// Icon: tabler:typography\n// Slug: Set the text content of an element to a reactive JSON stringified version of all signals\n// Description: This attribute sets the text content of an element to a reactive JSON stringified version of all signals.\n\nimport type {\n  AttributePlugin,\n  SignalFilterOptions,\n} from '../../../engine/types'\nimport { jsStrToObject } from '../../../utils/text'\n\nexport const JsonSignals: AttributePlugin = {\n  type: 'attribute',\n  name: 'jsonSignals',\n  keyReq: 'denied',\n  onLoad: ({ el, effect, value, filtered, mods }) => {\n    const spaces = mods.has('terse') ? 0 : 2\n    let filters: SignalFilterOptions = {}\n    if (value) {\n      filters = jsStrToObject(value)\n    }\n\n    const callback = () => {\n      observer.disconnect()\n      el.textContent = JSON.stringify(filtered(filters), null, spaces)\n      observer.observe(el, {\n        childList: true,\n      })\n    }\n    const observer = new MutationObserver(callback)\n    const cleanup = effect(callback)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n", "export function tagToMs(args: Set<string>) {\n  if (!args || args.size <= 0) return 0\n  for (const arg of args) {\n    if (arg.endsWith('ms')) {\n      return +arg.replace('ms', '')\n    }\n    if (arg.endsWith('s')) {\n      return +arg.replace('s', '') * 1000\n    }\n    try {\n      return Number.parseFloat(arg)\n    } catch (_) {}\n  }\n  return 0\n}\n\nexport function tagHas(tags: Set<string>, tag: string, defaultValue = false) {\n  if (!tags) return defaultValue\n  return tags.has(tag.toLowerCase())\n}\n\nexport function tagFirst(tags?: Set<string>, defaultValue = ''): string {\n  if (tags && tags.size > 0) {\n    for (const tag of tags) {\n      return tag\n    }\n  }\n  return defaultValue\n}\n", "import type { EventCallbackHandler, Modifiers } from '../engine/types'\nimport { tagHas, tagToMs } from './tags'\n\nexport function delay(\n  callback: EventCallbackHandler,\n  wait: number,\n): EventCallbackHandler {\n  return (...args: any[]) => {\n    setTimeout(() => {\n      callback(...args)\n    }, wait)\n  }\n}\n\nexport function debounce(\n  callback: EventCallbackHandler,\n  wait: number,\n  leading = false,\n  trailing = true,\n): EventCallbackHandler {\n  let timer = 0\n  return (...args: any[]) => {\n    timer && clearTimeout(timer)\n\n    if (leading && !timer) {\n      callback(...args)\n    }\n\n    timer = setTimeout(() => {\n      if (trailing) {\n        callback(...args)\n      }\n      timer && clearTimeout(timer)\n    }, wait)\n  }\n}\n\nexport function throttle(\n  callback: EventCallbackHandler,\n  wait: number,\n  leading = true,\n  trailing = false,\n): EventCallbackHandler {\n  let waiting = false\n\n  return (...args: any[]) => {\n    if (waiting) return\n\n    if (leading) {\n      callback(...args)\n    }\n\n    waiting = true\n    setTimeout(() => {\n      waiting = false\n      if (trailing) {\n        callback(...args)\n      }\n    }, wait)\n  }\n}\n\nexport function modifyTiming(\n  callback: EventCallbackHandler,\n  mods: Modifiers,\n): EventCallbackHandler {\n  const delayArgs = mods.get('delay')\n  if (delayArgs) {\n    const wait = tagToMs(delayArgs)\n    callback = delay(callback, wait)\n  }\n\n  const debounceArgs = mods.get('debounce')\n  if (debounceArgs) {\n    const wait = tagToMs(debounceArgs)\n    const leading = tagHas(debounceArgs, 'leading', false)\n    const trailing = !tagHas(debounceArgs, 'notrail', false)\n    callback = debounce(callback, wait, leading, trailing)\n  }\n\n  const throttleArgs = mods.get('throttle')\n  if (throttleArgs) {\n    const wait = tagToMs(throttleArgs)\n    const leading = !tagHas(throttleArgs, 'noleading', false)\n    const trailing = tagHas(throttleArgs, 'trail', false)\n    callback = throttle(callback, wait, leading, trailing)\n  }\n\n  return callback\n}\n", "import type { EventCallbackHandler, Modifiers } from '../engine/types'\n\nexport interface DocumentSupportingViewTransitionAPI {\n  startViewTransition(\n    updateCallback: () => Promise<void> | void,\n  ): IViewTransition\n}\n\nexport interface IViewTransition {\n  finished: Promise<void>\n  ready: Promise<void>\n  updateCallbackDone: Promise<void>\n  skipTransition(): void\n}\n\nexport const supportsViewTransitions = !!document.startViewTransition\n\nexport function modifyViewTransition(\n  callback: EventCallbackHandler,\n  mods: Modifiers,\n): EventCallbackHandler {\n  if (mods.has('viewtransition') && supportsViewTransitions) {\n    const cb = callback // I hate javascript\n    callback = (...args: any[]) =>\n      document.startViewTransition(() => cb(...args))\n  }\n\n  return callback\n}\n", "// Icon: material-symbols:mail\n// Slug: Add an event listener to an element\n// Description: This plugin adds an event listener to an element. The event listener can be triggered by a variety of events, such as clicks, keypresses, and more. The event listener can also be set to trigger only once, or to be passive or capture. The event listener can also be debounced or throttled. The event listener can also be set to trigger only when the event target is outside the element.\n\nimport {\n  type AttributePlugin,\n  DATASTAR_SIGNAL_PATCH_EVENT,\n} from '../../../engine/types'\nimport { kebab, modifyCasing } from '../../../utils/text'\nimport { modifyTiming } from '../../../utils/timing'\nimport { modifyViewTransition } from '../../../utils/view-transitions'\nimport { DATASTAR_SSE_EVENT } from '../backend/shared'\n\nexport const On: AttributePlugin = {\n  type: 'attribute',\n  name: 'on',\n  keyReq: 'must',\n  valReq: 'must',\n  argNames: ['evt'],\n  onLoad: (ctx) => {\n    const { el, key, mods, rx, startBatch, endBatch } = ctx\n    let target: Element | Window | Document = el\n    if (mods.has('window')) target = window\n    let callback = (evt?: Event) => {\n      if (evt) {\n        if (mods.has('prevent')) {\n          evt.preventDefault()\n        }\n        if (mods.has('stop')) {\n          evt.stopPropagation()\n        }\n        // Return if not a trusted event, not a custom event and no `trust` modifier exists\n        if (\n          !(evt.isTrusted || evt instanceof CustomEvent || mods.has('trust'))\n        ) {\n          return\n        }\n        ctx.evt = evt\n      }\n      startBatch()\n      rx(evt)\n      endBatch()\n    }\n    callback = modifyTiming(callback, mods)\n    callback = modifyViewTransition(callback, mods)\n    const evtListOpts: AddEventListenerOptions = {\n      capture: mods.has('capture'),\n      passive: mods.has('passive'),\n      once: mods.has('once'),\n    }\n    if (mods.has('outside')) {\n      target = document\n      const cb = callback\n      callback = (evt?: Event) => {\n        if (!el.contains(evt?.target as HTMLElement)) {\n          cb(evt)\n        }\n      }\n    }\n    // Default to kebab-case and allow modifying\n    let eventName = kebab(key)\n    eventName = modifyCasing(eventName, mods)\n    // Listen for Datastar events on the document\n    if (\n      eventName === DATASTAR_SSE_EVENT ||\n      eventName === DATASTAR_SIGNAL_PATCH_EVENT\n    ) {\n      target = document\n    }\n    // Prevent default on form submit events\n    if (el instanceof HTMLFormElement && eventName === 'submit') {\n      const cb = callback\n      callback = (evt?: Event) => {\n        evt?.preventDefault()\n        cb(evt)\n      }\n    }\n    target.addEventListener(eventName, callback, evtListOpts)\n    return () => {\n      target.removeEventListener(eventName, callback)\n    }\n  },\n}\n", "// Icon: mdi-light:vector-intersection\n// Slug: Runs an expression when an element intersects with the viewport\n// Description: An attribute that runs an expression when an element intersects with the viewport.\n\nimport type { AttributePlugin, HTMLOrSVG } from '../../../engine/types'\nimport { modifyTiming } from '../../../utils/timing'\nimport { modifyViewTransition } from '../../../utils/view-transitions'\n\nconst once = new WeakSet<HTMLOrSVG>()\n\nexport const OnIntersect: AttributePlugin = {\n  type: 'attribute',\n  name: 'onIntersect',\n  keyReq: 'denied',\n  onLoad: ({ el, mods, rx, startBatch, endBatch }) => {\n    let callback = () => {\n      startBatch()\n      rx()\n      endBatch()\n    }\n    callback = modifyTiming(callback, mods)\n    callback = modifyViewTransition(callback, mods)\n    const options = { threshold: 0 }\n    if (mods.has('full')) {\n      options.threshold = 1\n    } else if (mods.has('half')) {\n      options.threshold = 0.5\n    }\n    let observer: IntersectionObserver | null = new IntersectionObserver(\n      (entries) => {\n        for (const entry of entries) {\n          if (entry.isIntersecting) {\n            callback()\n            if (observer && once.has(el)) {\n              observer.disconnect()\n            }\n          }\n        }\n      },\n      options,\n    )\n    observer.observe(el)\n    if (mods.has('once')) {\n      once.add(el)\n    }\n    return () => {\n      if (!mods.has('once')) {\n        once.delete(el)\n      }\n      if (observer) {\n        observer.disconnect()\n        observer = null\n      }\n    }\n  },\n}\n", "// Icon: material-symbols:timer-outline\n// Slug: Runs an expression on an interval\n// Description: This attribute runs an expression on an interval. The interval can be set to a specific duration, and can be set to trigger immediately.\n\nimport type { AttributePlugin } from '../../../engine/types'\nimport { tagHas, tagToMs } from '../../../utils/tags'\nimport { modifyViewTransition } from '../../../utils/view-transitions'\n\nexport const OnInterval: AttributePlugin = {\n  type: 'attribute',\n  name: 'onInterval',\n  keyReq: 'denied',\n  valReq: 'must',\n  onLoad: ({ mods, rx, startBatch, endBatch }) => {\n    let callback = () => {\n      startBatch()\n      rx()\n      endBatch()\n    }\n    callback = modifyViewTransition(callback, mods)\n    let duration = 1000\n    const durationArgs = mods.get('duration')\n    if (durationArgs) {\n      duration = tagToMs(durationArgs)\n      const leading = tagHas(durationArgs, 'leading', false)\n      if (leading) {\n        callback()\n      }\n    }\n    const intervalId = setInterval(callback, duration)\n    return () => {\n      clearInterval(intervalId)\n    }\n  },\n}\n", "// Icon: material-symbols:timer-play-outline\n// Slug: Runs an expression when the element is loaded\n// Description: This attribute runs an expression when the element is loaded.\n\nimport type { AttributePlugin } from '../../../engine/types'\nimport { tagToMs } from '../../../utils/tags'\nimport { delay } from '../../../utils/timing'\nimport { modifyViewTransition } from '../../../utils/view-transitions'\n\nexport const OnLoad: AttributePlugin = {\n  type: 'attribute',\n  name: 'onLoad',\n  keyReq: 'denied',\n  valReq: 'must',\n  onLoad: ({ rx, mods, startBatch, endBatch }) => {\n    let callback = () => {\n      startBatch()\n      rx()\n      endBatch()\n    }\n    callback = modifyViewTransition(callback, mods)\n    let wait = 0\n    const delayArgs = mods.get('delay')\n    if (delayArgs) {\n      wait = tagToMs(delayArgs)\n    }\n    // Delay the callback regardless of whether the modifier is set so that other plugins are processed first.\n    callback = delay(callback, wait)\n    callback()\n  },\n}\n", "// Icon: mdi:cursor-pointer\n// Slug: Create a reference to an element\n// Description: This attribute creates a reference to an element that can be used in other expressions.\n\nimport type { AttributePlugin } from '../../../engine/types'\nimport { pathToObj } from '../../../utils/paths'\nimport { modifyCasing, modifyScope } from '../../../utils/text'\n\n// Sets the value of the element\nexport const Ref: AttributePlugin = {\n  type: 'attribute',\n  name: 'ref',\n  keyReq: 'exclusive',\n  valReq: 'exclusive',\n  onLoad: ({ el, key, mods, value, mergePatch }) => {\n    let signalName = key ? modifyCasing(key, mods) : value\n    signalName = modifyScope(signalName, el, mods)\n\n    mergePatch(pathToObj({}, { [signalName]: el }))\n  },\n}\n", "// Icon: tabler:box\n// Slug: Create a scope for scoped signals\n// Description: This attribute creates a scope for scoping data to specific DOM elements.\n\nimport type { AttributePlugin } from '../../../engine/types'\nimport { modifyScope } from '../../../utils/text'\n\nexport const Scope: AttributePlugin = {\n  type: 'attribute',\n  name: 'scope',\n  keyReq: 'denied',\n  onLoad: ({ el, value, mods, mergePatch }) => {\n    let scopeKey = value || `_${crypto.randomUUID()}`\n\n    if (el.parentElement) {\n      scopeKey = modifyScope(scopeKey, el.parentElement, mods)\n    }\n\n    const scopeKeyObj = scopeKey\n      .split('.')\n      .reduceRight<any>((acc, part) => ({ [part]: acc }), {})\n    mergePatch(scopeKeyObj)\n\n    el.setAttribute('data-scope', scopeKey)\n    el.removeAttribute('data-scope__scoped')\n\n    return () => {\n      const parts = scopeKey.split('.')\n      const removalObj = parts.reduceRight<any>(\n        (acc, part) => ({ [part]: acc }),\n        null,\n      )\n      mergePatch(removalObj)\n    }\n  },\n}\n", "// Icon: streamline:interface-edit-view-eye-eyeball-open-view\n// Slug: Show or hide an element\n// Description: This attribute shows or hides an element based on the value of the expression. If the expression is true, the element is shown. If the expression is false, the element is hidden. The element is hidden by setting the display property to none.\n\nimport type { AttributePlugin } from '../../../engine/types'\n\nconst NONE = 'none'\nconst DISPLAY = 'display'\n\nexport const Show: AttributePlugin = {\n  type: 'attribute',\n  name: 'show',\n  keyReq: 'denied',\n  valReq: 'must',\n  isExpr: true,\n  onLoad: ({ el, effect, rx }) => {\n    const update = () => {\n      observer.disconnect()\n      const shouldShow = rx()\n      if (shouldShow) {\n        if (el.style.display === NONE) el.style.removeProperty(DISPLAY)\n      } else {\n        el.style.setProperty(DISPLAY, NONE)\n      }\n      observer.observe(el, { attributeFilter: ['style'] })\n    }\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n", "// Icon: tabler:typography\n// Slug: Set the text content of an element\n// Description: This attribute sets the text content of an element to the result of the expression.\n\nimport type { AttributePlugin } from '../../../engine/types'\n\nexport const Text: AttributePlugin = {\n  type: 'attribute',\n  name: 'text',\n  keyReq: 'denied',\n  valReq: 'must',\n  isExpr: true,\n  onLoad: ({ el, effect, rx }) => {\n    const update = () => {\n      observer.disconnect()\n      el.textContent = `${rx()}`\n      observer.observe(el, { childList: true })\n    }\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n", "// Icon: ic:baseline-get-app\n// Slug: Use a GET request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DATASTAR,\n  DATASTAR_REQUEST,\n  DefaultSseRetryDurationMs,\n  EventTypePatchElements,\n  EventTypePatchSignals,\n} from '../../../../engine/consts'\nimport type {\n  HTMLOrSVG,\n  RuntimeContext,\n  SignalFilterOptions,\n} from '../../../../engine/types'\nimport { kebab } from '../../../../utils/text'\nimport {\n  DATASTAR_SSE_EVENT,\n  type DatastarSSEEvent,\n  ERROR,\n  FINISHED,\n  RETRIES_FAILED,\n  RETRYING,\n  STARTED,\n} from '../shared'\n\nconst dispatchSSE = (\n  type: string,\n  el: HTMLOrSVG,\n  argsRaw: Record<string, string>,\n) =>\n  document.dispatchEvent(\n    new CustomEvent<DatastarSSEEvent>(DATASTAR_SSE_EVENT, {\n      detail: { type, el, argsRaw },\n    }),\n  )\n\nconst isWrongContent = (err: any) => `${err}`.includes('text/event-stream')\n\ntype ResponseOverrides =\n  | {\n      selector?: string\n      mode?: string\n      useViewTransition?: boolean\n    }\n  | {\n      onlyIfMissing?: boolean\n    }\n\nexport type FetchArgs = {\n  headers?: Record<string, string>\n  openWhenHidden?: boolean\n  retryInterval?: number\n  retryScaler?: number\n  retryMaxWaitMs?: number\n  retryMaxCount?: number\n  abort?: AbortSignal\n  responseOverrides?: ResponseOverrides\n  contentType?: 'json' | 'form'\n  filterSignals?: SignalFilterOptions\n  selector?: string\n}\n\nexport const sse = async (\n  { el, evt, filtered, runtimeErr }: RuntimeContext,\n  method: string,\n  url: string,\n  {\n    selector,\n    headers: userHeaders,\n    contentType = 'json',\n    filterSignals = { include: /.*/, exclude: /(^|\\.)_/ },\n    openWhenHidden = false,\n    retryInterval = DefaultSseRetryDurationMs,\n    retryScaler = 2,\n    retryMaxWaitMs = 30_000,\n    retryMaxCount = 10,\n    abort,\n  }: FetchArgs = {},\n) => {\n  const action = method.toLowerCase()\n  let cleanupFn = () => {}\n  try {\n    if (!url?.length) {\n      throw runtimeErr('SseNoUrlProvided', { action })\n    }\n\n    const initialHeaders: Record<string, any> = {\n      Accept: 'text/event-stream, text/html, application/json',\n      [DATASTAR_REQUEST]: true,\n    }\n    if (contentType === 'json') {\n      initialHeaders['Content-Type'] = 'application/json'\n    }\n    const headers = Object.assign({}, initialHeaders, userHeaders)\n\n    // We ignore the content-type header if using form data\n    // if missing the boundary will be set automatically\n\n    const req: FetchEventSourceInit = {\n      method,\n      headers,\n      openWhenHidden,\n      retryInterval,\n      retryScaler,\n      retryMaxWaitMs,\n      retryMaxCount,\n      signal: abort,\n      onopen: async (response: Response) => {\n        if (response.status >= 400)\n          dispatchSSE(ERROR, el, { status: response.status.toString() })\n      },\n      onmessage: (evt) => {\n        if (!evt.event.startsWith(DATASTAR)) return\n        const type = evt.event\n        const argsRawLines: Record<string, string[]> = {}\n\n        for (const line of evt.data.split('\\n')) {\n          const i = line.indexOf(' ')\n          const k = line.slice(0, i)\n          const v = line.slice(i + 1)\n          ;(argsRawLines[k] ||= []).push(v)\n        }\n\n        const argsRaw = Object.fromEntries(\n          Object.entries(argsRawLines).map(([k, v]) => [k, v.join('\\n')]),\n        )\n\n        dispatchSSE(type, el, argsRaw)\n      },\n      onerror: (error) => {\n        if (isWrongContent(error)) {\n          // don't retry if the content-type is wrong\n          throw runtimeErr('InvalidContentType', { url })\n        }\n        // do nothing and it will retry\n        if (error) {\n          console.error(error.message)\n          dispatchSSE(RETRYING, el, { message: error.message })\n        }\n      },\n    }\n\n    const urlInstance = new URL(url, window.location.href)\n    const queryParams = new URLSearchParams(urlInstance.search)\n\n    if (contentType === 'json') {\n      const res = JSON.stringify(filtered(filterSignals))\n      if (method === 'GET') {\n        queryParams.set(DATASTAR, res)\n      } else {\n        req.body = res\n      }\n    } else if (contentType === 'form') {\n      const formEl = (\n        selector ? document.querySelector(selector) : el.closest('form')\n      ) as HTMLFormElement\n      if (!formEl) {\n        throw runtimeErr(\n          selector ? 'SseFormNotFound' : 'SseClosestFormNotFound',\n          { action, selector },\n        )\n      }\n\n      // Validate the form\n      if (!formEl.checkValidity()) {\n        formEl.reportValidity()\n        cleanupFn()\n        return\n      }\n\n      // Collect the form data\n\n      const formData = new FormData(formEl)\n      let submitter = el as HTMLElement | null\n\n      if (el === formEl && evt instanceof SubmitEvent) {\n        // Get the submitter from the event\n        submitter = evt.submitter\n      } else {\n        // Prevent the form being submitted\n        const preventDefault = (evt: Event) => evt.preventDefault()\n        formEl.addEventListener('submit', preventDefault)\n        cleanupFn = () => formEl.removeEventListener('submit', preventDefault)\n      }\n\n      // Append the value of the form submitter if it is a button with a name\n      if (submitter instanceof HTMLButtonElement) {\n        const name = submitter.getAttribute('name')\n        if (name) formData.append(name, submitter.value)\n      }\n\n      const multipart = formEl.getAttribute('enctype') === 'multipart/form-data'\n      // Leave the `Content-Type` header empty for multipart encoding so the browser can set it automatically with the correct boundary\n      if (!multipart) {\n        headers['Content-Type'] = 'application/x-www-form-urlencoded'\n      }\n\n      const formParams = new URLSearchParams(formData as any)\n      if (method === 'GET') {\n        for (const [key, value] of formParams) {\n          queryParams.append(key, value)\n        }\n      } else if (multipart) {\n        // Upload progress events are only available for: HTTPS connections (required for streaming uploads) with Multipart form data uploads\n        if (__USE_UPLOAD_PROGRESS__ && urlInstance.protocol === 'https:') {\n          const boundary = `----FormDataBoundary${Math.random().toString(36).substring(2, 11)}`\n          const encoder = new TextEncoder()\n\n          // Calculate total size\n          let total = 0\n          const parts: Array<{ field: string; value: string | File }> = []\n\n          for (const [name, value] of formData) {\n            parts.push({ field: name, value })\n            total += encoder.encode(`--${boundary}\\r\\n`).byteLength\n\n            if (value instanceof File) {\n              total += encoder.encode(\n                `Content-Disposition: form-data; name=\"${name}\"; filename=\"${value.name}\"\\r\\n` +\n                  `Content-Type: ${value.type || 'application/octet-stream'}\\r\\n\\r\\n`,\n              ).byteLength\n              total += value.size + 2\n            } else {\n              total += encoder.encode(\n                `Content-Disposition: form-data; name=\"${name}\"\\r\\n\\r\\n${value}\\r\\n`,\n              ).byteLength\n            }\n          }\n          total += encoder.encode(`--${boundary}--\\r\\n`).byteLength\n\n          let loaded = 0\n\n          req.body = new ReadableStream({\n            async start(controller) {\n              const write = (data: Uint8Array) => {\n                controller.enqueue(data)\n                loaded += data.byteLength\n\n                const progress = Math.round((loaded / total) * 100)\n                dispatchSSE('upload-progress', el, {\n                  progress: progress.toString(),\n                  loaded: loaded.toString(),\n                  total: total.toString(),\n                })\n              }\n\n              dispatchSSE('upload-progress', el, {\n                progress: '0',\n                loaded: '0',\n                total: total.toString(),\n              })\n\n              try {\n                for (const { field, value } of parts) {\n                  write(encoder.encode(`--${boundary}\\r\\n`))\n\n                  if (value instanceof File) {\n                    write(\n                      encoder.encode(\n                        `Content-Disposition: form-data; name=\"${field}\"; filename=\"${value.name}\"\\r\\n` +\n                          `Content-Type: ${value.type || 'application/octet-stream'}\\r\\n\\r\\n`,\n                      ),\n                    )\n\n                    const reader = value.stream().getReader()\n                    try {\n                      while (true) {\n                        const { done, value: chunk } = await reader.read()\n                        if (done) break\n                        write(chunk)\n                      }\n                    } finally {\n                      reader.releaseLock()\n                    }\n                    write(encoder.encode('\\r\\n'))\n                  } else {\n                    write(\n                      encoder.encode(\n                        `Content-Disposition: form-data; name=\"${field}\"\\r\\n\\r\\n${value}\\r\\n`,\n                      ),\n                    )\n                  }\n                }\n\n                write(encoder.encode(`--${boundary}--\\r\\n`))\n\n                if (loaded < total) {\n                  dispatchSSE('upload-progress', el, {\n                    progress: '100',\n                    loaded: total.toString(),\n                    total: total.toString(),\n                  })\n                }\n\n                controller.close()\n              } catch (error) {\n                controller.error(error)\n              }\n            },\n          })\n\n          // Override content-type header with the boundary\n          headers['Content-Type'] = `multipart/form-data; boundary=${boundary}`\n          // Set duplex mode for streaming uploads\n          ;(req as any).duplex = 'half'\n        } else {\n          req.body = formData\n        }\n      } else {\n        req.body = formParams\n      }\n    } else {\n      throw runtimeErr('SseInvalidContentType', { action, contentType })\n    }\n\n    dispatchSSE(STARTED, el, {})\n    urlInstance.search = queryParams.toString()\n\n    try {\n      await fetchEventSource(urlInstance.toString(), el, req)\n    } catch (error) {\n      if (!isWrongContent(error)) {\n        throw runtimeErr('SseFetchFailed', { method, url, error })\n      }\n      // exit gracefully and do nothing if the content-type is wrong\n      // this can happen if the client is sending a request\n      // where no response is expected, and they haven't\n      // set the content-type to text/event-stream\n    }\n  } finally {\n    dispatchSSE(FINISHED, el, {})\n    cleanupFn()\n  }\n}\n\n// Below originally from https://github.com/Azure/fetch-event-source/blob/main/LICENSE\n\n/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\n\ninterface EventSourceMessage {\n  id: string\n  event: string\n  data: string\n  retry?: number\n}\n\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nasync function getBytes(\n  stream: ReadableStream<Uint8Array>,\n  onChunk: (arr: Uint8Array) => void,\n): Promise<void> {\n  const reader = stream.getReader()\n  let result = await reader.read()\n  while (!result.done) {\n    onChunk(result.value)\n    result = await reader.read()\n  }\n}\n\nfunction getLines(onLine: (line: Uint8Array, fieldLength: number) => void) {\n  let buffer: Uint8Array | undefined\n  let position: number // current read position\n  let fieldLength: number // length of the `field` portion of the line\n  let discardTrailingNewline = false\n\n  // return a function that can process each incoming byte chunk:\n  return function onChunk(arr: Uint8Array) {\n    if (!buffer) {\n      buffer = arr\n      position = 0\n      fieldLength = -1\n    } else {\n      // we're still parsing the old line. Append the new bytes into buffer:\n      buffer = concat(buffer, arr)\n    }\n\n    const bufLength = buffer.length\n    let lineStart = 0 // index where the current line starts\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === 10) lineStart = ++position // skip to next char\n        discardTrailingNewline = false\n      }\n\n      // start looking forward till the end of line:\n      let lineEnd = -1 // index of the \\r or \\n char\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case 58: // :\n            if (fieldLength === -1) {\n              // first colon in line\n              fieldLength = position - lineStart\n            }\n            break\n          // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n          // biome-ignore lint/suspicious/noFallthroughSwitchClause: intentional fallthrough for CR to LF\n          case 13: // \\r\n            discardTrailingNewline = true\n          case 10: // \\n\n            lineEnd = position\n            break\n        }\n      }\n\n      if (lineEnd === -1) break // Wait for the next arr and then continue parsing\n\n      // we've reached the line end, send it out:\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength)\n      lineStart = position // we're now on the next line\n      fieldLength = -1\n    }\n\n    if (lineStart === bufLength)\n      buffer = undefined // we've finished reading it\n    else if (lineStart) {\n      // Create a new view into buffer beginning at lineStart so we don't\n      // need to copy over the previous lines when we get the new arr:\n      buffer = buffer.subarray(lineStart)\n      position -= lineStart\n    }\n  }\n}\n\nfunction getMessages(\n  onId: (id: string) => void,\n  onRetry: (retry: number) => void,\n  onMessage?: (msg: EventSourceMessage) => void,\n) {\n  let message = newMessage()\n  const decoder = new TextDecoder()\n\n  // return a function that can process each incoming line buffer:\n  return function onLine(line: Uint8Array, fieldLength: number) {\n    if (!line.length) {\n      // empty line denotes end of message. Trigger the callback and start a new message:\n      onMessage?.(message)\n      message = newMessage()\n    } else if (fieldLength > 0) {\n      // exclude comments and lines with no values\n      // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n      // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n      const field = decoder.decode(line.subarray(0, fieldLength))\n      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1)\n      const value = decoder.decode(line.subarray(valueOffset))\n\n      switch (field) {\n        case 'data':\n          message.data = message.data ? `${message.data}\\n${value}` : value\n          break\n        case 'event':\n          message.event = value\n          break\n        case 'id':\n          onId((message.id = value))\n          break\n        case 'retry': {\n          const retry = +value\n          if (!Number.isNaN(retry)) {\n            // per spec, ignore non-integers\n            onRetry((message.retry = retry))\n          }\n          break\n        }\n      }\n    }\n  }\n}\n\nconst concat = (a: Uint8Array, b: Uint8Array) => {\n  const res = new Uint8Array(a.length + b.length)\n  res.set(a)\n  res.set(b, a.length)\n  return res\n}\n\nconst newMessage = (): EventSourceMessage => ({\n  // data, event, and id must be initialized to empty strings:\n  // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n  // retry should be initialized to undefined so we return a consistent shape\n  // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n  data: '',\n  event: '',\n  id: '',\n  retry: undefined,\n})\n\ninterface FetchEventSourceInit extends RequestInit {\n  headers?: Record<string, string>\n  onopen?: (response: Response) => Promise<void>\n  onmessage?: (ev: EventSourceMessage) => void\n  onclose?: () => void\n  onerror?: (err: any) => number | null | undefined | void\n  openWhenHidden?: boolean\n  fetch?: typeof fetch\n  retryInterval?: number\n  retryScaler?: number\n  retryMaxWaitMs?: number\n  retryMaxCount?: number\n  overrides?: ResponseOverrides\n}\n\nfunction fetchEventSource(\n  input: RequestInfo,\n  el: HTMLOrSVG,\n  {\n    signal: inputSignal,\n    headers: inputHeaders,\n    onopen: inputOnOpen,\n    onmessage,\n    onclose,\n    onerror,\n    openWhenHidden,\n    fetch: inputFetch,\n    retryInterval = 1_000,\n    retryScaler = 2,\n    retryMaxWaitMs = 30_000,\n    retryMaxCount = 10,\n    overrides,\n    ...rest\n  }: FetchEventSourceInit,\n) {\n  return new Promise<void>((resolve, reject) => {\n    // make a copy of the input headers since we may modify it below:\n    const headers: Record<string, string> = {\n      accept: 'text/event-stream',\n      ...inputHeaders,\n    }\n\n    let curRequestController: AbortController\n    function onVisibilityChange() {\n      curRequestController.abort() // close existing request on every visibility change\n      if (!document.hidden) create() // page is now visible again, recreate request.\n    }\n\n    if (!openWhenHidden) {\n      document.addEventListener('visibilitychange', onVisibilityChange)\n    }\n\n    let retryTimer = 0\n    function dispose() {\n      document.removeEventListener('visibilitychange', onVisibilityChange)\n      window.clearTimeout(retryTimer)\n      curRequestController.abort()\n    }\n\n    // if the incoming signal aborts, dispose resources and resolve:\n    inputSignal?.addEventListener('abort', () => {\n      dispose()\n      resolve() // don't waste time constructing/logging errors\n    })\n\n    const fetch = inputFetch || window.fetch\n    const onopen = inputOnOpen || (() => {})\n\n    let retries = 0\n    let baseRetryInterval = retryInterval\n    async function create() {\n      curRequestController = new AbortController()\n      try {\n        const response = await fetch(input, {\n          ...rest,\n          headers,\n          signal: curRequestController.signal,\n        })\n\n        // on successful connection, reset the retry logic\n        retries = 0\n        retryInterval = baseRetryInterval\n\n        await onopen(response)\n\n        const dispatchNonSSE = async (\n          dispatchType: string,\n          response: Response,\n          name: string,\n          overrides?: ResponseOverrides,\n          ...argNames: string[]\n        ) => {\n          const argsRaw: Record<string, string> = {\n            [name]: await response.text(),\n          }\n          for (const n of argNames) {\n            let v = response.headers.get(`datastar-${kebab(n)}`)\n            if (overrides) {\n              const o = (overrides as any)[n]\n              if (o) v = typeof o === 'string' ? o : JSON.stringify(o)\n            }\n            if (v) argsRaw[n] = v\n          }\n\n          dispatchSSE(dispatchType, el, argsRaw)\n          dispose()\n        }\n\n        const ct = response.headers.get('Content-Type')\n        if (ct?.includes('text/html')) {\n          return await dispatchNonSSE(\n            EventTypePatchElements,\n            response,\n            'elements',\n            overrides,\n            'selector',\n            'mode',\n            'useViewTransition',\n          )\n        }\n\n        if (ct?.includes('application/json')) {\n          return await dispatchNonSSE(\n            EventTypePatchSignals,\n            response,\n            'signals',\n            overrides,\n            'onlyIfMissing',\n          )\n        }\n\n        if (ct?.includes('text/javascript')) {\n          const script = document.createElement('script')\n          const scriptAttributesHeader = response.headers.get(\n            'datastar-script-attributes',\n          )\n\n          if (scriptAttributesHeader) {\n            for (const [name, value] of Object.entries(\n              JSON.parse(scriptAttributesHeader),\n            )) {\n              script.setAttribute(name, value as string)\n            }\n          }\n          script.textContent = await response.text()\n          document.head.appendChild(script)\n          dispose()\n          return\n        }\n\n        await getBytes(\n          response.body!,\n          getLines(\n            getMessages(\n              (id) => {\n                if (id) {\n                  // signals the id and send it back on the next retry:\n                  headers['last-event-id'] = id\n                } else {\n                  // don't send the last-event-id header anymore:\n                  delete headers['last-event-id']\n                }\n              },\n              (retry) => {\n                baseRetryInterval = retryInterval = retry\n              },\n              onmessage,\n            ),\n          ),\n        )\n\n        onclose?.()\n        dispose()\n        resolve()\n      } catch (err) {\n        if (!curRequestController.signal.aborted) {\n          // if we haven't aborted the request ourselves:\n          try {\n            // check if we need to retry:\n            const interval: any = onerror?.(err) || retryInterval\n            window.clearTimeout(retryTimer)\n            retryTimer = window.setTimeout(create, interval)\n            retryInterval = Math.min(\n              retryInterval * retryScaler,\n              retryMaxWaitMs,\n            ) // exponential backoff\n            if (++retries >= retryMaxCount) {\n              dispatchSSE(RETRIES_FAILED, el, {})\n              // we should not retry anymore:\n              dispose()\n              reject('Max retries reached.') // Max retries reached, check your server or network connection\n            } else {\n              console.error(\n                `Datastar failed to reach ${input.toString()} retrying in ${interval}ms.`,\n              )\n            }\n          } catch (innerErr) {\n            // we should not retry anymore:\n            dispose()\n            reject(innerErr)\n          }\n        }\n      }\n    }\n\n    create()\n  })\n}\n", "// Factory for creating HTTP method action plugins\nimport type { ActionPlugin } from '../../../../engine/types'\nimport { type FetchArgs, sse } from './fetch'\n\n// Helper to create HTTP method plugins with consistent structure\nexport const createHttpMethod = (\n  name: string,\n  method: string,\n): ActionPlugin => ({\n  type: 'action',\n  name,\n  fn: (ctx, url: string, args: FetchArgs) => sse(ctx, method, url, args),\n})\n", "// Icon: material-symbols:delete-outline\n// Slug: Use a DELETE request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { createHttpMethod } from './httpMethods'\n\nexport const DELETE = createHttpMethod('delete', 'DELETE')\n", "// Icon: ic:baseline-get-app\n// Slug: Use a GET request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { createHttpMethod } from './httpMethods'\n\nexport const GET = createHttpMethod('get', 'GET')\n", "// Icon: fluent:patch-24-filled\n// Slug: Use a PATCH request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { createHttpMethod } from './httpMethods'\n\nexport const PATCH = createHttpMethod('patch', 'PATCH')\n", "// Icon: ri:signpost-fill\n// Slug: Use a POST request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { createHttpMethod } from './httpMethods'\n\nexport const POST = createHttpMethod('post', 'POST')\n", "// Icon: material-symbols:arrows-input\n// Slug: Use a PUT request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { createHttpMethod } from './httpMethods'\n\nexport const PUT = createHttpMethod('put', 'PUT')\n", "// Icon: material-symbols:cloud-download\n// Slug: Patch elements into the DOM using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DefaultElementPatchMode,\n  ElementPatchModeAfter,\n  ElementPatchModeAppend,\n  ElementPatchModeBefore,\n  ElementPatchModeInner,\n  ElementPatchModeOuter,\n  ElementPatchModePrepend,\n  ElementPatchModeRemove,\n  ElementPatchModeReplace,\n  EventTypePatchElements,\n} from '../../../../engine/consts'\nimport { aliasify } from '../../../../engine/engine'\nimport { initErr } from '../../../../engine/errors'\nimport type {\n  HTMLOrSVG,\n  InitContext,\n  WatcherPlugin,\n} from '../../../../engine/types'\nimport { kebab } from '../../../../utils/text'\nimport { supportsViewTransitions } from '../../../../utils/view-transitions'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const PatchElements: WatcherPlugin = {\n  type: 'watcher',\n  name: EventTypePatchElements,\n  async onGlobalInit(ctx) {\n    datastarSSEEventWatcher(EventTypePatchElements, (args) =>\n      onPatchElements(ctx, args),\n    )\n  },\n}\n\nfunction onPatchElements(\n  ctx: InitContext,\n  {\n    elements,\n    selector,\n    mode = DefaultElementPatchMode,\n    useViewTransition,\n  }: Record<string, string>,\n) {\n  if (mode === ElementPatchModeRemove && selector) {\n    const targets = document.querySelectorAll(selector)\n    if (!targets.length) {\n      throw initErr('NoTargetsFound', ctx, {\n        selectorOrId: selector,\n      })\n    }\n\n    if (useViewTransition && supportsViewTransitions) {\n      document.startViewTransition(() => {\n        for (const target of targets) {\n          target.remove()\n        }\n      })\n    } else {\n      for (const target of targets) {\n        target.remove()\n      }\n    }\n  } else {\n    const template = document.createElement('template')\n    template.innerHTML = elements\n\n    for (const node of [...template.content.childNodes]) {\n      const type = node.nodeType\n      if (type !== 1) {\n        if (type === 3 && !node.nodeValue!.trim()) {\n          continue\n        }\n        throw initErr('NoElementsFound', ctx)\n      }\n\n      const selectorOrId = selector || `#${(node as Element).id}`\n      const targets = document.querySelectorAll(selectorOrId)\n      if (!targets.length) {\n        throw initErr('NoTargetsFound', ctx, {\n          selectorOrId,\n        })\n      }\n\n      if (useViewTransition && supportsViewTransitions) {\n        document.startViewTransition(() =>\n          applyToTargets(ctx, mode, node as HTMLOrSVG, targets),\n        )\n      } else {\n        applyToTargets(ctx, mode, node as HTMLOrSVG, targets)\n      }\n    }\n  }\n}\n\nconst scripts = new WeakSet<HTMLScriptElement>()\nfunction execute(target: Element): void {\n  const elScripts =\n    target instanceof HTMLScriptElement\n      ? [target]\n      : target.querySelectorAll('script')\n  for (const old of elScripts) {\n    if (!scripts.has(old)) {\n      const script = document.createElement('script')\n      for (const { name, value } of old.attributes) {\n        script.setAttribute(name, value)\n      }\n      script.text = old.text\n      old.replaceWith(script)\n      scripts.add(script)\n    }\n  }\n}\n\nfunction applyToTargets(\n  ctx: InitContext,\n  mode: string,\n  element: HTMLOrSVG,\n  capturedTargets: NodeListOf<Element>,\n) {\n  for (const target of capturedTargets) {\n    if (mode === ElementPatchModeRemove) {\n      target.remove()\n    } else if (\n      mode === ElementPatchModeOuter ||\n      mode === ElementPatchModeInner\n    ) {\n      morph(target, element, mode)\n      execute(target)\n    } else {\n      const cloned = element.cloneNode(true) as Element\n      if (mode === ElementPatchModeReplace) {\n        target.replaceWith(cloned)\n      } else if (mode === ElementPatchModePrepend) {\n        target.prepend(cloned)\n      } else if (mode === ElementPatchModeAppend) {\n        target.append(cloned)\n      } else if (mode === ElementPatchModeBefore) {\n        target.before(cloned)\n      } else if (mode === ElementPatchModeAfter) {\n        target.after(cloned)\n      } else {\n        throw initErr('InvalidPatchMode', ctx, { mode })\n      }\n      execute(cloned)\n    }\n  }\n}\n\nconst oldIdTagNameMap = new Map<string, string>()\nconst ctxIdMap = new Map<Node, Set<string>>()\nconst ctxPersistentIds = new Set<string>()\nconst duplicateIds = new Set<string>()\nconst ctxPantry = document.createElement('div')\nctxPantry.hidden = true\n\nfunction morph(\n  oldElt: Element,\n  newElt: Element,\n  mode: typeof ElementPatchModeInner | typeof ElementPatchModeOuter,\n): void {\n  const ignore = aliasify('ignore-morph')\n  if (\n    (oldElt.hasAttribute(ignore) && newElt.hasAttribute(ignore)) ||\n    oldElt.parentElement?.closest(`[${ignore}]`)\n  ) {\n    return\n  }\n\n  const normalizedElt = document.createElement('div')\n  normalizedElt.append(newElt as Element)\n  document.body.insertAdjacentElement('afterend', ctxPantry)\n\n  // Computes the set of ids that persist between the two contents excluding duplicates\n  const oldIdElements = oldElt.querySelectorAll('[id]')\n  for (const { id, tagName } of oldIdElements) {\n    if (oldIdTagNameMap.has(id)) {\n      duplicateIds.add(id)\n    } else {\n      oldIdTagNameMap.set(id, tagName)\n    }\n  }\n  if (oldElt.id) {\n    if (oldIdTagNameMap.has(oldElt.id)) {\n      duplicateIds.add(oldElt.id)\n    } else {\n      oldIdTagNameMap.set(oldElt.id, oldElt.tagName)\n    }\n  }\n\n  ctxPersistentIds.clear()\n  const newIdElements = normalizedElt.querySelectorAll('[id]')\n  for (const { id, tagName } of newIdElements) {\n    if (ctxPersistentIds.has(id)) {\n      duplicateIds.add(id)\n    } else if (oldIdTagNameMap.get(id) === tagName) {\n      ctxPersistentIds.add(id)\n    }\n  }\n\n  oldIdTagNameMap.clear()\n\n  for (const id of duplicateIds) {\n    ctxPersistentIds.delete(id)\n  }\n\n  duplicateIds.clear()\n\n  // Computes a map of nodes to all ids contained within that node (inclusive of the node).\n  // This map can be used to ask if two nodes have intersecting sets of ids,\n  // which allows for a looser definition of \"matching\" than tradition id matching,\n  // and allows child nodes to contribute to a parent nodes matching.\n  // const idMap = new Map<Node, Set<string>>()\n  ctxIdMap.clear()\n\n  populateIdMapWithTree(\n    mode === 'outer' ? oldElt.parentElement! : oldElt,\n    oldIdElements,\n  )\n  populateIdMapWithTree(normalizedElt, newIdElements)\n\n  morphChildren(\n    mode === 'outer' ? oldElt.parentElement! : oldElt,\n    normalizedElt,\n    mode === 'outer' ? (oldElt as Node) : null,\n    oldElt.nextSibling,\n  )\n\n  ctxPantry.remove()\n}\n\n// This is the core algorithm for matching up children.\n// The idea is to use id sets to try to match up nodes as faithfully as possible.\n// We greedily match, which allows us to keep the algorithm fast,\n// but by using id sets, we are able to better match up with content deeper in the DOM.\nfunction morphChildren(\n  oldParent: Element, // the old content that we are merging the new content into\n  newParent: Element, // the parent element of the new content\n  insertionPoint: Node | null = null, // // the point in the DOM we start morphing at (defaults to first child)\n  endPoint: Node | null = null, // the point in the DOM we stop morphing at (defaults to after last child)\n): void {\n  // normalize\n  if (\n    oldParent instanceof HTMLTemplateElement &&\n    newParent instanceof HTMLTemplateElement\n  ) {\n    // we can pretend the DocumentElement is an Element\n    oldParent = oldParent.content as unknown as Element\n    newParent = newParent.content as unknown as Element\n  }\n  insertionPoint ??= oldParent.firstChild\n\n  // run through all the new content\n  for (const newChild of newParent.childNodes) {\n    // once we reach the end of the old parent content skip to the end and insert the rest\n    if (insertionPoint && insertionPoint !== endPoint) {\n      const bestMatch = findBestMatch(newChild, insertionPoint, endPoint)\n      if (bestMatch) {\n        // if the node to morph is not at the insertion point then remove/move up to it\n        if (bestMatch !== insertionPoint) {\n          let cursor: Node | null = insertionPoint\n          // Remove nodes between the start and end nodes\n          while (cursor && cursor !== bestMatch) {\n            const tempNode = cursor\n            cursor = cursor.nextSibling\n            removeNode(tempNode)\n          }\n        }\n        morphNode(bestMatch, newChild)\n        insertionPoint = bestMatch.nextSibling\n        continue\n      }\n    }\n\n    // @ts-ignore\n    const ncId = newChild.id\n    // if the matching node is elsewhere in the original content\n    if (newChild instanceof Element && ctxPersistentIds.has(ncId)) {\n      // move it and all its children here and morph, will always be found\n      // Search for an element by id within the document and pantry, and move it using moveBefore.\n\n      const movedChild = window[ncId] as unknown as Element\n\n      // Removes an element from its ancestors' id maps.\n      // This is needed when an element is moved from the \"future\" via `moveBeforeId`.\n      // Otherwise, its erstwhile ancestors could be mistakenly moved to the pantry rather than being deleted,\n      // preventing their removal hooks from being called.\n      let current = movedChild\n      while ((current = current.parentNode as Element)) {\n        const idSet = ctxIdMap.get(current)\n        if (idSet) {\n          idSet.delete(ncId)\n          if (!idSet.size) {\n            ctxIdMap.delete(current)\n          }\n        }\n      }\n\n      moveBefore(oldParent, movedChild, insertionPoint)\n      morphNode(movedChild, newChild)\n      insertionPoint = movedChild.nextSibling\n      continue\n    }\n\n    // This performs the action of inserting a new node while handling situations where the node contains\n    // elements with persistent ids and possible state info we can still preserve by moving in and then morphing\n    if (ctxIdMap.has(newChild)) {\n      // node has children with ids with possible state so create a dummy elt of same type and apply full morph algorithm\n      const newEmptyChild = document.createElement(\n        (newChild as Element).tagName,\n      )\n      oldParent.insertBefore(newEmptyChild, insertionPoint)\n      morphNode(newEmptyChild, newChild)\n      insertionPoint = newEmptyChild.nextSibling\n    } else {\n      // optimization: no id state to preserve so we can just insert a clone of the newChild and its descendants\n      const newClonedChild = document.importNode(newChild, true) // importNode to not mutate newParent\n      oldParent.insertBefore(newClonedChild, insertionPoint)\n      insertionPoint = newClonedChild.nextSibling\n    }\n  }\n\n  // remove any remaining old nodes that didn't match up with new content\n  while (insertionPoint && insertionPoint !== endPoint) {\n    const tempNode = insertionPoint\n    insertionPoint = insertionPoint.nextSibling\n    removeNode(tempNode)\n  }\n}\n\n// Scans forward from the startPoint to the endPoint looking for a match for the node.\n// It looks for an id set match first, then a soft match.\n// We abort soft matching if we find two future soft matches, to reduce churn.\nfunction findBestMatch(\n  node: Node,\n  startPoint: Node | null,\n  endPoint: Node | null,\n): Node | null {\n  let bestMatch = null\n  let nextSibling = node.nextSibling\n  let siblingSoftMatchCount = 0\n  let displaceMatchCount = 0\n\n  // max id matches we are willing to displace in our search\n  const nodeMatchCount = ctxIdMap.get(node)?.size || 0\n\n  let cursor = startPoint\n  while (cursor && cursor !== endPoint) {\n    // soft matching is a prerequisite for id set matching\n    if (isSoftMatch(cursor, node)) {\n      let isIdSetMatch = false\n      const oldSet = ctxIdMap.get(cursor)\n      const newSet = ctxIdMap.get(node)\n\n      if (newSet && oldSet) {\n        for (const id of oldSet) {\n          // a potential match is an id in the new and old nodes that\n          // has not already been merged into the DOM\n          // But the newNode content we call this on has not been\n          // merged yet and we don't allow duplicate IDs so it is simple\n          if (newSet.has(id)) {\n            isIdSetMatch = true\n            break\n          }\n        }\n      }\n\n      if (isIdSetMatch) {\n        return cursor // found an id set match, we're done!\n      }\n\n      // we haven't yet saved a soft match fallback\n      // the current soft match will hard match something else in the future, leave it\n      if (!bestMatch && !ctxIdMap.has(cursor)) {\n        // optimization: if node can't id set match, we can just return the soft match immediately\n        if (!nodeMatchCount) {\n          return cursor\n        }\n        // save this as the fallback if we get through the loop without finding a hard match\n        bestMatch = cursor\n      }\n    }\n    // check for ids we may be displaced when matching\n    displaceMatchCount += ctxIdMap.get(cursor)?.size || 0\n    if (displaceMatchCount > nodeMatchCount) {\n      // if we are going to displace more ids than the node contains then\n      // we do not have a good candidate for an id match, so return\n      break\n    }\n\n    if (bestMatch === null && nextSibling && isSoftMatch(cursor, nextSibling)) {\n      // The next new node has a soft match with this node, so\n      // increment the count of future soft matches\n      siblingSoftMatchCount++\n      nextSibling = nextSibling.nextSibling\n\n      // If there are two future soft matches, block soft matching for this node to allow\n      // future siblings to soft match. This is to reduce churn in the DOM when an element\n      // is prepended.\n      if (siblingSoftMatchCount >= 2) {\n        bestMatch = undefined\n      }\n    }\n\n    // if the current node contains active element, stop looking for better future matches,\n    // because if one is found, this node will be moved to the pantry, re-parenting it and thus losing focus\n    if (cursor.contains(document.activeElement)) break\n\n    cursor = cursor.nextSibling\n  }\n\n  return bestMatch || null\n}\n\nfunction isSoftMatch(oldNode: Node, newNode: Node): boolean {\n  // ok to cast: if one is not element, `id` and `tagName` will be null and we'll just compare that.\n  const oldId = (oldNode as Element).id\n  return (\n    oldNode.nodeType === newNode.nodeType &&\n    (oldNode as Element).tagName === (newNode as Element).tagName &&\n    // If oldElt has an `id` with possible state and it doesn't match newElt.id then avoid morphing.\n    // We'll still match an anonymous node with an IDed newElt, though, because if it got this far,\n    // its not persistent, and new nodes can't have any hidden state.\n    (!oldId || oldId === (newNode as Element).id)\n  )\n}\n\n// Gets rid of an unwanted DOM node; strategy depends on nature of its reuse:\n// - Persistent nodes will be moved to the pantry for later reuse\n// - Other nodes will have their hooks called, and then are removed\nfunction removeNode(node: Node) {\n  // are we going to id set match this later?\n  if (ctxIdMap.has(node)) {\n    // skip callbacks and move to pantry\n    moveBefore(ctxPantry, node, null)\n  } else {\n    // remove for realsies\n    node.parentNode?.removeChild(node)\n  }\n}\n\n// Moves an element before another element within the same parent.\n// Uses the proposed `moveBefore` API if available (and working), otherwise falls back to `insertBefore`.\n// This is essentially a forward-compat wrapper.\nconst moveBefore: (parentNode: Node, node: Node, after: Node | null) => void =\n  // @ts-ignore\n  removeNode.call.bind(ctxPantry.moveBefore ?? ctxPantry.insertBefore)\n\nfunction morphNode(\n  oldNode: Node, // root node to merge content into\n  newNode: Node, // new content to merge\n): Node {\n  // syncs the oldNode to the newNode, copying over all attributes and\n  // inner element state from the newNode to the oldNode\n  const type = newNode.nodeType\n\n  // if is an element type, sync the attributes from the\n  // new node into the new node\n  if (type === 1 /* element type */) {\n    const ignore = aliasify('ignore-morph')\n    if (\n      (oldNode as Element).hasAttribute(ignore) &&\n      (newNode as Element).hasAttribute(ignore)\n    ) {\n      return oldNode\n    }\n\n    const preserveAttrs = (newNode as HTMLElement)\n      .getAttribute(aliasify('preserve-attr'))\n      ?.split(' ')\n\n    for (const { name, value } of (newNode as Element).attributes) {\n      // @ts-ignore\n      if (\n        (oldNode as Element).getAttribute(name) !== value &&\n        !preserveAttrs?.includes(kebab(name))\n      ) {\n        ;(oldNode as Element).setAttribute(name, value)\n      }\n    }\n\n    const oldAttrs = (oldNode as Element).attributes\n    for (let i = oldAttrs.length - 1; i >= 0; i--) {\n      const { name } = oldAttrs[i]\n      if (\n        !(newNode as Element).hasAttribute(name) &&\n        !preserveAttrs?.includes(kebab(name))\n      ) {\n        ;(oldNode as Element).removeAttribute(name)\n      }\n    }\n\n    //  many bothans died to bring us information:\n    //  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n    //  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n    if (\n      oldNode instanceof HTMLInputElement &&\n      newNode instanceof HTMLInputElement &&\n      newNode.type !== 'file'\n    ) {\n      const bind = aliasify('bind').slice(5)\n      let noBind = true\n      for (const key in newNode.dataset) {\n        if (key.startsWith(bind)) {\n          noBind = false\n          break\n        }\n      }\n      if (noBind) {\n        const newValue = newNode.value\n        if (!newNode.hasAttribute('value')) {\n          oldNode.value = ''\n          oldNode.removeAttribute('value')\n        } else if (oldNode.value !== newValue) {\n          oldNode.setAttribute('value', newValue)\n          oldNode.value = newValue\n        }\n      }\n    } else if (\n      oldNode instanceof HTMLTextAreaElement &&\n      newNode instanceof HTMLTextAreaElement\n    ) {\n      const newValue = newNode.value\n      if (newValue !== oldNode.value) {\n        oldNode.value = newValue\n      }\n      if (oldNode.firstChild && oldNode.firstChild.nodeValue !== newValue) {\n        oldNode.firstChild.nodeValue = newValue\n      }\n    }\n  }\n\n  if (type === 8 /* comment */ || type === 3 /* text */) {\n    if (oldNode.nodeValue !== newNode.nodeValue) {\n      oldNode.nodeValue = newNode.nodeValue\n    }\n  }\n\n  if (!oldNode.isEqualNode(newNode)) {\n    morphChildren(oldNode as Element, newNode as Element)\n  }\n  return oldNode\n}\n\n// A bottom-up algorithm that populates a map of Element -> IdSet.\n// The idSet for a given element is the set of all IDs contained within its subtree.\n// As an optimization, we filter these IDs through the given list of persistent IDs,\n// because we don't need to bother considering IDed elements that won't be in the new content.\nfunction populateIdMapWithTree(\n  root: Element | null,\n  elements: Element[] | NodeListOf<Element>,\n) {\n  for (const elt of elements) {\n    if (ctxPersistentIds.has(elt.id)) {\n      let current: Element | null = elt\n      // walk up the parent hierarchy of that element, adding the id of element to the parent's id set\n      while (current && current !== root) {\n        let idSet = ctxIdMap.get(current)\n        // if the id set doesn't exist, create it and insert it in the map\n        if (!idSet) {\n          idSet = new Set()\n          ctxIdMap.set(current, idSet)\n        }\n        idSet.add(elt.id)\n        current = current.parentElement\n      }\n    }\n  }\n}\n", "// Icon: material-symbols:settings-input-antenna\n// Slug: Patch signals using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DefaultPatchSignalsOnlyIfMissing,\n  EventTypePatchSignals,\n} from '../../../../engine/consts'\nimport type { WatcherPlugin } from '../../../../engine/types'\nimport { isBoolString, jsStrToObject } from '../../../../utils/text'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const PatchSignals: WatcherPlugin = {\n  type: 'watcher',\n  name: EventTypePatchSignals,\n  onGlobalInit: (ctx) =>\n    datastarSSEEventWatcher(\n      EventTypePatchSignals,\n      ({\n        signals: raw = '{}',\n        onlyIfMissing: onlyIfMissingRaw = `${DefaultPatchSignalsOnlyIfMissing}`,\n      }) =>\n        ctx.mergePatch(jsStrToObject(raw), {\n          ifMissing: isBoolString(onlyIfMissingRaw),\n        }),\n    ),\n}\n", "import { apply, load, setAlias } from '../engine'\nimport { Peek } from '../plugins/framework/actions/peek'\nimport { SetAll } from '../plugins/framework/actions/setAll'\nimport { ToggleAll } from '../plugins/framework/actions/toggleAll'\nimport { Attr } from '../plugins/framework/attributes/attr'\nimport { Bind } from '../plugins/framework/attributes/bind'\nimport { Class } from '../plugins/framework/attributes/class'\nimport { Indicator } from '../plugins/framework/attributes/indicator'\nimport { JsonSignals } from '../plugins/framework/attributes/jsonSignals'\nimport { On } from '../plugins/framework/attributes/on'\nimport { OnIntersect } from '../plugins/framework/attributes/onIntersect'\nimport { OnInterval } from '../plugins/framework/attributes/onInterval'\nimport { OnLoad } from '../plugins/framework/attributes/onLoad'\nimport { Ref } from '../plugins/framework/attributes/ref'\nimport { Scope } from '../plugins/framework/attributes/scope'\nimport { Show } from '../plugins/framework/attributes/show'\nimport { Text } from '../plugins/framework/attributes/text'\nimport { DELETE } from '../plugins/framework/backend/actions/delete'\nimport { GET } from '../plugins/framework/backend/actions/get'\nimport { PATCH } from '../plugins/framework/backend/actions/patch'\nimport { POST } from '../plugins/framework/backend/actions/post'\nimport { PUT } from '../plugins/framework/backend/actions/put'\nimport { PatchElements } from '../plugins/framework/backend/watchers/patchElements'\nimport { PatchSignals } from '../plugins/framework/backend/watchers/patchSignals'\n\nload(\n  // Backend\n  GET,\n  POST,\n  PUT,\n  PATCH,\n  DELETE,\n  PatchElements,\n  PatchSignals,\n  // Attributes\n  Attr,\n  Bind,\n  Class,\n  Indicator,\n  JsonSignals,\n  On,\n  OnIntersect,\n  OnInterval,\n  OnLoad,\n  Ref,\n  Scope,\n  Show,\n  Text,\n  // Actions\n  Peek,\n  SetAll,\n  ToggleAll,\n)\n\napply()\n\nexport { apply, load, setAlias }\n"],
  "mappings": "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",
  "names": ["lol", "DSP", "DSS", "DATASTAR", "DATASTAR_REQUEST", "DefaultSseRetryDurationMs", "DefaultPatchSignalsOnlyIfMissing", "ElementPatchModeOuter", "ElementPatchModeInner", "ElementPatchModeRemove", "ElementPatchModeReplace", "ElementPatchModePrepend", "ElementPatchModeAppend", "ElementPatchModeBefore", "ElementPatchModeAfter", "DefaultElementPatchMode", "EventTypePatchElements", "EventTypePatchSignals", "isPojo", "obj", "isEmpty", "prop", "updateLeaves", "fn", "key", "val", "pathToObj", "target", "paths", "path", "keys", "lastKey", "acc", "isHTMLOrSVG", "el", "findClosestScoped", "isBoolString", "str", "kebab", "camel", "x", "snake", "pascal", "jsStrToObject", "raw", "caseFns", "modifyCasing", "mods", "c", "fn", "modifyScope", "signalName", "el", "scope", "findClosestScoped", "Computed", "el", "key", "mods", "rx", "computed", "mergePatch", "signalName", "modifyCasing", "modifyScope", "pathToObj", "Effect", "effect", "rx", "Signals", "el", "key", "mods", "rx", "mergePatch", "ifMissing", "modifyScope", "modifyCasing", "pathToObj", "patch", "pathObj", "url", "dserr", "type", "reason", "metadata", "e", "DATASTAR", "snake", "q", "c", "initErr", "reason", "ctx", "metadata", "errCtx", "dserr", "runtimeErr", "DATASTAR_SIGNAL_PATCH_EVENT", "DATASTAR", "currentPatch", "queuedEffects", "batchDepth", "notifyIndex", "queuedEffectsLength", "activeSub", "startBatch", "endBatch", "flush", "dispatch", "signal", "initialValue", "signalOper", "value_", "flags_", "computedSymbol", "computed", "getter", "c", "computedOper", "effect", "fn", "e", "fn_", "link", "prev", "setCurrentSub", "effectOper", "peek", "run", "update", "updateComputed", "updateSignal", "sub", "prevSub", "startTracking", "oldValue", "endTracking", "s", "value", "notify", "flags", "subs", "subs_", "sub_", "checkDirty", "deps_", "dep", "dep_", "depFlags", "nextDep_", "shallowPropagate", "newValue", "propagate", "currentValue", "unlink", "prevDep", "depsTail_", "nextDep", "recursedCheck", "subsTail_", "isValidLink", "newLink", "prevDep_", "prevSub_", "nextSub_", "toRemove", "next", "stack", "top", "subSubs", "prev_", "checkDepth", "dirty", "firstSub", "hasMultipleSubs", "nextSub", "subFlags", "checkLink", "depsTail", "getPath", "path", "acc", "key", "root", "hasPath", "obj", "deep", "prefix", "isArr", "isPojo", "deepObj", "keys", "_", "prop", "pathToObj", "isEmpty", "oldPatch", "DATASTAR_SIGNAL_PATCH_EVENT", "mergePatch", "patch", "ifMissing", "mergeInner", "target", "targetParent", "filtered", "include", "exclude", "pathObj", "node", "actions", "plugins", "pluginRegexs", "removals", "mutationObserver", "alias", "setAlias", "aliasify", "name", "load", "pluginsToLoad", "plugin", "ctx", "initErr", "a", "b", "lenDiff", "applyEls", "els", "ignore", "el", "applyAttributePlugin", "apply", "observe", "attrKey", "rawKey", "camel", "i", "rawModifiers", "hasKey", "hasValue", "runtimeErr", "generateReactiveExpression", "keyReq", "valReq", "rawMod", "label", "mod", "t", "cleanup", "cleanups", "mutations", "type", "attributeName", "addedNodes", "removedNodes", "isHTMLOrSVG", "expr", "attrPlugin", "statementRe", "statements", "lastIdx", "last", "scope", "findClosestScoped", "match", "signalName", "part", "escaped", "escapeRe", "DSP", "DSS", "k", "v", "djb2", "nameGen", "snake", "actionsCalled", "actionsRe", "actionMatches", "actionNames", "actionFns", "actionPrefix", "DATASTAR", "actionName", "action", "args", "error", "str", "hash", "load", "Signals", "Computed", "Effect", "Peek", "peek", "fn", "SetAll", "filtered", "mergePatch", "peek", "value", "filter", "masked", "updateLeaves", "ToggleAll", "filtered", "mergePatch", "peek", "filter", "masked", "updateLeaves", "oldValue", "Attr", "el", "effect", "key", "rx", "syncAttr", "val", "observer", "obj", "cleanup", "k", "kebab", "value", "dataURIRegex", "textType", "numberType", "Bind", "el", "key", "mods", "value", "effect", "mergePatch", "runtimeErr", "getPath", "hasPath", "signalName", "modifyCasing", "modifyScope", "scopedModifier", "allBoundInputs", "aliasify", "inputIndex", "pathObj", "input", "pathToObj", "syncSignal", "cleanup", "val", "files", "allContents", "allMimes", "allNames", "f", "resolve", "reader", "match", "option", "signalValue", "observer", "Class", "key", "el", "effect", "mods", "rx", "addedClasses", "isUpdating", "observer", "cleanup", "className", "classes", "modifyCasing", "kebab", "k", "v", "classNames", "cn", "DATASTAR_SSE_EVENT", "DATASTAR", "STARTED", "FINISHED", "ERROR", "RETRYING", "RETRIES_FAILED", "datastarSSEEventWatcher", "eventType", "fn", "event", "argsRaw", "Indicator", "el", "key", "mods", "mergePatch", "value", "signalName", "modifyCasing", "modifyScope", "pathToObj", "watcher", "event", "type", "elt", "STARTED", "FINISHED", "DATASTAR_SSE_EVENT", "JsonSignals", "el", "effect", "value", "filtered", "mods", "spaces", "filters", "jsStrToObject", "callback", "observer", "cleanup", "tagToMs", "args", "arg", "tagHas", "tags", "tag", "defaultValue", "delay", "callback", "wait", "args", "debounce", "leading", "trailing", "timer", "throttle", "waiting", "modifyTiming", "mods", "delayArgs", "tagToMs", "debounceArgs", "tagHas", "throttleArgs", "supportsViewTransitions", "modifyViewTransition", "callback", "mods", "cb", "args", "On", "ctx", "el", "key", "mods", "rx", "startBatch", "endBatch", "target", "callback", "evt", "modifyTiming", "modifyViewTransition", "evtListOpts", "cb", "eventName", "kebab", "modifyCasing", "DATASTAR_SSE_EVENT", "DATASTAR_SIGNAL_PATCH_EVENT", "once", "OnIntersect", "el", "mods", "rx", "startBatch", "endBatch", "callback", "modifyTiming", "modifyViewTransition", "options", "observer", "entries", "entry", "OnInterval", "mods", "rx", "startBatch", "endBatch", "callback", "modifyViewTransition", "duration", "durationArgs", "tagToMs", "tagHas", "intervalId", "OnLoad", "rx", "mods", "startBatch", "endBatch", "callback", "modifyViewTransition", "wait", "delayArgs", "tagToMs", "delay", "Ref", "el", "key", "mods", "value", "mergePatch", "signalName", "modifyCasing", "modifyScope", "pathToObj", "Scope", "el", "value", "mods", "mergePatch", "scopeKey", "modifyScope", "scopeKeyObj", "acc", "part", "removalObj", "NONE", "DISPLAY", "Show", "el", "effect", "rx", "update", "observer", "cleanup", "Text", "el", "effect", "rx", "update", "observer", "cleanup", "dispatchSSE", "type", "el", "argsRaw", "DATASTAR_SSE_EVENT", "isWrongContent", "err", "sse", "evt", "filtered", "runtimeErr", "method", "url", "selector", "userHeaders", "contentType", "filterSignals", "openWhenHidden", "retryInterval", "DefaultSseRetryDurationMs", "retryScaler", "retryMaxWaitMs", "retryMaxCount", "abort", "action", "cleanupFn", "initialHeaders", "DATASTAR_REQUEST", "headers", "req", "response", "ERROR", "DATASTAR", "argsRawLines", "line", "i", "k", "v", "error", "RETRYING", "urlInstance", "queryParams", "res", "formEl", "formData", "submitter", "preventDefault", "name", "multipart", "formParams", "key", "value", "STARTED", "fetchEventSource", "FINISHED", "getBytes", "stream", "onChunk", "reader", "result", "getLines", "onLine", "buffer", "position", "fieldLength", "discardTrailingNewline", "arr", "concat", "bufLength", "lineStart", "lineEnd", "getMessages", "onId", "onRetry", "onMessage", "message", "newMessage", "decoder", "field", "valueOffset", "retry", "a", "b", "input", "inputSignal", "inputHeaders", "inputOnOpen", "onmessage", "onclose", "onerror", "inputFetch", "overrides", "rest", "resolve", "reject", "curRequestController", "onVisibilityChange", "create", "retryTimer", "dispose", "fetch", "onopen", "retries", "baseRetryInterval", "dispatchNonSSE", "dispatchType", "argNames", "n", "kebab", "o", "ct", "EventTypePatchElements", "EventTypePatchSignals", "script", "scriptAttributesHeader", "id", "interval", "RETRIES_FAILED", "innerErr", "createHttpMethod", "name", "method", "ctx", "url", "args", "sse", "DELETE", "createHttpMethod", "GET", "createHttpMethod", "PATCH", "createHttpMethod", "POST", "createHttpMethod", "PUT", "createHttpMethod", "PatchElements", "EventTypePatchElements", "ctx", "datastarSSEEventWatcher", "args", "onPatchElements", "elements", "selector", "mode", "DefaultElementPatchMode", "useViewTransition", "ElementPatchModeRemove", "targets", "initErr", "supportsViewTransitions", "target", "template", "node", "type", "selectorOrId", "applyToTargets", "scripts", "execute", "elScripts", "old", "script", "name", "value", "element", "capturedTargets", "ElementPatchModeOuter", "ElementPatchModeInner", "morph", "cloned", "ElementPatchModeReplace", "ElementPatchModePrepend", "ElementPatchModeAppend", "ElementPatchModeBefore", "ElementPatchModeAfter", "oldIdTagNameMap", "ctxIdMap", "ctxPersistentIds", "duplicateIds", "ctxPantry", "oldElt", "newElt", "ignore", "aliasify", "normalizedElt", "oldIdElements", "id", "tagName", "newIdElements", "populateIdMapWithTree", "morphChildren", "oldParent", "newParent", "insertionPoint", "endPoint", "newChild", "bestMatch", "findBestMatch", "cursor", "tempNode", "removeNode", "morphNode", "ncId", "movedChild", "current", "idSet", "moveBefore", "newEmptyChild", "newClonedChild", "startPoint", "nextSibling", "siblingSoftMatchCount", "displaceMatchCount", "nodeMatchCount", "isSoftMatch", "isIdSetMatch", "oldSet", "newSet", "oldNode", "newNode", "oldId", "preserveAttrs", "kebab", "oldAttrs", "i", "bind", "noBind", "key", "newValue", "root", "elt", "PatchSignals", "EventTypePatchSignals", "ctx", "datastarSSEEventWatcher", "raw", "onlyIfMissingRaw", "DefaultPatchSignalsOnlyIfMissing", "jsStrToObject", "isBoolString", "load", "GET", "POST", "PUT", "PATCH", "DELETE", "PatchElements", "PatchSignals", "Attr", "Bind", "Class", "Indicator", "JsonSignals", "On", "OnIntersect", "OnInterval", "OnLoad", "Ref", "Scope", "Show", "Text", "Peek", "SetAll", "ToggleAll", "apply"]
}
