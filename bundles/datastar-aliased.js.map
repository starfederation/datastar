{
  "version": 3,
  "sources": ["../library/src/engine/consts.ts", "../library/src/engine/types.ts", "../library/src/utils/text.ts", "../library/src/plugins/official/core/attributes/computed.ts", "../library/src/plugins/official/core/attributes/signals.ts", "../library/src/plugins/official/core/attributes/star.ts", "../library/src/utils/dom.ts", "../library/src/utils/timing.ts", "../library/src/engine/errors.ts", "../library/src/vendored/preact-core.ts", "../library/src/engine/signals.ts", "../library/src/engine/engine.ts", "../library/src/engine/index.ts", "../library/src/vendored/fetch-event-source.ts", "../library/src/plugins/official/backend/shared.ts", "../library/src/plugins/official/backend/actions/sse.ts", "../library/src/plugins/official/backend/actions/delete.ts", "../library/src/plugins/official/backend/actions/get.ts", "../library/src/plugins/official/backend/actions/patch.ts", "../library/src/plugins/official/backend/actions/post.ts", "../library/src/plugins/official/backend/actions/put.ts", "../library/src/plugins/official/backend/attributes/indicator.ts", "../library/src/plugins/official/backend/watchers/executeScript.ts", "../library/src/utils/view-transtions.ts", "../library/src/vendored/idiomorph.esm.js", "../library/src/plugins/official/backend/watchers/mergeFragments.ts", "../library/src/plugins/official/backend/watchers/mergeSignals.ts", "../library/src/plugins/official/backend/watchers/removeFragments.ts", "../library/src/plugins/official/backend/watchers/removeSignals.ts", "../library/src/plugins/official/browser/actions/clipboard.ts", "../library/src/plugins/official/browser/attributes/customValidity.ts", "../library/src/plugins/official/browser/attributes/intersects.ts", "../library/src/plugins/official/browser/attributes/persist.ts", "../library/src/plugins/official/browser/attributes/replaceUrl.ts", "../library/src/plugins/official/browser/attributes/scrollIntoView.ts", "../library/src/plugins/official/browser/attributes/show.ts", "../library/src/plugins/official/browser/attributes/viewTransition.ts", "../library/src/plugins/official/dom/attributes/attr.ts", "../library/src/plugins/official/dom/attributes/bind.ts", "../library/src/plugins/official/dom/attributes/class.ts", "../library/src/utils/tags.ts", "../library/src/plugins/official/dom/attributes/on.ts", "../library/src/plugins/official/dom/attributes/ref.ts", "../library/src/plugins/official/dom/attributes/text.ts", "../library/src/plugins/official/logic/actions/fit.ts", "../library/src/plugins/official/logic/actions/setAll.ts", "../library/src/plugins/official/logic/actions/toggleAll.ts", "../library/src/bundles/datastar-aliased.ts"],
  "sourcesContent": ["// This is auto-generated by Datastar. DO NOT EDIT.\nconst lol = /\uD83D\uDD95JS_DS\uD83D\uDE80/.source\nexport const DSP = lol.slice(0, 5)\nexport const DSS = lol.slice(4)\n\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_EVENT = \"datastar-event\";\nexport const DATASTAR_REQUEST = \"Datastar-Request\";\n\n// #region Defaults\n\n// #region Default durations\n\n// The default duration for settling during fragment merges. Allows for CSS transitions to complete.\nexport const DefaultFragmentsSettleDurationMs = 300;\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000;\n\n// #endregion\n\n\n// #region Default strings\n\n// The default attributes for <script/> element use when executing scripts. It is a set of key-value pairs delimited by a newline \\\\n character.\nexport const DefaultExecuteScriptAttributes = \"type module\";\n\n// #endregion\n\n\n// #region Default booleans\n\n// Should fragments be merged using the ViewTransition API?\nexport const DefaultFragmentsUseViewTransitions = false;\n\n// Should a given set of signals merge if they are missing?\nexport const DefaultMergeSignalsOnlyIfMissing = false;\n\n// Should script element remove itself after execution?\nexport const DefaultExecuteScriptAutoRemove = true;\n\n// #endregion\n\n\n// #region Enums\n\n// The mode in which a fragment is merged into the DOM.\nexport const FragmentMergeModes = {\n    // Morphs the fragment into the existing element using idiomorph.\n    Morph: \"morph\",\n    // Replaces the inner HTML of the existing element.\n    Inner: \"inner\",\n    // Replaces the outer HTML of the existing element.\n    Outer: \"outer\",\n    // Prepends the fragment to the existing element.\n    Prepend: \"prepend\",\n    // Appends the fragment to the existing element.\n    Append: \"append\",\n    // Inserts the fragment before the existing element.\n    Before: \"before\",\n    // Inserts the fragment after the existing element.\n    After: \"after\",\n    // Upserts the attributes of the existing element.\n    UpsertAttributes: \"upsertAttributes\",\n} as const;\n\n// Default value for FragmentMergeMode\nexport const DefaultFragmentMergeMode = FragmentMergeModes.Morph;\n\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\nexport const EventTypes = {\n    // An event for merging HTML fragments into the DOM.\n    MergeFragments: \"datastar-merge-fragments\",\n    // An event for merging signals.\n    MergeSignals: \"datastar-merge-signals\",\n    // An event for removing HTML fragments from the DOM.\n    RemoveFragments: \"datastar-remove-fragments\",\n    // An event for removing signals.\n    RemoveSignals: \"datastar-remove-signals\",\n    // An event for executing <script/> elements in the browser.\n    ExecuteScript: \"datastar-execute-script\",\n} as const;\n// #endregion\n\n// #endregion", "import type { EffectFn, Signal } from '../vendored/preact-core'\nimport { DATASTAR } from './consts'\nimport type { SignalsRoot } from './signals'\n\nexport type OnRemovalFn = () => void\n\nexport enum PluginType {\n  Attribute = 1,\n  Watcher = 2,\n  Action = 3,\n}\n\nexport interface DatastarPlugin {\n  type: PluginType // The type of plugin\n  name: string // The name of the plugin\n}\n\nexport enum Requirement {\n  Allowed = 0,\n  Must = 1,\n  Denied = 2,\n  Exclusive = 3,\n}\n\nexport interface DatastarSignalEvent {\n  added: Array<string>\n  removed: Array<string>\n  updated: Array<string>\n}\nexport const DATASTAR_SIGNAL_EVENT = `${DATASTAR}-signals`\nexport interface CustomEventMap {\n  [DATASTAR_SIGNAL_EVENT]: CustomEvent<DatastarSignalEvent>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\ndeclare global {\n  interface Document {\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n  }\n}\n\n// A plugin accesible via a `data-${name}` attribute on an element\nexport interface AttributePlugin extends DatastarPlugin {\n  type: PluginType.Attribute\n  onGlobalInit?: (ctx: InitContext) => void // Called once on registration of the plugin\n  onLoad: (ctx: RuntimeContext) => OnRemovalFn | void // Return a function to be called on removal\n  removeOnLoad?: (rawKey: string) => boolean // Return whether the attribute key should be removed after onLoad (useful for plugin attributes you don\u2019t want reapplied)\n  mods?: Set<string> // If not provided, all modifiers are allowed\n  keyReq?: Requirement // The rules for the key requirements\n  valReq?: Requirement // The rules for the value requirements\n  argNames?: string[] // argument names for the reactive expression\n}\n\n// A plugin that runs on the global scope of the DastaStar instance\nexport interface WatcherPlugin extends DatastarPlugin {\n  type: PluginType.Watcher\n  onGlobalInit?: (ctx: InitContext) => void\n}\n\nexport type ActionPlugins = Record<string, ActionPlugin>\nexport type ActionMethod = (ctx: RuntimeContext, ...args: any[]) => any\n\nexport interface ActionPlugin extends DatastarPlugin {\n  type: PluginType.Action\n  fn: ActionMethod\n}\n\nexport type GlobalInitializer = (ctx: InitContext) => void\n// export type RemovalEntry = { id: string; fns: Array<OnRemovalFn> }\n\nexport type InitContext = {\n  plugin: DatastarPlugin\n  signals: SignalsRoot\n  effect: (fn: EffectFn) => OnRemovalFn\n  actions: Readonly<ActionPlugins>\n  applyAttributePlugin: (el: HTMLorSVGElement, datasetKey: string) => void\n}\n\nexport type HTMLorSVGElement = Element & (HTMLElement | SVGElement)\nexport type Modifiers = Map<string, Set<string>> // mod name -> tags\n\nexport type RuntimeContext = InitContext & {\n  plugin: DatastarPlugin // The name of the plugin\n  el: HTMLorSVGElement // The element the attribute is on\n  rawKey: Readonly<string> // no parsing data-* key\n  key: Readonly<string> // data-* key without the prefix or tags\n  value: Readonly<string> // value of data-* attribute\n  mods: Modifiers // the tags and their arguments\n  genRX: () => <T>(...args: any[]) => T // a reactive expression\n  fnContent?: string // the content of the function\n}\n\nexport type NestedValues = { [key: string]: NestedValues | any }\nexport type NestedSignal = {\n  [key: string]: NestedSignal | Signal<any>\n}\n\nexport type RuntimeExpressionFunction = (\n  ctx: RuntimeContext,\n  ...args: any[]\n) => any\n", "import type { Modifiers } from '../engine/types'\n\nexport const isBoolString = (str: string) => str.trim() === 'true'\n\nexport const kebab = (str: string) =>\n  str.replace(\n    /[A-Z]+(?![a-z])|[A-Z]/g,\n    ($, ofs) => (ofs ? '-' : '') + $.toLowerCase(),\n  )\n\nexport const camel = (str: string) =>\n  kebab(str).replace(/-./g, (x) => x[1].toUpperCase())\n\nexport const snake = (str: string) => kebab(str).replace(/-/g, '_')\n\nexport const pascal = (str: string) =>\n  camel(str).replace(/^./, (x) => x[0].toUpperCase())\n\nexport const jsStrToObject = (raw: string) =>\n  new Function(`return Object.assign({}, ${raw})`)()\n\nexport const trimDollarSignPrefix = (str: string) =>\n  str.startsWith('$') ? str.slice(1) : str\n\nconst caseFns: Record<string, (s: string) => string> = { kebab, snake, pascal }\n\nexport function modifyCasing(str: string, mods: Modifiers) {\n  for (const c of mods.get('case') || []) {\n    const fn = caseFns[c]\n    if (fn) str = fn(str)\n  }\n  return str\n}\n", "import {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { modifyCasing } from '../../../../utils/text'\n\nconst name = 'computed'\nexport const Computed: AttributePlugin = {\n  type: PluginType.Attribute,\n  name,\n  keyReq: Requirement.Must,\n  valReq: Requirement.Must,\n  onLoad: ({ key, mods, signals, genRX }) => {\n    key = modifyCasing(key, mods)\n    const rx = genRX()\n    signals.setComputed(key, rx)\n  },\n}\n", "import {\n  type AttributePlugin,\n  type NestedValues,\n  PluginType,\n} from '../../../../engine/types'\nimport { jsStrToObject, modifyCasing } from '../../../../utils/text'\n\nexport const Signals: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'signals',\n  removeOnLoad: () => true,\n  onLoad: (ctx) => {\n    const { key, mods, signals, value, genRX } = ctx\n    const ifMissing = mods.has('ifmissing')\n\n    if (key !== '') {\n      const k = modifyCasing(key, mods)\n      const v = value === '' ? value : genRX()()\n      if (ifMissing) {\n        signals.upsertIfMissing(k, v)\n      } else {\n        signals.setValue(k, v)\n      }\n    } else {\n      const obj = jsStrToObject(ctx.value)\n      ctx.value = JSON.stringify(obj)\n      const rx = genRX()\n      const nv = rx<NestedValues>()\n      signals.merge(nv, ifMissing)\n    }\n  },\n}\n", "import {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nexport const Star: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'star',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Denied,\n  onLoad: () => {\n    alert('YOU ARE PROBABLY OVERCOMPLICATING IT')\n  },\n}\n", "import { DATASTAR } from '../engine/consts'\n\nexport class Hash {\n  #value = 0\n  #prefix: string\n\n  constructor(prefix = DATASTAR) {\n    this.#prefix = prefix\n  }\n\n  with(x: number | string): Hash {\n    if (typeof x === 'string') {\n      for (const c of x.split('')) {\n        this.with(c.charCodeAt(0))\n      }\n    } else {\n      this.#value = (this.#value << 5) - this.#value + x\n    }\n    return this\n  }\n\n  get value() {\n    return this.#prefix + Math.abs(this.#value).toString(36)\n  }\n}\n\nexport function elUniqId(el: Element) {\n  if (el.id) return el.id\n  const hash = new Hash()\n\n  let currentEl = el\n  while (currentEl.parentNode) {\n    if (currentEl.id) {\n      hash.with(currentEl.id)\n      break\n    }\n    if (currentEl === currentEl.ownerDocument.documentElement) {\n      hash.with(currentEl.tagName)\n    } else {\n      for (\n        let i = 1, e = el;\n        e.previousElementSibling;\n        e = e.previousElementSibling, i++\n      ) {\n        hash.with(i)\n      }\n    }\n\n    currentEl = currentEl.parentNode as Element\n  }\n  return hash.value\n}\n\nexport function onElementRemoved(element: Element, callback: () => void) {\n  const observer = new MutationObserver((mutations) => {\n    for (const mutation of mutations) {\n      for (const removedNode of mutation.removedNodes) {\n        if (removedNode === element) {\n          observer.disconnect()\n          callback()\n          return\n        }\n      }\n    }\n  })\n  observer.observe(element.parentNode as Node, { childList: true })\n}\n", "export type TimerHandler = (...args: any[]) => void\n\nexport function delay(\n  callback: TimerHandler,\n  wait: number,\n): TimerHandler {\n  return (...args: any[]) => {\n    setTimeout(() => {\n      callback(...args)\n    }, wait)\n  }\n}\n\nexport function debounce(\n  callback: TimerHandler,\n  wait: number,\n  leading = false,\n  trailing = true,\n): TimerHandler {\n  let timer = -1\n\n  const resetTimer = () => timer && clearTimeout(timer)\n\n  return (...args: any[]) => {\n    resetTimer()\n\n    if (leading && !timer) {\n      callback(...args)\n    }\n\n    timer = setTimeout(() => {\n      if (trailing) {\n        callback(...args)\n      }\n      resetTimer()\n    }, wait)\n  }\n}\n\nexport function throttle(\n  callback: TimerHandler,\n  wait: number,\n  leading = true,\n  trailing = false,\n): TimerHandler {\n  let waiting = false\n\n  return (...args: any[]) => {\n    if (waiting) return\n\n    if (leading) {\n      callback(...args)\n    }\n\n    waiting = true\n    setTimeout(() => {\n      waiting = false\n      if (trailing) {\n        callback(...args)\n      }\n    }, wait)\n  }\n}\n", "import { snake } from '../utils/text'\nimport { DATASTAR } from './consts'\nimport { type InitContext, PluginType, type RuntimeContext } from './types'\n\nconst url = 'https://data-star.dev/errors'\n//const url = `${window.location.origin}/errors`\n\ninterface Metadata {\n  error?: string\n  [key: string]: any\n}\n\nfunction dserr(type: string, reason: string, metadata: Metadata = {}) {\n  const e = new Error()\n  e.name = `${DATASTAR} ${type} error`\n  const r = snake(reason)\n  const q = new URLSearchParams({\n    metadata: JSON.stringify(metadata),\n  }).toString()\n  const c = JSON.stringify(metadata, null, 2)\n  e.message = `${reason}\\nMore info: ${url}/${type}/${r}?${q}\\nContext: ${c}`\n  return e\n}\n\nexport function internalErr(from: string, reason: string, args = {}) {\n  return dserr('internal', reason, Object.assign({ from }, args))\n}\n\nexport function initErr(reason: string, ctx: InitContext, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: PluginType[ctx.plugin.type],\n    },\n  }\n  return dserr('init', reason, Object.assign(errCtx, metadata))\n}\n\nexport function runtimeErr(reason: string, ctx: RuntimeContext, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: PluginType[ctx.plugin.type],\n    },\n    element: {\n      id: ctx.el.id,\n      tag: ctx.el.tagName,\n    },\n    expression: {\n      rawKey: ctx.rawKey,\n      key: ctx.key,\n      value: ctx.value,\n      validSignals: ctx.signals.paths(),\n      fnContent: ctx.fnContent,\n    },\n  }\n  return dserr('runtime', reason, Object.assign(errCtx, metadata))\n}\n", "import { internalErr } from '../engine/errors'\nimport type { OnRemovalFn } from '../engine/types'\n\nconst from = 'preact-signals'\n\n// An named symbol/brand for detecting Signal instances even when they weren't\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for('preact-signals')\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0\nconst NOTIFIED = 1 << 1\nconst OUTDATED = 1 << 2\nconst DISPOSED = 1 << 3\nconst HAS_ERROR = 1 << 4\nconst TRACKING = 1 << 5\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n  // A source whose value the target depends on.\n  _source: Signal\n  _prevSource?: Node\n  _nextSource?: Node\n\n  // A target that depends on the source and should be notified when the source changes.\n  _target: Computed | Effect\n  _prevTarget?: Node\n  _nextTarget?: Node\n\n  // The version number of the source that target has last seen. We use version numbers\n  // instead of storing the source value, because source values can take arbitrary amount\n  // of memory, and computeds could hang on to them forever because they're lazily evaluated.\n  // Use the special value -1 to mark potentially unused but recyclable nodes.\n  _version: number\n\n  // Used to remember & roll back the source's previous `._node` value when entering &\n  // exiting a new evaluation context.\n  _rollbackNode?: Node\n}\n\nfunction startBatch() {\n  batchDepth++\n}\n\nfunction endBatch() {\n  if (batchDepth > 1) {\n    batchDepth--\n    return\n  }\n\n  let error: unknown\n  let hasError = false\n\n  while (batchedEffect !== undefined) {\n    let effect: Effect | undefined = batchedEffect\n    batchedEffect = undefined\n\n    batchIteration++\n\n    while (effect !== undefined) {\n      const next: Effect | undefined = effect._nextBatchedEffect\n      effect._nextBatchedEffect = undefined\n      effect._flags &= ~NOTIFIED\n\n      if (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n        try {\n          effect._callback()\n        } catch (err) {\n          if (!hasError) {\n            error = err\n            hasError = true\n          }\n        }\n      }\n      effect = next\n    }\n  }\n  batchIteration = 0\n  batchDepth--\n\n  if (hasError) {\n    throw internalErr(from, 'BatchError, error', { error })\n  }\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n  if (batchDepth > 0) {\n    return fn()\n  }\n  /*@__INLINE__**/ startBatch()\n  try {\n    return fn()\n  } finally {\n    endBatch()\n  }\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n  const prevContext = evalContext\n  evalContext = undefined\n  try {\n    return fn()\n  } finally {\n    evalContext = prevContext\n  }\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined\nlet batchDepth = 0\nlet batchIteration = 0\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0\n\nfunction addDependency(signal: Signal): Node | undefined {\n  if (evalContext === undefined) {\n    return undefined\n  }\n\n  let node = signal._node\n  if (node === undefined || node._target !== evalContext) {\n    /**\n     * `signal` is a new dependency. Create a new dependency node, and set it\n     * as the tail of the current context's dependency list. e.g:\n     *\n     * { A <-> B       }\n     *         \u2191     \u2191\n     *        tail  node (new)\n     *               \u2193\n     * { A <-> B <-> C }\n     *               \u2191\n     *              tail (evalContext._sources)\n     */\n    node = {\n      _version: 0,\n      _source: signal,\n      _prevSource: evalContext._sources,\n      _nextSource: undefined,\n      _target: evalContext,\n      _prevTarget: undefined,\n      _nextTarget: undefined,\n      _rollbackNode: node,\n    }\n\n    if (evalContext._sources !== undefined) {\n      evalContext._sources._nextSource = node\n    }\n    evalContext._sources = node\n    signal._node = node\n\n    // Subscribe to change notifications from this dependency if we're in an effect\n    // OR evaluating a computed signal that in turn has subscribers.\n    if (evalContext._flags & TRACKING) {\n      signal._subscribe(node)\n    }\n    return node\n  }\n  if (node._version === -1) {\n    // `signal` is an existing dependency from a previous evaluation. Reuse it.\n    node._version = 0\n\n    /**\n     * If `node` is not already the current tail of the dependency list (i.e.\n     * there is a next node in the list), then make the `node` the new tail. e.g:\n     *\n     * { A <-> B <-> C <-> D }\n     *         \u2191           \u2191\n     *        node   \u250C\u2500\u2500\u2500 tail (evalContext._sources)\n     *         \u2514\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2510\n     *               \u2193     \u2193\n     * { A <-> C <-> D <-> B }\n     *                     \u2191\n     *                    tail (evalContext._sources)\n     */\n    if (node._nextSource !== undefined) {\n      node._nextSource._prevSource = node._prevSource\n\n      if (node._prevSource !== undefined) {\n        node._prevSource._nextSource = node._nextSource\n      }\n\n      node._prevSource = evalContext._sources\n      node._nextSource = undefined\n\n      evalContext._sources!._nextSource = node\n      evalContext._sources = node\n    }\n\n    // We can assume that the currently evaluated effect / computed signal is already\n    // subscribed to change notifications from `signal` if needed.\n    return node\n  }\n  return undefined\n}\n\n/**\n * The base class for plain and computed signals.\n */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style protoTYPEOF_\n// This enables better control of the transpiled output size.\ndeclare class Signal<T = any> {\n  /** @internal */\n  _value: unknown\n\n  /**\n   * @internal\n   * Version numbers should always be >= 0, because the special value -1 is used\n   * by Nodes to signify potentially unused but recyclable nodes.\n   */\n  _version: number\n\n  /** @internal */\n  _node?: Node\n\n  /** @internal */\n  _targets?: Node\n\n  constructor(value?: T)\n\n  /** @internal */\n  _refresh(): boolean\n\n  /** @internal */\n  _subscribe(node: Node): void\n\n  /** @internal */\n  _unsubscribe(node: Node): void\n\n  subscribe(fn: (value: T) => void): () => void\n\n  valueOf(): T\n\n  toString(): string\n\n  toJSON(): T\n\n  peek(): T\n\n  brand: typeof BRAND_SYMBOL\n\n  get value(): T\n  set value(value: T)\n}\n\n/** @internal */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style protoTYPEOF_\n// This enables better control of the transpiled output size.\n// biome-ignore lint/suspicious/noRedeclare: <explanation>\nfunction Signal(this: Signal, value?: unknown) {\n  this._value = value\n  this._version = 0\n  this._node = undefined\n  this._targets = undefined\n}\n\nSignal.prototype.brand = BRAND_SYMBOL\n\nSignal.prototype._refresh = () => true\n\nSignal.prototype._subscribe = function (node) {\n  if (this._targets !== node && node._prevTarget === undefined) {\n    node._nextTarget = this._targets\n    if (this._targets !== undefined) {\n      this._targets._prevTarget = node\n    }\n    this._targets = node\n  }\n}\n\nSignal.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the signal has any subscribers to begin with.\n  if (this._targets !== undefined) {\n    const prev = node._prevTarget\n    const next = node._nextTarget\n    if (prev !== undefined) {\n      prev._nextTarget = next\n      node._prevTarget = undefined\n    }\n    if (next !== undefined) {\n      next._prevTarget = prev\n      node._nextTarget = undefined\n    }\n    if (node === this._targets) {\n      this._targets = next\n    }\n  }\n}\n\nSignal.prototype.subscribe = function (fn) {\n  return effect(() => {\n    const value = this.value\n\n    const prevContext = evalContext\n    evalContext = undefined\n    try {\n      fn(value)\n    } finally {\n      evalContext = prevContext\n    }\n  })\n}\n\nSignal.prototype.valueOf = function () {\n  return this.value\n}\n\nSignal.prototype.toString = function () {\n  return `${this.value}`\n}\n\nSignal.prototype.toJSON = function () {\n  return this.value\n}\n\nSignal.prototype.peek = function () {\n  const prevContext = evalContext\n  evalContext = undefined\n  try {\n    return this.value\n  } finally {\n    evalContext = prevContext\n  }\n}\n\nObject.defineProperty(Signal.prototype, 'value', {\n  get(this: Signal) {\n    const node = addDependency(this)\n    if (node !== undefined) {\n      node._version = this._version\n    }\n    return this._value\n  },\n  set(this: Signal, value) {\n    if (value !== this._value) {\n      if (batchIteration > 100) {\n        throw internalErr(from, 'SignalCycleDetected')\n      }\n\n      this._value = value\n      this._version++\n      globalVersion++\n\n      /**@__INLINE__*/ startBatch()\n      try {\n        for (\n          let node = this._targets;\n          node !== undefined;\n          node = node._nextTarget\n        ) {\n          node._target._notify()\n        }\n      } finally {\n        endBatch()\n      }\n    }\n  },\n})\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T): Signal<T>\nexport function signal<T = undefined>(): Signal<T | undefined>\nexport function signal<T>(value?: T): Signal<T> {\n  return new Signal(value)\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n  // Check the dependencies for changed values. The dependency list is already\n  // in order of use. Therefore if multiple dependencies have changed values, only\n  // the first used dependency is re-evaluated at this point.\n  for (\n    let node = target._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    // If there's a new version of the dependency before or after refreshing,\n    // or the dependency has something blocking it from refreshing at all (e.g. a\n    // dependency cycle), then we need to recompute.\n    if (\n      node._source._version !== node._version ||\n      !node._source._refresh() ||\n      node._source._version !== node._version\n    ) {\n      return true\n    }\n  }\n  // If none of the dependencies have changed values since last recompute then\n  // there's no need to recompute.\n  return false\n}\n\nfunction prepareSources(target: Computed | Effect) {\n  /**\n   * 1. Mark all current sources as re-usable nodes (version: -1)\n   * 2. Set a rollback node if the current node is being used in a different context\n   * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n   *\n   *    { undefined <- A <-> B <-> C -> undefined }\n   *                   \u2191           \u2191\n   *                   \u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   * target._sources = A; (node is head)  \u2502\n   *                   \u2193                  \u2502\n   * target._sources = C; (node is tail) \u2500\u2518\n   */\n  for (\n    let node = target._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    const rollbackNode = node._source._node\n    if (rollbackNode !== undefined) {\n      node._rollbackNode = rollbackNode\n    }\n    node._source._node = node\n    node._version = -1\n\n    if (node._nextSource === undefined) {\n      target._sources = node\n      break\n    }\n  }\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n  let node = target._sources\n  let head: Node | undefined = undefined\n\n  /**\n   * At this point 'target._sources' points to the tail of the doubly-linked list.\n   * It contains all existing sources + new sources in order of use.\n   * Iterate backwards until we find the head node while dropping old dependencies.\n   */\n  while (node !== undefined) {\n    const prev = node._prevSource\n\n    /**\n     * The node was not re-used, unsubscribe from its change notifications and remove itself\n     * from the doubly-linked list. e.g:\n     *\n     * { A <-> B <-> C }\n     *         \u2193\n     *    { A <-> C }\n     */\n    if (node._version === -1) {\n      node._source._unsubscribe(node)\n\n      if (prev !== undefined) {\n        prev._nextSource = node._nextSource\n      }\n      if (node._nextSource !== undefined) {\n        node._nextSource._prevSource = prev\n      }\n    } else {\n      /**\n       * The new head is the last node seen which wasn't removed/unsubscribed\n       * from the doubly-linked list. e.g:\n       *\n       * { A <-> B <-> C }\n       *   \u2191     \u2191     \u2191\n       *   \u2502     \u2502     \u2514 head = node\n       *   \u2502     \u2514 head = node\n       *   \u2514 head = node\n       */\n      head = node\n    }\n\n    node._source._node = node._rollbackNode\n    if (node._rollbackNode !== undefined) {\n      node._rollbackNode = undefined\n    }\n\n    node = prev\n  }\n\n  target._sources = head\n}\n\nexport declare class Computed<T = any> extends Signal<T> {\n  _fn: () => T\n  _sources?: Node\n  _globalVersion: number\n  _flags: number\n\n  constructor(fn: () => T)\n\n  _notify(): void\n  get value(): T\n}\n\n// biome-ignore lint/suspicious/noRedeclare: <explanation>\nexport function Computed(this: Computed, fn: () => unknown) {\n  Signal.call(this, undefined)\n\n  this._fn = fn\n  this._sources = undefined\n  this._globalVersion = globalVersion - 1\n  this._flags = OUTDATED\n}\n\nComputed.prototype = new Signal() as Computed\n\nComputed.prototype._refresh = function () {\n  this._flags &= ~NOTIFIED\n\n  if (this._flags & RUNNING) {\n    return false\n  }\n\n  // If this computed signal has subscribed to updates from its dependencies\n  // (TRACKING flag set) and none of them have notified about changes (OUTDATED\n  // flag not set), then the computed value can't have changed.\n  if ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n    return true\n  }\n  this._flags &= ~OUTDATED\n\n  if (this._globalVersion === globalVersion) {\n    return true\n  }\n  this._globalVersion = globalVersion\n\n  // Mark this computed signal running before checking the dependencies for value\n  // changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n  this._flags |= RUNNING\n  if (this._version > 0 && !needsToRecompute(this)) {\n    this._flags &= ~RUNNING\n    return true\n  }\n\n  const prevContext = evalContext\n  try {\n    prepareSources(this)\n    evalContext = this\n    const value = this._fn()\n    if (\n      this._flags & HAS_ERROR ||\n      this._value !== value ||\n      this._version === 0\n    ) {\n      this._value = value\n      this._flags &= ~HAS_ERROR\n      this._version++\n    }\n  } catch (err) {\n    this._value = err\n    this._flags |= HAS_ERROR\n    this._version++\n  }\n  evalContext = prevContext\n  cleanupSources(this)\n  this._flags &= ~RUNNING\n  return true\n}\n\nComputed.prototype._subscribe = function (node) {\n  if (this._targets === undefined) {\n    this._flags |= OUTDATED | TRACKING\n\n    // A computed signal subscribes lazily to its dependencies when it\n    // gets its first subscriber.\n    for (\n      let node = this._sources;\n      node !== undefined;\n      node = node._nextSource\n    ) {\n      node._source._subscribe(node)\n    }\n  }\n  Signal.prototype._subscribe.call(this, node)\n}\n\nComputed.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the computed signal has any subscribers.\n  if (this._targets !== undefined) {\n    Signal.prototype._unsubscribe.call(this, node)\n\n    // Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n    // This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n    if (this._targets === undefined) {\n      this._flags &= ~TRACKING\n\n      for (\n        let node = this._sources;\n        node !== undefined;\n        node = node._nextSource\n      ) {\n        node._source._unsubscribe(node)\n      }\n    }\n  }\n}\n\nComputed.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= OUTDATED | NOTIFIED\n\n    for (\n      let node = this._targets;\n      node !== undefined;\n      node = node._nextTarget\n    ) {\n      node._target._notify()\n    }\n  }\n}\n\nObject.defineProperty(Computed.prototype, 'value', {\n  get(this: Computed) {\n    if (this._flags & RUNNING) {\n      // Cycle detected\n      throw internalErr(from, 'SignalCycleDetected')\n    }\n    const node = addDependency(this)\n    this._refresh()\n    if (node !== undefined) {\n      node._version = this._version\n    }\n    if (this._flags & HAS_ERROR) {\n      throw internalErr(from, 'GetComputedError', { value: this._value })\n    }\n    return this._value\n  },\n})\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n  readonly value: T\n  peek(): T\n\n  subscribe(fn: (value: T) => void): () => void\n  valueOf(): T\n  toString(): string\n  toJSON(): T\n  brand: typeof BRAND_SYMBOL\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(fn: () => T): ReadonlySignal<T> {\n  return new Computed(fn)\n}\n\nfunction cleanupEffect(effect: Effect) {\n  const cleanup = effect._cleanup\n  effect._cleanup = undefined\n\n  if (typeof cleanup === 'function') {\n    /*@__INLINE__**/ startBatch()\n\n    // Run cleanup functions always outside of any context.\n    const prevContext = evalContext\n    evalContext = undefined\n    try {\n      cleanup!()\n    } catch (error) {\n      effect._flags &= ~RUNNING\n      effect._flags |= DISPOSED\n      disposeEffect(effect)\n      throw internalErr(from, 'CleanupEffectError', { error })\n    } finally {\n      evalContext = prevContext\n      endBatch()\n    }\n  }\n}\n\nfunction disposeEffect(effect: Effect) {\n  for (\n    let node = effect._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    node._source._unsubscribe(node)\n  }\n  effect._fn = undefined\n  effect._sources = undefined\n\n  cleanupEffect(effect)\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n  if (evalContext !== this) {\n    throw internalErr(from, 'EndEffectError')\n  }\n  cleanupSources(this)\n  evalContext = prevContext\n\n  this._flags &= ~RUNNING\n  if (this._flags & DISPOSED) {\n    disposeEffect(this)\n  }\n  endBatch()\n}\n\nexport type EffectFn = () => OnRemovalFn | void | Promise<OnRemovalFn | void>\n\ndeclare class Effect {\n  _fn?: EffectFn\n  _cleanup?: () => void\n  _sources?: Node\n  _nextBatchedEffect?: Effect\n  _flags: number\n\n  constructor(fn: EffectFn)\n\n  _callback(): void\n  _start(): () => void\n  _notify(): void\n  _dispose(): void\n}\n\n// biome-ignore lint/suspicious/noRedeclare: <explanation>\nfunction Effect(this: Effect, fn: EffectFn) {\n  this._fn = fn\n  this._cleanup = undefined\n  this._sources = undefined\n  this._nextBatchedEffect = undefined\n  this._flags = TRACKING\n}\n\nEffect.prototype._callback = function () {\n  const finish = this._start()\n  try {\n    if (this._flags & DISPOSED) return\n    if (this._fn === undefined) return\n\n    const cleanup = this._fn()\n    if (typeof cleanup === 'function') {\n      this._cleanup = cleanup!\n    }\n  } finally {\n    finish()\n  }\n}\n\nEffect.prototype._start = function () {\n  if (this._flags & RUNNING) {\n    throw internalErr(from, 'SignalCycleDetected')\n  }\n  this._flags |= RUNNING\n  this._flags &= ~DISPOSED\n  cleanupEffect(this)\n  prepareSources(this)\n\n  /*@__INLINE__**/ startBatch()\n  const prevContext = evalContext\n  evalContext = this\n  return endEffect.bind(this, prevContext)\n}\n\nEffect.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= NOTIFIED\n    this._nextBatchedEffect = batchedEffect\n    batchedEffect = this\n  }\n}\n\nEffect.prototype._dispose = function () {\n  this._flags |= DISPOSED\n\n  if (!(this._flags & RUNNING)) {\n    disposeEffect(this)\n  }\n}\n\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn): () => void {\n  const effect = new Effect(fn)\n  try {\n    effect._callback()\n  } catch (error) {\n    effect._dispose()\n    // Throw the error, since it is already a Datastar error.\n    throw error\n  }\n  // Return a bound function instead of a wrapper like `() => effect._dispose()`,\n  // because bound functions seem to be just as fast and take up a lot less memory.\n  return effect._dispose.bind(effect)\n}\n\nexport { batch, computed, effect, Signal, untracked }\nexport type { ReadonlySignal }\n", "import { type Computed, Signal, computed } from '../vendored/preact-core'\nimport { internalErr } from './errors'\nimport {\n  DATASTAR_SIGNAL_EVENT,\n  type DatastarSignalEvent,\n  type NestedSignal,\n  type NestedValues,\n} from './types'\n\nconst from = 'namespacedSignals'\n\nconst dispatchSignalEvent = (evt: Partial<DatastarSignalEvent>) => {\n  document.dispatchEvent(\n    new CustomEvent<DatastarSignalEvent>(DATASTAR_SIGNAL_EVENT, {\n      detail: Object.assign({ added: [], removed: [], updated: [] }, evt),\n    }),\n  )\n}\n// If onlyPublic is true, only signals not starting with an underscore are included\nfunction nestedValues(\n  signal: NestedSignal,\n  onlyPublic = false,\n): Record<string, any> {\n  const kv: Record<string, any> = {}\n  for (const key in signal) {\n    if (Object.hasOwn(signal, key)) {\n      if (onlyPublic && key.startsWith('_')) {\n        continue\n      }\n      const value = signal[key]\n      if (value instanceof Signal) {\n        kv[key] = value.value\n      } else {\n        kv[key] = nestedValues(value)\n      }\n    }\n  }\n  return kv\n}\n\nfunction mergeNested(\n  target: NestedValues,\n  values: NestedValues,\n  onlyIfMissing = false,\n) {\n  const evt: DatastarSignalEvent = {\n    added: [],\n    removed: [],\n    updated: [],\n  }\n  for (const key in values) {\n    if (Object.hasOwn(values, key)) {\n      if (key.match(/\\_\\_+/)) {\n        throw internalErr(from, 'InvalidSignalKey', { key })\n      }\n\n      const value = values[key]\n      if (value instanceof Object && !Array.isArray(value)) {\n        if (!target[key]) {\n          target[key] = {}\n        }\n        const subEvt = mergeNested(\n          target[key] as NestedValues,\n          value as NestedValues,\n          onlyIfMissing,\n        )\n        evt.added.push(...subEvt.added.map((k) => `${key}.${k}`))\n        evt.removed.push(...subEvt.removed.map((k) => `${key}.${k}`))\n        evt.updated.push(...subEvt.updated.map((k) => `${key}.${k}`))\n      } else {\n        const hasKey = Object.hasOwn(target, key)\n        if (hasKey) {\n          if (onlyIfMissing) continue\n          const t = target[key]\n          if (t instanceof Signal) {\n            const oldValue = t.value\n            t.value = value\n            if (oldValue !== value) {\n              evt.updated.push(key)\n            }\n            continue\n          }\n        }\n\n        target[key] = new Signal(value)\n        evt.added.push(key)\n      }\n    }\n  }\n  return evt\n}\n\nfunction walkNestedSignal(\n  signal: NestedSignal,\n  cb: (dotDeliminatedPath: string, signal: Signal<any>) => void,\n): void {\n  for (const key in signal) {\n    if (Object.hasOwn(signal, key)) {\n      const value = signal[key]\n      if (value instanceof Signal) {\n        cb(key, value)\n      } else {\n        walkNestedSignal(value, (path, value) => {\n          cb(`${key}.${path}`, value)\n        })\n      }\n    }\n  }\n}\n\n// Recursive function to subset a nested object, each key is a dot-delimited path\nfunction nestedSubset(original: NestedValues, ...keys: string[]): NestedValues {\n  const subset: NestedValues = {}\n  for (const key of keys) {\n    const parts = key.split('.')\n    let subOriginal = original\n    let subSubset = subset\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subOriginal[part]) {\n        return {}\n      }\n      if (!subSubset[part]) {\n        subSubset[part] = {}\n      }\n      subOriginal = subOriginal[part] as NestedValues\n      subSubset = subSubset[part] as NestedValues\n    }\n    const last = parts[parts.length - 1]\n    subSubset[last] = subOriginal[last]\n  }\n  return subset\n}\n\n// Recursively walk a NestedValue with a callback and dot-delimited path\nexport function walkNestedValues(\n  nv: NestedValues,\n  cb: (path: string, value: any) => void,\n) {\n  for (const key in nv) {\n    if (Object.hasOwn(nv, key)) {\n      const value = nv[key]\n      if (value instanceof Object && !Array.isArray(value)) {\n        walkNestedValues(value, (path, value) => {\n          cb(`${key}.${path}`, value)\n        })\n      } else {\n        cb(key, value)\n      }\n    }\n  }\n}\n\nexport class SignalsRoot {\n  #signals: NestedSignal = {}\n\n  exists(dotDelimitedPath: string): boolean {\n    return !!this.signal(dotDelimitedPath)\n  }\n\n  signal<T>(dotDelimitedPath: string): Signal<T> | null {\n    const parts = dotDelimitedPath.split('.')\n    let subSignals = this.#signals\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subSignals[part]) {\n        return null\n      }\n      subSignals = subSignals[part] as NestedSignal\n    }\n    const last = parts[parts.length - 1]\n    const signal = subSignals[last]\n    if (!signal)\n      throw internalErr(from, 'SignalNotFound', { path: dotDelimitedPath })\n    return signal as Signal<T>\n  }\n\n  setSignal<T extends Signal<T>>(dotDelimitedPath: string, signal: T) {\n    const parts = dotDelimitedPath.split('.')\n    let subSignals = this.#signals\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subSignals[part]) {\n        subSignals[part] = {}\n      }\n      subSignals = subSignals[part] as NestedSignal\n    }\n    const last = parts[parts.length - 1]\n    subSignals[last] = signal\n  }\n\n  setComputed<T>(dotDelimitedPath: string, fn: () => T) {\n    const signal = computed(() => fn()) as Computed\n    this.setSignal(dotDelimitedPath, signal)\n  }\n\n  value<T>(dotDelimitedPath: string): T {\n    const signal = this.signal(dotDelimitedPath) as Signal<T>\n    return signal?.value\n  }\n\n  setValue<T>(dotDelimitedPath: string, value: T) {\n    const s = this.upsertIfMissing(dotDelimitedPath, value)\n    const oldValue = s.value\n    s.value = value\n    if (oldValue !== value) {\n      dispatchSignalEvent({ updated: [dotDelimitedPath] })\n    }\n  }\n\n  upsertIfMissing<T>(dotDelimitedPath: string, defaultValue: T) {\n    const parts = dotDelimitedPath.split('.')\n    let subSignals = this.#signals\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subSignals[part]) {\n        subSignals[part] = {}\n      }\n      subSignals = subSignals[part] as NestedSignal\n    }\n    const last = parts[parts.length - 1]\n\n    const current = subSignals[last]\n    if (current instanceof Signal) {\n      return current as Signal<T>\n    }\n\n    const signal = new Signal(defaultValue)\n    subSignals[last] = signal\n\n    dispatchSignalEvent({ added: [dotDelimitedPath] })\n\n    return signal\n  }\n\n  remove(...dotDelimitedPaths: string[]) {\n    if (!dotDelimitedPaths.length) {\n      this.#signals = {}\n      return\n    }\n    const removed = Array<string>()\n    for (const path of dotDelimitedPaths) {\n      const parts = path.split('.')\n      let subSignals = this.#signals\n      for (let i = 0; i < parts.length - 1; i++) {\n        const part = parts[i]\n        if (!subSignals[part]) {\n          return\n        }\n        subSignals = subSignals[part] as NestedSignal\n      }\n      const last = parts[parts.length - 1]\n      delete subSignals[last]\n      removed.push(path)\n    }\n    dispatchSignalEvent({ removed })\n  }\n\n  merge(other: NestedValues, onlyIfMissing = false) {\n    const evt = mergeNested(this.#signals, other, onlyIfMissing)\n    if (evt.added.length || evt.removed.length || evt.updated.length) {\n      dispatchSignalEvent(evt)\n    }\n  }\n\n  subset(...keys: string[]): NestedValues {\n    return nestedSubset(this.values(), ...keys)\n  }\n\n  walk(cb: (name: string, signal: Signal<any>) => void) {\n    walkNestedSignal(this.#signals, cb)\n  }\n\n  paths() {\n    const signalNames = new Array<string>()\n    this.walk((path) => signalNames.push(path))\n    return signalNames\n  }\n\n  values(onlyPublic = false): NestedValues {\n    return nestedValues(this.#signals, onlyPublic)\n  }\n\n  JSON(shouldIndent = true, onlyPublic = false) {\n    const values = this.values(onlyPublic)\n    if (!shouldIndent) {\n      return JSON.stringify(values)\n    }\n    return JSON.stringify(values, null, 2)\n  }\n\n  public toString() {\n    return this.JSON()\n  }\n}\n", "import { Hash, elUniqId } from '../utils/dom'\nimport { camel } from '../utils/text'\nimport { delay } from '../utils/timing'\nimport { effect } from '../vendored/preact-core'\nimport { DSP, DSS } from './consts'\nimport { initErr, runtimeErr } from './errors'\nimport { SignalsRoot } from './signals'\nimport {\n  type ActionPlugin,\n  type ActionPlugins,\n  type AttributePlugin,\n  type DatastarPlugin,\n  type GlobalInitializer,\n  type HTMLorSVGElement,\n  type InitContext,\n  type OnRemovalFn,\n  PluginType,\n  Requirement,\n  type RuntimeContext,\n  type RuntimeExpressionFunction,\n  type WatcherPlugin,\n} from './types'\n\nconst removalKey = (k: string, v: string) => `${k}${DSP}${v}`\n\nexport class Engine {\n  aliasPrefix = ''\n  #signals: SignalsRoot = new SignalsRoot()\n  #plugins: AttributePlugin[] = []\n  #actions: ActionPlugins = {}\n  #watchers: WatcherPlugin[] = []\n  #mutationObserver: MutationObserver | null = null\n\n  // Map of cleanup functions by element, keyed by the dataset key and value\n  #removals = new Map<Element, Map<string, OnRemovalFn>>()\n\n  get signals() {\n    return this.#signals\n  }\n\n  public load(...pluginsToLoad: DatastarPlugin[]) {\n    const that = this // I hate javascript\n    for (const plugin of pluginsToLoad) {\n      const ctx: InitContext = {\n        get signals() {\n          return that.#signals\n        },\n        effect: (cb: () => void): OnRemovalFn => effect(cb),\n        actions: this.#actions,\n        plugin,\n        applyAttributePlugin: that.#applyAttributePlugin.bind(that),\n      }\n\n      let globalInitializer: GlobalInitializer | undefined\n      switch (plugin.type) {\n        case PluginType.Watcher: {\n          const wp = plugin as WatcherPlugin\n          this.#watchers.push(wp)\n          globalInitializer = wp.onGlobalInit\n          break\n        }\n        case PluginType.Action: {\n          this.#actions[plugin.name] = plugin as ActionPlugin\n          break\n        }\n        case PluginType.Attribute: {\n          const ap = plugin as AttributePlugin\n          this.#plugins.push(ap)\n          globalInitializer = ap.onGlobalInit\n          break\n        }\n        default: {\n          throw initErr('InvalidPluginType', ctx)\n        }\n      }\n      if (globalInitializer) {\n        globalInitializer(ctx)\n      }\n    }\n\n    // Sort attribute plugins by descending length then alphabetically\n    this.#plugins.sort((a, b) => {\n      const lenDiff = b.name.length - a.name.length\n      if (lenDiff !== 0) return lenDiff\n      return a.name.localeCompare(b.name)\n    })\n\n    this.#delayedApply()\n  }\n\n  // Delay applying plugins to give them time to load\n  #delayedApply = delay(() => {\n    this.#apply(document.body)\n    this.#observe()\n  }, 1)\n\n  // Apply all plugins to the element and its children\n  #apply(rootElement: Element) {\n    this.#walkDownDOM(rootElement, (el) => {\n      // Cleanup any existing removal functions\n      const elRemovals = this.#removals.get(el)\n      if (elRemovals) {\n        for (const [, removalFn] of elRemovals) {\n          removalFn()\n        }\n        this.#removals.delete(el)\n      }\n\n      // Apply the plugins to the element in order of application\n      // since DOMStringMap is ordered, we can be deterministic\n      for (const datasetKey of Object.keys(el.dataset)) {\n        this.#applyAttributePlugin(el, datasetKey)\n      }\n    })\n  }\n\n  // Set up a mutation observer to run plugin removal and apply functions\n  #observe() {\n    if (this.#mutationObserver) {\n      return\n    }\n    \n    this.#mutationObserver = new MutationObserver((mutations) => {\n      for (const {\n        target,\n        type,\n        attributeName,\n        oldValue,\n        addedNodes,\n        removedNodes,\n      } of mutations) {\n        switch (type) {\n          case 'childList':\n            {\n              for (const node of removedNodes) {\n                const el = node as HTMLorSVGElement\n                const elRemovals = this.#removals.get(el)\n                if (!elRemovals) continue\n\n                for (const [_, removalFn] of elRemovals) {\n                  removalFn()\n                }\n                this.#removals.delete(el)\n              }\n\n              for (const node of addedNodes) {\n                const el = node as HTMLorSVGElement\n                this.#apply(el)\n              }\n            }\n            break\n          case 'attributes': {\n            {\n              const datasetPrefix = 'data-'\n              const requiredPrefix =\n                datasetPrefix + (this.aliasPrefix ? `${this.aliasPrefix}-` : '')\n              if (!attributeName?.startsWith(requiredPrefix)) {\n                break\n              }\n\n              const el = target as HTMLorSVGElement\n              const datasetKey = camel(\n                attributeName.slice(datasetPrefix.length),\n              )\n\n              // If the value has changed, clean up the old value\n              if (oldValue !== null && el.dataset[datasetKey] !== oldValue) {\n                const elRemovals = this.#removals.get(el)\n                if (elRemovals) {\n                  const rk = removalKey(datasetKey, oldValue)\n                  const removalFn = elRemovals.get(rk)\n                  if (removalFn) {\n                    removalFn()\n                    elRemovals.delete(rk)\n                  }\n                }\n              }\n\n              // Apply the plugin only if the dataset key exists\n              if (datasetKey in el.dataset) {\n                this.#applyAttributePlugin(el, datasetKey)\n              }\n            }\n            break\n          }\n        }\n      }\n    })\n\n    this.#mutationObserver.observe(document.body, {\n      attributes: true,\n      attributeOldValue: true,\n      childList: true,\n      subtree: true,\n    })\n  }\n\n  #applyAttributePlugin(el: HTMLorSVGElement, camelCasedKey: string) {\n    // Extract the raw key from the dataset\n    const rawKey = camelCasedKey.slice(this.aliasPrefix.length)\n\n    // Find the plugin that matches, since the plugins are sorted by length descending and alphabetically\n    // the first match will be the most specific\n    const plugin = this.#plugins.find((p) => rawKey.startsWith(p.name))\n\n    // Skip if no plugin is found\n    if (!plugin) return\n\n    const elAttr = this.#removals.get(el)\n    if (elAttr) {\n      for (const [k, removalFn] of elAttr) {\n        if (k.startsWith(camelCasedKey)) {\n          removalFn()\n          elAttr.delete(k)\n        }\n      }\n    }\n\n    // Ensure the element has an id\n    if (!el.id.length) el.id = elUniqId(el)\n\n    // Extract the key and modifiers\n    let [key, ...rawModifiers] = rawKey.slice(plugin.name.length).split(/\\_\\_+/)\n\n    const hasKey = key.length > 0\n    if (hasKey) {\n      key = camel(key)\n    }\n    const value = el.dataset[camelCasedKey] || ''\n    const hasValue = value.length > 0\n\n    // Create the runtime context\n    const that = this // I hate javascript\n    const ctx: RuntimeContext = {\n      get signals() {\n        return that.#signals\n      },\n      applyAttributePlugin: that.#applyAttributePlugin.bind(that),\n      effect: (cb: () => void): OnRemovalFn => effect(cb),\n      actions: this.#actions,\n      genRX: () => this.#genRX(ctx, ...(plugin.argNames || [])),\n      plugin,\n      el,\n      rawKey,\n      key,\n      value,\n      mods: new Map(),\n    }\n\n    // Check the requirements\n    const keyReq = plugin.keyReq || Requirement.Allowed\n    if (hasKey) {\n      if (keyReq === Requirement.Denied) {\n        throw runtimeErr(`${plugin.name}KeyNotAllowed`, ctx)\n      }\n    } else if (keyReq === Requirement.Must) {\n      throw runtimeErr(`${plugin.name}KeyRequired`, ctx)\n    }\n\n    const valReq = plugin.valReq || Requirement.Allowed\n    if (hasValue) {\n      if (valReq === Requirement.Denied) {\n        throw runtimeErr(`${plugin.name}ValueNotAllowed`, ctx)\n      }\n    } else if (valReq === Requirement.Must) {\n      throw runtimeErr(`${plugin.name}ValueRequired`, ctx)\n    }\n\n    // Check for exclusive requirements\n    if (keyReq === Requirement.Exclusive || valReq === Requirement.Exclusive) {\n      if (hasKey && hasValue) {\n        throw runtimeErr(`${plugin.name}KeyAndValueProvided`, ctx)\n      }\n      if (!hasKey && !hasValue) {\n        throw runtimeErr(`${plugin.name}KeyOrValueRequired`, ctx)\n      }\n    }\n\n    for (const rawMod of rawModifiers) {\n      const [label, ...mod] = rawMod.split('.')\n      ctx.mods.set(camel(label), new Set(mod.map((t) => t.toLowerCase())))\n    }\n\n    // Load the plugin and store any cleanup functions\n    const removalFn = plugin.onLoad(ctx)\n    if (removalFn) {\n      let elRemovals = this.#removals.get(el)\n      if (!elRemovals) {\n        elRemovals = new Map()\n        this.#removals.set(el, elRemovals)\n      }\n      elRemovals.set(removalKey(camelCasedKey, value), removalFn)\n    }\n\n    // Remove the attribute if required\n    const removeOnLoad = plugin.removeOnLoad\n    if (removeOnLoad && removeOnLoad(rawKey) === true) {\n      delete el.dataset[camelCasedKey]\n    }\n  }\n\n  #genRX(\n    ctx: RuntimeContext,\n    ...argNames: string[]\n  ): RuntimeExpressionFunction {\n    let userExpression = ''\n\n    // This regex allows Datastar expressions to support nested\n    // regex and strings that contain ; without breaking.\n    //\n    // Each of these regex defines a block type we want to match\n    // (importantly we ignore the content within these blocks):\n    //\n    // regex            \\/(\\\\\\/|[^\\/])*\\/\n    // double quotes      \"(\\\\\"|[^\\\"])*\"\n    // single quotes      '(\\\\'|[^'])*'\n    // ticks              `(\\\\`|[^`])*`\n    //\n    // We also want to match the non delimiter part of statements\n    // note we only support ; statement delimiters:\n    //\n    // [^;]\n    //\n    const statementRe =\n      /(\\/(\\\\\\/|[^\\/])*\\/|\"(\\\\\"|[^\\\"])*\"|'(\\\\'|[^'])*'|`(\\\\`|[^`])*`|[^;])+/gm\n    const statements = ctx.value.trim().match(statementRe)\n    if (statements) {\n      const lastIdx = statements.length - 1\n      const last = statements[lastIdx].trim()\n      if (!last.startsWith('return')) {\n        statements[lastIdx] = `return (${last});`\n      }\n      userExpression = statements.join(';\\n')\n    }\n\n    // Ignore any escaped values\n    const escaped = new Map<string, string>()\n    const escapeRe = new RegExp(`(?:${DSP})(.*?)(?:${DSS})`, 'gm')\n    for (const match of userExpression.matchAll(escapeRe)) {\n      const k = match[1]\n      const v = new Hash('dsEscaped').with(k).value\n      escaped.set(v, k)\n      userExpression = userExpression.replace(DSP + k + DSS, v)\n    }\n\n    const fnCall = /@(\\w*)\\(/gm\n    const matches = userExpression.matchAll(fnCall)\n    const methodsCalled = new Set<string>()\n    for (const match of matches) {\n      methodsCalled.add(match[1])\n    }\n\n    // Replace any action calls\n    const actionsRe = new RegExp(\n      `@(${Object.keys(this.#actions).join('|')})\\\\(`,\n      'gm',\n    )\n\n    // Add ctx to action calls\n    userExpression = userExpression.replaceAll(\n      actionsRe,\n      'ctx.actions.$1.fn(ctx,',\n    )\n\n    // Replace any signal calls\n    const signalNames = ctx.signals.paths()\n    if (signalNames.length) {\n      // Match any valid `$signalName` followed by a non-word character or end of string\n      const signalsRe = new RegExp(`\\\\$(${signalNames.join('|')})(\\\\W|$)`, 'gm')\n      userExpression = userExpression.replaceAll(\n        signalsRe,\n        `ctx.signals.signal('$1').value$2`,\n      )\n    }\n\n    // Replace any escaped values\n    for (const [k, v] of escaped) {\n      userExpression = userExpression.replace(k, v)\n    }\n\n    const fnContent = `return (()=> {\\n${userExpression}\\n})()` // Wrap in IIFE\n    ctx.fnContent = fnContent\n\n    try {\n      const fn = new Function('ctx', ...argNames, fnContent)\n      return (...args: any[]) => {\n        try {\n          return fn(ctx, ...args)\n        } catch (error: any) {\n          throw runtimeErr('ExecuteExpression', ctx, {\n            error: error.message,\n          })\n        }\n      }\n    } catch (error: any) {\n      throw runtimeErr('GenerateExpression', ctx, {\n        error: error.message,\n      })\n    }\n  }\n\n  #walkDownDOM(\n    element: Element | null,\n    callback: (el: HTMLorSVGElement) => void,\n  ) {\n    if (\n      !element ||\n      !(element instanceof HTMLElement || element instanceof SVGElement)\n    ) {\n      return null\n    }\n    const dataset = element.dataset\n    if ('starIgnore' in dataset) {\n      return null\n    }\n    if (!('starIgnore__self' in dataset)) {\n      callback(element)\n    }\n    let el = element.firstElementChild\n    while (el) {\n      this.#walkDownDOM(el, callback)\n      el = el.nextElementSibling\n    }\n  }\n}\n", "import { DSP } from '../engine/consts'\n// @ts-ignore\nconst _ = DSP // This is to force the import of DSP first in the compiled code\n\nimport { Computed } from '../plugins/official/core/attributes/computed'\nimport { Signals } from '../plugins/official/core/attributes/signals'\nimport { Star } from '../plugins/official/core/attributes/star'\nimport { Engine } from './engine'\n\nconst DS = new Engine()\nDS.load(Star, Signals, Computed)\nexport const Datastar = DS\n", "import { runtimeErr } from '../engine/errors'\nimport type { RuntimeContext } from '../engine/types'\n\n/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\nexport interface EventSourceMessage {\n  /** The event ID to set the EventSource object's last event ID value. */\n  id: string\n  /** A string identifying the type of event described. */\n  event: string\n  /** The event data */\n  data: string\n  /** The reconnection interval (in milliseconds) to wait before retrying the connection */\n  retry?: number\n}\n\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nexport async function getBytes(\n  stream: ReadableStream<Uint8Array>,\n  onChunk: (arr: Uint8Array) => void,\n) {\n  const reader = stream.getReader()\n  let result: ReadableStreamReadResult<Uint8Array>\n  while (!(result = await reader.read()).done) {\n    onChunk(result.value)\n  }\n}\n\nenum ControlChars {\n  NewLine = 10,\n  CarriageReturn = 13,\n  Space = 32,\n  Colon = 58,\n}\n\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nexport function getLines(\n  onLine: (line: Uint8Array, fieldLength: number) => void,\n) {\n  let buffer: Uint8Array | undefined\n  let position: number // current read position\n  let fieldLength: number // length of the `field` portion of the line\n  let discardTrailingNewline = false\n\n  // return a function that can process each incoming byte chunk:\n  return function onChunk(arr: Uint8Array) {\n    if (buffer === undefined) {\n      buffer = arr\n      position = 0\n      fieldLength = -1\n    } else {\n      // we're still parsing the old line. Append the new bytes into buffer:\n      buffer = concat(buffer, arr)\n    }\n\n    const bufLength = buffer.length\n    let lineStart = 0 // index where the current line starts\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === ControlChars.NewLine) {\n          lineStart = ++position // skip to next char\n        }\n\n        discardTrailingNewline = false\n      }\n\n      // start looking forward till the end of line:\n      let lineEnd = -1 // index of the \\r or \\n char\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case ControlChars.Colon:\n            if (fieldLength === -1) {\n              // first colon in line\n              fieldLength = position - lineStart\n            }\n            break\n          // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n          // biome-ignore lint/suspicious/noFallthroughSwitchClause: <explanation>\n          case ControlChars.CarriageReturn:\n            discardTrailingNewline = true\n          case ControlChars.NewLine:\n            lineEnd = position\n            break\n        }\n      }\n\n      if (lineEnd === -1) {\n        // We reached the end of the buffer but the line hasn't ended.\n        // Wait for the next arr and then continue parsing:\n        break\n      }\n\n      // we've reached the line end, send it out:\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength)\n      lineStart = position // we're now on the next line\n      fieldLength = -1\n    }\n\n    if (lineStart === bufLength) {\n      buffer = undefined // we've finished reading it\n    } else if (lineStart !== 0) {\n      // Create a new view into buffer beginning at lineStart so we don't\n      // need to copy over the previous lines when we get the new arr:\n      buffer = buffer.subarray(lineStart)\n      position -= lineStart\n    }\n  }\n}\n\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nexport function getMessages(\n  onId: (id: string) => void,\n  onRetry: (retry: number) => void,\n  onMessage?: (msg: EventSourceMessage) => void,\n) {\n  let message = newMessage()\n  const decoder = new TextDecoder()\n\n  // return a function that can process each incoming line buffer:\n  return function onLine(line: Uint8Array, fieldLength: number) {\n    if (line.length === 0) {\n      // empty line denotes end of message. Trigger the callback and start a new message:\n      onMessage?.(message)\n      message = newMessage()\n    } else if (fieldLength > 0) {\n      // exclude comments and lines with no values\n      // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n      // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n      const field = decoder.decode(line.subarray(0, fieldLength))\n      const valueOffset =\n        fieldLength + (line[fieldLength + 1] === ControlChars.Space ? 2 : 1)\n      const value = decoder.decode(line.subarray(valueOffset))\n\n      switch (field) {\n        case 'data':\n          // if this message already has data, append the new value to the old.\n          // otherwise, just set to the new value:\n          message.data = message.data ? `${message.data}\\n${value}` : value // otherwise,\n          break\n        case 'event':\n          message.event = value\n          break\n        case 'id':\n          onId((message.id = value))\n          break\n        case 'retry': {\n          const retry = Number.parseInt(value, 10)\n          if (!Number.isNaN(retry)) {\n            // per spec, ignore non-integers\n            onRetry((message.retry = retry))\n          }\n          break\n        }\n      }\n    }\n  }\n}\n\nfunction concat(a: Uint8Array, b: Uint8Array) {\n  const res = new Uint8Array(a.length + b.length)\n  res.set(a)\n  res.set(b, a.length)\n  return res\n}\n\nfunction newMessage(): EventSourceMessage {\n  // data, event, and id must be initialized to empty strings:\n  // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n  // retry should be initialized to undefined so we return a consistent shape\n  // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n  return {\n    data: '',\n    event: '',\n    id: '',\n    retry: undefined,\n  }\n}\n\nexport const EventStreamContentType = 'text/event-stream'\n\nconst LastEventId = 'last-event-id'\n\nexport interface FetchEventSourceInit extends RequestInit {\n  /**\n   * The request headers. FetchEventSource only supports the Record<string,string> format.\n   */\n  headers?: Record<string, string>\n\n  /**\n   * Called when a response is received. Use this to validate that the response\n   * actually matches what you expect (and throw if it doesn't.) If not provided,\n   * will default to a basic validation to ensure the content-type is text/event-stream.\n   */\n  onopen?: (response: Response) => Promise<void>\n\n  /**\n   * Called when a message is received. NOTE: Unlike the default browser\n   * EventSource.onmessage, this callback is called for _all_ events,\n   * even ones with a custom `event` field.\n   */\n  onmessage?: (ev: EventSourceMessage) => void\n\n  /**\n   * Called when a response finishes. If you don't expect the server to kill\n   * the connection, you can throw an exception here and retry using onerror.\n   */\n  onclose?: () => void\n\n  /**\n   * Called when there is any error making the request / processing messages /\n   * handling callbacks etc. Use this to control the retry strategy: if the\n   * error is fatal, rethrow the error inside the callback to stop the entire\n   * operation. Otherwise, you can return an interval (in milliseconds) after\n   * which the request will automatically retry (with the last-event-id).\n   * If this callback is not specified, or it returns undefined, fetchEventSource\n   * will treat every error as retriable and will try again after 1 second.\n   */\n  onerror?: (err: any) => number | null | undefined | void\n\n  /**\n   * If true, will keep the request open even if the document is hidden.\n   * By default, fetchEventSource will close the request and reopen it\n   * automatically when the document becomes visible again.\n   */\n  openWhenHidden?: boolean\n\n  /** The Fetch function to use. Defaults to window.fetch */\n  fetch?: typeof fetch\n\n  /** The retry interval in milliseconds. Defaults to 1_000 */\n  retryInterval?: number\n\n  /** The scaler for the retry interval. Defaults to 2 */\n  retryScaler?: number\n\n  /** The maximum retry interval in milliseconds. Defaults to 30_000 */\n  retryMaxWaitMs?: number\n\n  /** The maximum number of retries before giving up. Defaults to 10 */\n  retryMaxCount?: number\n}\n\nexport function fetchEventSource(\n  ctx: RuntimeContext,\n  input: RequestInfo,\n  {\n    signal: inputSignal,\n    headers: inputHeaders,\n    onopen: inputOnOpen,\n    onmessage,\n    onclose,\n    onerror,\n    openWhenHidden,\n    fetch: inputFetch,\n    retryInterval = 1_000,\n    retryScaler = 2,\n    retryMaxWaitMs = 30_000,\n    retryMaxCount = 10,\n    ...rest\n  }: FetchEventSourceInit,\n) {\n  return new Promise<void>((resolve, reject) => {\n    let retries = 0\n\n    // make a copy of the input headers since we may modify it below:\n    const headers = { ...inputHeaders }\n    if (!headers.accept) {\n      headers.accept = EventStreamContentType\n    }\n\n    let curRequestController: AbortController\n    function onVisibilityChange() {\n      curRequestController.abort() // close existing request on every visibility change\n      if (!document.hidden) {\n        create() // page is now visible again, recreate request.\n      }\n    }\n\n    if (!openWhenHidden) {\n      document.addEventListener('visibilitychange', onVisibilityChange)\n    }\n\n    let retryTimer = 0\n    function dispose() {\n      document.removeEventListener('visibilitychange', onVisibilityChange)\n      window.clearTimeout(retryTimer)\n      curRequestController.abort()\n    }\n\n    // if the incoming signal aborts, dispose resources and resolve:\n    inputSignal?.addEventListener('abort', () => {\n      dispose()\n      resolve() // don't waste time constructing/logging errors\n    })\n\n    const fetch = inputFetch ?? window.fetch\n    const onopen = inputOnOpen ?? function defaultOnOpen() {}\n    // response: Response\n\n    async function create() {\n      curRequestController = new AbortController()\n      try {\n        const response = await fetch(input, {\n          ...rest,\n          headers,\n          signal: curRequestController.signal,\n        })\n\n        await onopen(response)\n\n        await getBytes(\n          response.body!,\n          getLines(\n            getMessages(\n              (id) => {\n                if (id) {\n                  // signals the id and send it back on the next retry:\n                  headers[LastEventId] = id\n                } else {\n                  // don't send the last-event-id header anymore:\n                  delete headers[LastEventId]\n                }\n              },\n              (retry) => {\n                retryInterval = retry\n              },\n              onmessage,\n            ),\n          ),\n        )\n\n        onclose?.()\n        dispose()\n        resolve()\n      } catch (err) {\n        if (!curRequestController.signal.aborted) {\n          // if we haven't aborted the request ourselves:\n          try {\n            // check if we need to retry:\n            const interval: any = onerror?.(err) ?? retryInterval\n            window.clearTimeout(retryTimer)\n            retryTimer = window.setTimeout(create, interval)\n            retryInterval *= retryScaler // exponential backoff\n            retryInterval = Math.min(retryInterval, retryMaxWaitMs)\n            retries++\n            if (retries >= retryMaxCount) {\n              // we should not retry anymore:\n              dispose()\n              // Max retries hit, check your server or network connection\n              reject(runtimeErr('SseMaxRetries', ctx, { retryMaxCount }))\n            } else {\n              console.error(\n                `Datastar failed to reach ${rest.method}: ${input.toString()} retry in ${interval}ms`,\n              )\n            }\n          } catch (innerErr) {\n            // we should not retry anymore:\n            dispose()\n            reject(innerErr)\n          }\n        }\n      }\n    }\n\n    create()\n  })\n}\n", "import { DATASTAR } from '../../../engine/consts'\n\nexport const DATASTAR_SSE_EVENT = `${DATASTAR}-sse`\nexport const SETTLING_CLASS = `${DATASTAR}-settling`\nexport const SWAPPING_CLASS = `${DATASTAR}-swapping`\nexport const STARTED = 'started'\nexport const FINISHED = 'finished'\nexport const ERROR = 'error'\nexport const RETRYING = 'retrying'\n\nexport interface DatastarSSEEvent {\n  type: string\n  argsRaw: Record<string, string>\n}\n\nexport interface CustomEventMap {\n  [DATASTAR_SSE_EVENT]: CustomEvent<DatastarSSEEvent>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\n\ndeclare global {\n  interface Document {\n    //adds definition to Document, but you can do the same with HTMLElement\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n  }\n}\n\nexport function datastarSSEEventWatcher(\n  // ctx: InitContext,\n  eventType: string,\n  fn: (argsRaw: Record<string, string>) => void,\n) {\n  document.addEventListener(\n    DATASTAR_SSE_EVENT,\n    (event: CustomEvent<DatastarSSEEvent>) => {\n      if (event.detail.type !== eventType) return\n      const { argsRaw } = event.detail\n      fn(argsRaw)\n    },\n  )\n}\n", "// Icon: ic:baseline-get-app\n// Slug: Use a GET request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { DATASTAR, DATASTAR_REQUEST, DefaultSseRetryDurationMs } from '../../../../engine/consts'\nimport { runtimeErr } from '../../../../engine/errors'\nimport type { RuntimeContext } from '../../../../engine/types'\nimport {\n  type FetchEventSourceInit,\n  fetchEventSource,\n} from '../../../../vendored/fetch-event-source'\nimport {\n  DATASTAR_SSE_EVENT,\n  type DatastarSSEEvent,\n  ERROR,\n  FINISHED,\n  RETRYING,\n  STARTED,\n} from '../shared'\n\nfunction dispatchSSE(type: string, argsRaw: Record<string, string>) {\n  document.dispatchEvent(\n    new CustomEvent<DatastarSSEEvent>(DATASTAR_SSE_EVENT, {\n      detail: { type, argsRaw },\n    }),\n  )\n}\n\nconst isWrongContent = (err: any) => `${err}`.includes('text/event-stream')\n\nexport type SSEArgs = {\n  headers?: Record<string, string>\n  openWhenHidden?: boolean\n  retryInterval?: number\n  retryScaler?: number\n  retryMaxWaitMs?: number\n  retryMaxCount?: number\n  abort?: AbortSignal\n} & (\n  | {\n      contentType: 'json'\n      includeLocal?: boolean\n    }\n  | {\n      contentType: 'form'\n      selector?: string\n    }\n)\n\nexport const sse = async (\n  ctx: RuntimeContext,\n  method: string,\n  url: string,\n  args: SSEArgs,\n) => {\n  const {\n    el: { id: elId },\n    el,\n    signals,\n  } = ctx\n  const {\n    headers: userHeaders,\n    contentType,\n    includeLocal,\n    selector,\n    openWhenHidden,\n    retryInterval,\n    retryScaler,\n    retryMaxWaitMs,\n    retryMaxCount,\n    abort,\n  } = Object.assign(\n    {\n      headers: {},\n      contentType: 'json',\n      includeLocal: false,\n      selector: null,\n      openWhenHidden: false, // will keep the request open even if the document is hidden.\n      retryInterval: DefaultSseRetryDurationMs, // the retry interval in milliseconds\n      retryScaler: 2, // the amount to multiply the retry interval by each time\n      retryMaxWaitMs: 30_000, // the maximum retry interval in milliseconds\n      retryMaxCount: 10, // the maximum number of retries before giving up\n      abort: undefined,\n    },\n    args,\n  )\n  const action = method.toLowerCase()\n  let cleanupFn = (): void => {}\n  try {\n    dispatchSSE(STARTED, { elId })\n    if (!url?.length) {\n      throw runtimeErr('SseNoUrlProvided', ctx, { action })\n    }\n\n    const initialHeaders: Record<string, any> = {}\n    initialHeaders[DATASTAR_REQUEST] = true\n    // We ignore the content-type header if using form data\n    // if missing the boundary will be set automatically\n    if (contentType === 'json') {\n      initialHeaders['Content-Type'] = 'application/json'\n    }\n    const headers = Object.assign({}, initialHeaders, userHeaders)\n\n    const req: FetchEventSourceInit = {\n      method,\n      headers,\n      openWhenHidden,\n      retryInterval,\n      retryScaler,\n      retryMaxWaitMs,\n      retryMaxCount,\n      signal: abort,\n      onopen: async (response: Response) => {\n        if (response.status >= 400) {\n          const status = response.status.toString()\n          dispatchSSE(ERROR, { status })\n        }\n      },\n      onmessage: (evt) => {\n        if (!evt.event.startsWith(DATASTAR)) {\n          return\n        }\n        const type = evt.event\n        const argsRawLines: Record<string, string[]> = {}\n\n        const lines = evt.data.split('\\n')\n        for (const line of lines) {\n          const colonIndex = line.indexOf(' ')\n          const key = line.slice(0, colonIndex)\n          let argLines = argsRawLines[key]\n          if (!argLines) {\n            argLines = []\n            argsRawLines[key] = argLines\n          }\n          const value = line.slice(colonIndex + 1).trim()\n          argLines.push(value)\n        }\n\n        const argsRaw: Record<string, string> = {}\n        for (const [key, lines] of Object.entries(argsRawLines)) {\n          argsRaw[key] = lines.join('\\n')\n        }\n\n        // if you aren't seeing your event you can debug by using this line in the console\n        // document.addEventListener(\"datastar-sse\",(e) => console.log(e));\n        dispatchSSE(type, argsRaw)\n      },\n      onerror: (error) => {\n        if (isWrongContent(error)) {\n          // don't retry if the content-type is wrong\n          throw runtimeErr('InvalidContentType', ctx, { url })\n        }\n        // do nothing and it will retry\n        if (error) {\n          console.error(error.message)\n          dispatchSSE(RETRYING, { message: error.message })\n        }\n      },\n    }\n\n    const urlInstance = new URL(url, window.location.origin)\n    const queryParams = new URLSearchParams(urlInstance.search)\n\n    if (contentType === 'json') {\n      const json = signals.JSON(false, !includeLocal)\n      if (method === 'GET') {\n        queryParams.set(DATASTAR, json)\n      } else {\n        req.body = json\n      }\n    } else if (contentType === 'form') {\n      const formEl = selector\n        ? document.querySelector(selector)\n        : el.closest('form')\n      if (formEl === null) {\n        if (selector) {\n          throw runtimeErr('SseFormNotFound', ctx, { action, selector })\n        }\n        throw runtimeErr('SseClosestFormNotFound', ctx, { action })\n      }\n      if (el !== formEl) {\n        const preventDefault = (evt: Event) => evt.preventDefault()\n        formEl.addEventListener('submit', preventDefault)\n        cleanupFn = (): void =>\n          formEl.removeEventListener('submit', preventDefault)\n      }\n      if (!formEl.checkValidity()) {\n        formEl.reportValidity()\n        cleanupFn()\n        return\n      }\n      const formData = new FormData(formEl)\n      if (method === 'GET') {\n        const formParams = new URLSearchParams(formData as any)\n        for (const [key, value] of formParams) {\n          queryParams.set(key, value)\n        }\n      } else {\n        req.body = formData\n      }\n    } else {\n      throw runtimeErr('SseInvalidContentType', ctx, { action, contentType })\n    }\n\n    urlInstance.search = queryParams.toString()\n\n    try {\n      await fetchEventSource(ctx, urlInstance.toString(), req)\n    } catch (error) {\n      if (!isWrongContent(error)) {\n        throw runtimeErr('SseFetchFailed', ctx, { method, url, error })\n      }\n      // exit gracefully and do nothing if the content-type is wrong\n      // this can happen if the client is sending a request\n      // where no response is expected, and they haven't\n      // set the content-type to text/event-stream\n    }\n  } finally {\n    dispatchSSE(FINISHED, { elId })\n    cleanupFn()\n  }\n}\n", "// Icon: material-symbols:delete-outline\n// Slug: Use a DELETE request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  type ActionPlugin,\n  PluginType,\n  type RuntimeContext,\n} from '../../../../engine/types'\nimport { type SSEArgs, sse } from './sse'\n\nexport const DELETE: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'delete',\n  fn: async (ctx: RuntimeContext, url: string, args: SSEArgs) => {\n    return sse(ctx, 'DELETE', url, { ...args })\n  },\n}\n", "// Icon: ic:baseline-get-app\n// Slug: Use a GET request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  type ActionPlugin,\n  PluginType,\n  type RuntimeContext,\n} from '../../../../engine/types'\nimport { type SSEArgs, sse } from './sse'\n\nexport const GET: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'get',\n  fn: async (ctx: RuntimeContext, url: string, args: SSEArgs) => {\n    return sse(ctx, 'GET', url, { ...args })\n  },\n}\n", "// Icon: fluent:patch-24-filled\n// Slug: Use a PATCH request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  type ActionPlugin,\n  PluginType,\n  type RuntimeContext,\n} from '../../../../engine/types'\nimport { type SSEArgs, sse } from './sse'\n\nexport const PATCH: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'patch',\n  fn: async (ctx: RuntimeContext, url: string, args: SSEArgs) => {\n    return sse(ctx, 'PATCH', url, { ...args })\n  },\n}\n", "// Icon: ri:signpost-fill\n// Slug: Use a POST request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  type ActionPlugin,\n  PluginType,\n  type RuntimeContext,\n} from '../../../../engine/types'\nimport { type SSEArgs, sse } from './sse'\n\nexport const POST: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'post',\n  fn: async (ctx: RuntimeContext, url: string, args: SSEArgs) => {\n    return sse(ctx, 'POST', url, { ...args })\n  },\n}\n", "// Icon: material-symbols:arrows-input\n// Slug: Use a PUT request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  type ActionPlugin,\n  PluginType,\n  type RuntimeContext,\n} from '../../../../engine/types'\nimport { type SSEArgs, sse } from './sse'\n\nexport const PUT: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'put',\n  fn: async (ctx: RuntimeContext, url: string, args: SSEArgs) => {\n    return sse(ctx, 'PUT', url, { ...args })\n  },\n}\n", "// Icon: material-symbols:network-wifi\n// Slug: Sets the indicator signal used when fetching data via SSE\n// Description: must be a valid signal name\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { modifyCasing, trimDollarSignPrefix } from '../../../../utils/text'\nimport {\n  DATASTAR_SSE_EVENT,\n  type DatastarSSEEvent,\n  FINISHED,\n  STARTED,\n} from '../shared'\n\nexport const Indicator: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'indicator',\n  keyReq: Requirement.Exclusive,\n  valReq: Requirement.Exclusive,\n  onLoad: ({ el, key, mods, signals, value }) => {\n    const signalName = key ? modifyCasing(key, mods) : trimDollarSignPrefix(value)\n    const signal = signals.upsertIfMissing(signalName, false)\n    const watcher = (event: CustomEvent<DatastarSSEEvent>) => {\n      const {\n        type,\n        argsRaw: { elId },\n      } = event.detail\n      if (elId !== el.id) return\n      switch (type) {\n        case STARTED:\n          signal.value = true\n          break\n        case FINISHED:\n          signal.value = false\n          break\n      }\n    }\n    document.addEventListener(DATASTAR_SSE_EVENT, watcher)\n\n    return () => {\n      document.removeEventListener(DATASTAR_SSE_EVENT, watcher)\n    }\n  },\n}\n", "// Icon: tabler:file-type-js\n// Slug: Execute JavaScript using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DefaultExecuteScriptAttributes,\n  DefaultExecuteScriptAutoRemove,\n  EventTypes,\n} from '../../../../engine/consts'\nimport { initErr } from '../../../../engine/errors'\nimport { PluginType, type WatcherPlugin } from '../../../../engine/types'\nimport { isBoolString } from '../../../../utils/text'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const ExecuteScript: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypes.ExecuteScript,\n  onGlobalInit: async (ctx) => {\n    datastarSSEEventWatcher(\n      EventTypes.ExecuteScript,\n      ({\n        autoRemove: autoRemoveRaw = `${DefaultExecuteScriptAutoRemove}`,\n        attributes: attributesRaw = DefaultExecuteScriptAttributes,\n        script,\n      }) => {\n        const autoRemove = isBoolString(autoRemoveRaw)\n        if (!script?.length) {\n          throw initErr('NoScriptProvided', ctx)\n        }\n        const scriptEl = document.createElement('script')\n        for (const attr of attributesRaw.split('\\n')) {\n          const pivot = attr.indexOf(' ')\n          const key = pivot ? attr.slice(0, pivot) : attr\n          const value = pivot ? attr.slice(pivot) : ''\n          scriptEl.setAttribute(key.trim(), value.trim())\n        }\n        scriptEl.text = script\n        document.head.appendChild(scriptEl)\n        if (autoRemove) {\n          scriptEl.remove()\n        }\n      },\n    )\n  },\n}\n", "export interface DocumentSupportingViewTransitionAPI {\n  startViewTransition(\n    updateCallback: () => Promise<void> | void,\n  ): IViewTransition\n}\n\nexport interface IViewTransition {\n  finished: Promise<void>\n  ready: Promise<void>\n  updateCallbackDone: Promise<void>\n  skipTransition(): void\n}\n\nexport const docWithViewTransitionAPI =\n  document as unknown as DocumentSupportingViewTransitionAPI\nexport const supportsViewTransitions =\n  !!docWithViewTransitionAPI.startViewTransition\n", "/**\n * @typedef {object} ConfigHead\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} [style]\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {function(Element): boolean} [shouldPreserve]\n * @property {function(Element): boolean} [shouldReAppend]\n * @property {function(Element): boolean} [shouldRemove]\n * @property {function(Element, {added: Node[], kept: Element[], removed: Element[]}): void} [afterHeadMorphed]\n */\n\n/**\n * @typedef {object} ConfigCallbacks\n *\n * @property {function(Node): boolean} [beforeNodeAdded]\n * @property {function(Node): void} [afterNodeAdded]\n * @property {function(Element, Node): boolean} [beforeNodeMorphed]\n * @property {function(Element, Node): void} [afterNodeMorphed]\n * @property {function(Element): boolean} [beforeNodeRemoved]\n * @property {function(Element): void} [afterNodeRemoved]\n * @property {function(string, Element, \"update\" | \"remove\"): boolean} [beforeAttributeUpdated]\n * @property {function(Element): boolean} [beforeNodePantried]\n */\n\n/**\n * @typedef {object} Config\n *\n * @property {'outerHTML' | 'innerHTML'} [morphStyle]\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {ConfigCallbacks} [callbacks]\n * @property {ConfigHead} [head]\n */\n\n/**\n * @typedef {function} NoOp\n *\n * @returns {void}\n */\n\n/**\n * @typedef {object} ConfigHeadInternal\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} style\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {(function(Element): boolean) | NoOp} shouldPreserve\n * @property {(function(Element): boolean) | NoOp} shouldReAppend\n * @property {(function(Element): boolean) | NoOp} shouldRemove\n * @property {(function(Element, {added: Node[], kept: Element[], removed: Element[]}): void) | NoOp} afterHeadMorphed\n */\n\n/**\n * @typedef {object} ConfigCallbacksInternal\n *\n * @property {(function(Node): boolean) | NoOp} beforeNodeAdded\n * @property {(function(Node): void) | NoOp} afterNodeAdded\n * @property {(function(Node, Node): boolean) | NoOp} beforeNodeMorphed\n * @property {(function(Node, Node): void) | NoOp} afterNodeMorphed\n * @property {(function(Node): boolean) | NoOp} beforeNodeRemoved\n * @property {(function(Node): void) | NoOp} afterNodeRemoved\n * @property {(function(string, Element, \"update\" | \"remove\"): boolean) | NoOp} beforeAttributeUpdated\n * @property {(function(Node): boolean) | NoOp} beforeNodePantried\n */\n\n/**\n * @typedef {object} ConfigInternal\n *\n * @property {'outerHTML' | 'innerHTML'} morphStyle\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {ConfigCallbacksInternal} callbacks\n * @property {ConfigHeadInternal} head\n * @property {boolean} [twoPass]\n */\n\n/**\n * @typedef {Function} Morph\n *\n * @param {Element | Document} oldNode\n * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n * @param {Config} [config]\n * @returns {undefined | Node[]}\n */\n\n// base IIFE to define idiomorph\n/**\n *\n * @type {{defaults: ConfigInternal, morph: Morph}}\n */\nvar Idiomorph = (function () {\n  \"use strict\";\n\n  /**\n   * @typedef {object} MorphContext\n   *\n   * @property {Node} target\n   * @property {Node} newContent\n   * @property {ConfigInternal} config\n   * @property {ConfigInternal['morphStyle']} morphStyle\n   * @property {ConfigInternal['ignoreActive']} ignoreActive\n   * @property {ConfigInternal['ignoreActiveValue']} ignoreActiveValue\n   * @property {Map<Node, Set<string>>} idMap\n   * @property {Set<string>} persistentIds\n   * @property {Set<string>} deadIds\n   * @property {ConfigInternal['callbacks']} callbacks\n   * @property {ConfigInternal['head']} head\n   * @property {HTMLDivElement} pantry\n   */\n\n  //=============================================================================\n  // AND NOW IT BEGINS...\n  //=============================================================================\n\n  /**\n   *\n   * @type {Set<string>}\n   */\n  let EMPTY_SET = new Set();\n\n  /**\n   * Default configuration values, updatable by users now\n   * @type {ConfigInternal}\n   */\n  let defaults = {\n    morphStyle: \"outerHTML\",\n    callbacks: {\n      beforeNodeAdded: noOp,\n      afterNodeAdded: noOp,\n      beforeNodeMorphed: noOp,\n      afterNodeMorphed: noOp,\n      beforeNodeRemoved: noOp,\n      afterNodeRemoved: noOp,\n      beforeAttributeUpdated: noOp,\n      beforeNodePantried: noOp,\n    },\n    head: {\n      style: \"merge\",\n      shouldPreserve: function (elt) {\n        return elt.getAttribute(\"im-preserve\") === \"true\";\n      },\n      shouldReAppend: function (elt) {\n        return elt.getAttribute(\"im-re-append\") === \"true\";\n      },\n      shouldRemove: noOp,\n      afterHeadMorphed: noOp,\n    },\n  };\n\n  /**\n   * =============================================================================\n   * Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n   * =============================================================================\n   *\n   * @param {Element | Document} oldNode\n   * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n   * @param {Config} [config]\n   * @returns {undefined | Node[]}\n   */\n  function morph(oldNode, newContent, config = {}) {\n    if (oldNode instanceof Document) {\n      oldNode = oldNode.documentElement;\n    }\n\n    if (typeof newContent === \"string\") {\n      newContent = parseContent(newContent);\n    }\n\n    let normalizedContent = normalizeContent(newContent);\n\n    let ctx = createMorphContext(oldNode, normalizedContent, config);\n\n    return morphNormalizedContent(oldNode, normalizedContent, ctx);\n  }\n\n  /**\n   *\n   * @param {Element} oldNode\n   * @param {Element} normalizedNewContent\n   * @param {MorphContext} ctx\n   * @returns {undefined | Node[]}\n   */\n  function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {\n    if (ctx.head.block) {\n      let oldHead = oldNode.querySelector(\"head\");\n      let newHead = normalizedNewContent.querySelector(\"head\");\n      if (oldHead && newHead) {\n        let promises = handleHeadElement(newHead, oldHead, ctx);\n        // when head promises resolve, call morph again, ignoring the head tag\n        Promise.all(promises).then(function () {\n          morphNormalizedContent(\n            oldNode,\n            normalizedNewContent,\n            Object.assign(ctx, {\n              head: {\n                block: false,\n                ignore: true,\n              },\n            }),\n          );\n        });\n        return;\n      }\n    }\n\n    if (ctx.morphStyle === \"innerHTML\") {\n      // innerHTML, so we are only updating the children\n      morphChildren(normalizedNewContent, oldNode, ctx);\n      if (ctx.config.twoPass) {\n        restoreFromPantry(oldNode, ctx);\n      }\n      return Array.from(oldNode.children);\n    } else if (ctx.morphStyle === \"outerHTML\" || ctx.morphStyle == null) {\n      // otherwise find the best element match in the new content, morph that, and merge its siblings\n      // into either side of the best match\n      let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n\n      // stash the siblings that will need to be inserted on either side of the best match\n      let previousSibling = bestMatch?.previousSibling ?? null;\n      let nextSibling = bestMatch?.nextSibling ?? null;\n\n      // morph it\n      let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);\n\n      if (bestMatch) {\n        // if there was a best match, merge the siblings in too and return the\n        // whole bunch\n        if (morphedNode) {\n          const elements = insertSiblings(\n            previousSibling,\n            morphedNode,\n            nextSibling,\n          );\n          if (ctx.config.twoPass) {\n            restoreFromPantry(morphedNode.parentNode, ctx);\n          }\n          return elements;\n        }\n      } else {\n        // otherwise nothing was added to the DOM\n        return [];\n      }\n    } else {\n      throw \"Do not understand how to morph style \" + ctx.morphStyle;\n    }\n  }\n\n  /**\n   * @param {Node} possibleActiveElement\n   * @param {MorphContext} ctx\n   * @returns {boolean}\n   */\n  // TODO: ignoreActive and ignoreActiveValue are marked as optional since they are not\n  //   initialised in the default config object. As a result the && in the function body may\n  //   return undefined instead of boolean. Either expand the type of the return value to\n  //   include undefined or wrap the ctx.ignoreActiveValue into a Boolean()\n  function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n    return (\n      !!ctx.ignoreActiveValue &&\n      possibleActiveElement === document.activeElement &&\n      possibleActiveElement !== document.body\n    );\n  }\n\n  /**\n   * @param {Node} oldNode root node to merge content into\n   * @param {Node | null} newContent new content to merge\n   * @param {MorphContext} ctx the merge context\n   * @returns {Node | null} the element that ended up in the DOM\n   */\n  function morphOldNodeTo(oldNode, newContent, ctx) {\n    if (ctx.ignoreActive && oldNode === document.activeElement) {\n      // don't morph focused element\n    } else if (newContent == null) {\n      if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n\n      oldNode.parentNode?.removeChild(oldNode);\n      ctx.callbacks.afterNodeRemoved(oldNode);\n      return null;\n    } else if (!isSoftMatch(oldNode, newContent)) {\n      if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n      if (ctx.callbacks.beforeNodeAdded(newContent) === false) return oldNode;\n\n      oldNode.parentNode?.replaceChild(newContent, oldNode);\n      ctx.callbacks.afterNodeAdded(newContent);\n      ctx.callbacks.afterNodeRemoved(oldNode);\n      return newContent;\n    } else {\n      if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false)\n        return oldNode;\n\n      if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n        // ignore the head element\n      } else if (\n        oldNode instanceof HTMLHeadElement &&\n        ctx.head.style !== \"morph\"\n      ) {\n        // ok to cast: if newContent wasn't also a <head>, it would've got caught in the `!isSoftMatch` branch above\n        handleHeadElement(\n          /** @type {HTMLHeadElement} */ (newContent),\n          oldNode,\n          ctx,\n        );\n      } else {\n        syncNodeFrom(newContent, oldNode, ctx);\n        if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n          morphChildren(newContent, oldNode, ctx);\n        }\n      }\n      ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n      return oldNode;\n    }\n    return null;\n  }\n\n  /**\n   * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n   * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n   * by using id sets, we are able to better match up with content deeper in the DOM.\n   *\n   * Basic algorithm is, for each node in the new content:\n   *\n   * - if we have reached the end of the old parent, append the new content\n   * - if the new content has an id set match with the current insertion point, morph\n   * - search for an id set match\n   * - if id set match found, morph\n   * - otherwise search for a \"soft\" match\n   * - if a soft match is found, morph\n   * - otherwise, prepend the new node before the current insertion point\n   *\n   * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n   * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n   *\n   * @param {Node} newParent the parent element of the new content\n   * @param {Node} oldParent the old content that we are merging the new content into\n   * @param {MorphContext} ctx the merge context\n   * @returns {void}\n   */\n  function morphChildren(newParent, oldParent, ctx) {\n    if (\n      newParent instanceof HTMLTemplateElement &&\n      oldParent instanceof HTMLTemplateElement\n    ) {\n      newParent = newParent.content;\n      oldParent = oldParent.content;\n    }\n\n    /**\n     *\n     * @type {Node | null}\n     */\n    let nextNewChild = newParent.firstChild;\n    /**\n     *\n     * @type {Node | null}\n     */\n    let insertionPoint = oldParent.firstChild;\n    let newChild;\n\n    // run through all the new content\n    while (nextNewChild) {\n      newChild = nextNewChild;\n      nextNewChild = newChild.nextSibling;\n\n      // if we are at the end of the exiting parent's children, just append\n      if (insertionPoint == null) {\n        // skip add callbacks when we're going to be restoring this from the pantry in the second pass\n        if (\n          ctx.config.twoPass &&\n          ctx.persistentIds.has(/** @type {Element} */ (newChild).id)\n        ) {\n          oldParent.appendChild(newChild);\n        } else {\n          if (ctx.callbacks.beforeNodeAdded(newChild) === false) continue;\n          oldParent.appendChild(newChild);\n          ctx.callbacks.afterNodeAdded(newChild);\n        }\n        removeIdsFromConsideration(ctx, newChild);\n        continue;\n      }\n\n      // if the current node has an id set match then morph\n      if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n        morphOldNodeTo(insertionPoint, newChild, ctx);\n        insertionPoint = insertionPoint.nextSibling;\n        removeIdsFromConsideration(ctx, newChild);\n        continue;\n      }\n\n      // otherwise search forward in the existing old children for an id set match\n      let idSetMatch = findIdSetMatch(\n        newParent,\n        oldParent,\n        newChild,\n        insertionPoint,\n        ctx,\n      );\n\n      // if we found a potential match, remove the nodes until that point and morph\n      if (idSetMatch) {\n        insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);\n        morphOldNodeTo(idSetMatch, newChild, ctx);\n        removeIdsFromConsideration(ctx, newChild);\n        continue;\n      }\n\n      // no id set match found, so scan forward for a soft match for the current node\n      let softMatch = findSoftMatch(\n        newParent,\n        oldParent,\n        newChild,\n        insertionPoint,\n        ctx,\n      );\n\n      // if we found a soft match for the current node, morph\n      if (softMatch) {\n        insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n        morphOldNodeTo(softMatch, newChild, ctx);\n        removeIdsFromConsideration(ctx, newChild);\n        continue;\n      }\n\n      // abandon all hope of morphing, just insert the new child before the insertion point\n      // and move on\n\n      // skip add callbacks when we're going to be restoring this from the pantry in the second pass\n      if (\n        ctx.config.twoPass &&\n        ctx.persistentIds.has(/** @type {Element} */ (newChild).id)\n      ) {\n        oldParent.insertBefore(newChild, insertionPoint);\n      } else {\n        if (ctx.callbacks.beforeNodeAdded(newChild) === false) continue;\n        oldParent.insertBefore(newChild, insertionPoint);\n        ctx.callbacks.afterNodeAdded(newChild);\n      }\n      removeIdsFromConsideration(ctx, newChild);\n    }\n\n    // remove any remaining old nodes that didn't match up with new content\n    while (insertionPoint !== null) {\n      let tempNode = insertionPoint;\n      insertionPoint = insertionPoint.nextSibling;\n      removeNode(tempNode, ctx);\n    }\n  }\n\n  //=============================================================================\n  // Attribute Syncing Code\n  //=============================================================================\n\n  /**\n   * @param {string} attr the attribute to be mutated\n   * @param {Element} to the element that is going to be updated\n   * @param {\"update\" | \"remove\"} updateType\n   * @param {MorphContext} ctx the merge context\n   * @returns {boolean} true if the attribute should be ignored, false otherwise\n   */\n  function ignoreAttribute(attr, to, updateType, ctx) {\n    if (\n      attr === \"value\" &&\n      ctx.ignoreActiveValue &&\n      to === document.activeElement\n    ) {\n      return true;\n    }\n    return ctx.callbacks.beforeAttributeUpdated(attr, to, updateType) === false;\n  }\n\n  /**\n   * syncs a given node with another node, copying over all attributes and\n   * inner element state from the 'from' node to the 'to' node\n   *\n   * @param {Node} from the element to copy attributes & state from\n   * @param {Node} to the element to copy attributes & state to\n   * @param {MorphContext} ctx the merge context\n   */\n  function syncNodeFrom(from, to, ctx) {\n    let type = from.nodeType;\n\n    // if is an element type, sync the attributes from the\n    // new node into the new node\n    if (type === 1 /* element type */) {\n      const fromEl = /** @type {Element} */ (from);\n      const toEl = /** @type {Element} */ (to);\n      const fromAttributes = fromEl.attributes;\n      const toAttributes = toEl.attributes;\n      for (const fromAttribute of fromAttributes) {\n        if (ignoreAttribute(fromAttribute.name, toEl, \"update\", ctx)) {\n          continue;\n        }\n        if (toEl.getAttribute(fromAttribute.name) !== fromAttribute.value) {\n          toEl.setAttribute(fromAttribute.name, fromAttribute.value);\n        }\n      }\n      // iterate backwards to avoid skipping over items when a delete occurs\n      for (let i = toAttributes.length - 1; 0 <= i; i--) {\n        const toAttribute = toAttributes[i];\n\n        // toAttributes is a live NamedNodeMap, so iteration+mutation is unsafe\n        // e.g. custom element attribute callbacks can remove other attributes\n        if (!toAttribute) continue;\n\n        if (!fromEl.hasAttribute(toAttribute.name)) {\n          if (ignoreAttribute(toAttribute.name, toEl, \"remove\", ctx)) {\n            continue;\n          }\n          toEl.removeAttribute(toAttribute.name);\n        }\n      }\n    }\n\n    // sync text nodes\n    if (type === 8 /* comment */ || type === 3 /* text */) {\n      if (to.nodeValue !== from.nodeValue) {\n        to.nodeValue = from.nodeValue;\n      }\n    }\n\n    if (!ignoreValueOfActiveElement(to, ctx)) {\n      // sync input values\n      syncInputValue(from, to, ctx);\n    }\n  }\n\n  /**\n   * @param {Element} from element to sync the value from\n   * @param {Element} to element to sync the value to\n   * @param {string} attributeName the attribute name\n   * @param {MorphContext} ctx the merge context\n   */\n  function syncBooleanAttribute(from, to, attributeName, ctx) {\n    // TODO: prefer set/getAttribute here\n    if (!(from instanceof Element && to instanceof Element)) return;\n    // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n    const fromLiveValue = from[attributeName],\n      toLiveValue = to[attributeName];\n    if (fromLiveValue !== toLiveValue) {\n      let ignoreUpdate = ignoreAttribute(attributeName, to, \"update\", ctx);\n      if (!ignoreUpdate) {\n        // update attribute's associated DOM property\n        // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n        to[attributeName] = from[attributeName];\n      }\n      if (fromLiveValue) {\n        if (!ignoreUpdate) {\n          // TODO: do we really want this? tests say so but it feels wrong\n          to.setAttribute(attributeName, fromLiveValue);\n        }\n      } else {\n        if (!ignoreAttribute(attributeName, to, \"remove\", ctx)) {\n          to.removeAttribute(attributeName);\n        }\n      }\n    }\n  }\n\n  /**\n   * NB: many bothans died to bring us information:\n   *\n   *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n   *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n   *\n   * @param {Node} from the element to sync the input value from\n   * @param {Node} to the element to sync the input value to\n   * @param {MorphContext} ctx the merge context\n   */\n  function syncInputValue(from, to, ctx) {\n    if (\n      from instanceof HTMLInputElement &&\n      to instanceof HTMLInputElement &&\n      from.type !== \"file\"\n    ) {\n      let fromValue = from.value;\n      let toValue = to.value;\n\n      // sync boolean attributes\n      syncBooleanAttribute(from, to, \"checked\", ctx);\n      syncBooleanAttribute(from, to, \"disabled\", ctx);\n\n      if (!from.hasAttribute(\"value\")) {\n        if (!ignoreAttribute(\"value\", to, \"remove\", ctx)) {\n          to.value = \"\";\n          to.removeAttribute(\"value\");\n        }\n      } else if (fromValue !== toValue) {\n        if (!ignoreAttribute(\"value\", to, \"update\", ctx)) {\n          to.setAttribute(\"value\", fromValue);\n          to.value = fromValue;\n        }\n      }\n      // TODO: QUESTION(1cg): this used to only check `from` unlike the other branches -- why?\n      // did I break something?\n    } else if (\n      from instanceof HTMLOptionElement &&\n      to instanceof HTMLOptionElement\n    ) {\n      syncBooleanAttribute(from, to, \"selected\", ctx);\n    } else if (\n      from instanceof HTMLTextAreaElement &&\n      to instanceof HTMLTextAreaElement\n    ) {\n      let fromValue = from.value;\n      let toValue = to.value;\n      if (ignoreAttribute(\"value\", to, \"update\", ctx)) {\n        return;\n      }\n      if (fromValue !== toValue) {\n        to.value = fromValue;\n      }\n      if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n        to.firstChild.nodeValue = fromValue;\n      }\n    }\n  }\n\n  /**\n   * =============================================================================\n   *  The HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n   * =============================================================================\n   * @param {Element} newHeadTag\n   * @param {Element} currentHead\n   * @param {MorphContext} ctx\n   * @returns {Promise<void>[]}\n   */\n  function handleHeadElement(newHeadTag, currentHead, ctx) {\n    /**\n     * @type {Node[]}\n     */\n    let added = [];\n    /**\n     * @type {Element[]}\n     */\n    let removed = [];\n    /**\n     * @type {Element[]}\n     */\n    let preserved = [];\n    /**\n     * @type {Element[]}\n     */\n    let nodesToAppend = [];\n\n    let headMergeStyle = ctx.head.style;\n\n    // put all new head elements into a Map, by their outerHTML\n    let srcToNewHeadNodes = new Map();\n    for (const newHeadChild of newHeadTag.children) {\n      srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n    }\n\n    // for each elt in the current head\n    for (const currentHeadElt of currentHead.children) {\n      // If the current head element is in the map\n      let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n      let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n      let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n      if (inNewContent || isPreserved) {\n        if (isReAppended) {\n          // remove the current version and let the new version replace it and re-execute\n          removed.push(currentHeadElt);\n        } else {\n          // this element already exists and should not be re-appended, so remove it from\n          // the new content map, preserving it in the DOM\n          srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n          preserved.push(currentHeadElt);\n        }\n      } else {\n        if (headMergeStyle === \"append\") {\n          // we are appending and this existing element is not new content\n          // so if and only if it is marked for re-append do we do anything\n          if (isReAppended) {\n            removed.push(currentHeadElt);\n            nodesToAppend.push(currentHeadElt);\n          }\n        } else {\n          // if this is a merge, we remove this content since it is not in the new head\n          if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n            removed.push(currentHeadElt);\n          }\n        }\n      }\n    }\n\n    // Push the remaining new head elements in the Map into the\n    // nodes to append to the head tag\n    nodesToAppend.push(...srcToNewHeadNodes.values());\n    log(\"to append: \", nodesToAppend);\n\n    let promises = [];\n    for (const newNode of nodesToAppend) {\n      log(\"adding: \", newNode);\n      // TODO: This could theoretically be null, based on type\n      let newElt = /** @type {ChildNode} */ (\n        document.createRange().createContextualFragment(newNode.outerHTML)\n          .firstChild\n      );\n      log(newElt);\n      if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n        if (\n          (\"href\" in newElt && newElt.href) ||\n          (\"src\" in newElt && newElt.src)\n        ) {\n          /** @type {(result?: any) => void} */ let resolve;\n          let promise = new Promise(function (_resolve) {\n            resolve = _resolve;\n          });\n          newElt.addEventListener(\"load\", function () {\n            resolve();\n          });\n          promises.push(promise);\n        }\n        currentHead.appendChild(newElt);\n        ctx.callbacks.afterNodeAdded(newElt);\n        added.push(newElt);\n      }\n    }\n\n    // remove all removed elements, after we have appended the new elements to avoid\n    // additional network requests for things like style sheets\n    for (const removedElement of removed) {\n      if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n        currentHead.removeChild(removedElement);\n        ctx.callbacks.afterNodeRemoved(removedElement);\n      }\n    }\n\n    ctx.head.afterHeadMorphed(currentHead, {\n      added: added,\n      kept: preserved,\n      removed: removed,\n    });\n    return promises;\n  }\n\n  //=============================================================================\n  // Misc\n  //=============================================================================\n\n  /**\n   * @param {any[]} _args\n   */\n  function log(..._args) {\n    //console.log(args);\n  }\n\n  function noOp() {}\n\n  /**\n   * Deep merges the config object and the Idiomoroph.defaults object to\n   * produce a final configuration object\n   * @param {Config} config\n   * @returns {ConfigInternal}\n   */\n  function mergeDefaults(config) {\n    /**\n     * @type {ConfigInternal}\n     */\n    let finalConfig = Object.assign({}, defaults);\n\n    // copy top level stuff into final config\n    Object.assign(finalConfig, config);\n\n    // copy callbacks into final config (do this to deep merge the callbacks)\n    finalConfig.callbacks = Object.assign(\n      {},\n      defaults.callbacks,\n      config.callbacks,\n    );\n\n    // copy head config into final config  (do this to deep merge the head)\n    finalConfig.head = Object.assign({}, defaults.head, config.head);\n\n    return finalConfig;\n  }\n\n  /**\n   *\n   * @param {Element} oldNode\n   * @param {Element} newContent\n   * @param {Config} config\n   * @returns {MorphContext}\n   */\n  function createMorphContext(oldNode, newContent, config) {\n    const mergedConfig = mergeDefaults(config);\n    return {\n      target: oldNode,\n      newContent: newContent,\n      config: mergedConfig,\n      morphStyle: mergedConfig.morphStyle,\n      ignoreActive: mergedConfig.ignoreActive,\n      ignoreActiveValue: mergedConfig.ignoreActiveValue,\n      idMap: createIdMap(oldNode, newContent),\n      deadIds: new Set(),\n      persistentIds: mergedConfig.twoPass\n        ? createPersistentIds(oldNode, newContent)\n        : new Set(),\n      pantry: mergedConfig.twoPass\n        ? createPantry()\n        : document.createElement(\"div\"),\n      callbacks: mergedConfig.callbacks,\n      head: mergedConfig.head,\n    };\n  }\n\n  function createPantry() {\n    const pantry = document.createElement(\"div\");\n    pantry.hidden = true;\n    document.body.insertAdjacentElement(\"afterend\", pantry);\n    return pantry;\n  }\n\n  /**\n   *\n   * @param {Node | null} node1\n   * @param {Node | null} node2\n   * @param {MorphContext} ctx\n   * @returns {boolean}\n   */\n  // TODO: The function handles this as if it's Element or null, but the function is called in\n  //   places where the arguments may be just a Node, not an Element\n  function isIdSetMatch(node1, node2, ctx) {\n    if (node1 == null || node2 == null) {\n      return false;\n    }\n    if (\n      node1 instanceof Element &&\n      node2 instanceof Element &&\n      node1.tagName === node2.tagName\n    ) {\n      if (node1.id !== \"\" && node1.id === node2.id) {\n        return true;\n      } else {\n        return getIdIntersectionCount(ctx, node1, node2) > 0;\n      }\n    }\n    return false;\n  }\n\n  /**\n   *\n   * @param {Node | null} oldNode\n   * @param {Node | null} newNode\n   * @returns {boolean}\n   */\n  function isSoftMatch(oldNode, newNode) {\n    if (oldNode == null || newNode == null) {\n      return false;\n    }\n    // ok to cast: if one is not element, `id` or `tagName` will be undefined and we'll compare that\n    // If oldNode has an `id` with possible state and it doesn't match newNode.id then avoid morphing\n    if (\n      /** @type {Element} */ (oldNode).id &&\n      /** @type {Element} */ (oldNode).id !==\n        /** @type {Element} */ (newNode).id\n    ) {\n      return false;\n    }\n    return (\n      oldNode.nodeType === newNode.nodeType &&\n      /** @type {Element} */ (oldNode).tagName ===\n        /** @type {Element} */ (newNode).tagName\n    );\n  }\n\n  /**\n   *\n   * @param {Node} startInclusive\n   * @param {Node} endExclusive\n   * @param {MorphContext} ctx\n   * @returns {Node | null}\n   */\n  function removeNodesBetween(startInclusive, endExclusive, ctx) {\n    /** @type {Node | null} */ let cursor = startInclusive;\n    while (cursor !== endExclusive) {\n      let tempNode = /** @type {Node} */ (cursor);\n      // TODO: Prefer assigning to a new variable here or expand the type of startInclusive\n      //  to be Node | null\n      cursor = tempNode.nextSibling;\n      removeNode(tempNode, ctx);\n    }\n    removeIdsFromConsideration(ctx, endExclusive);\n    return endExclusive.nextSibling;\n  }\n\n  /**\n   * =============================================================================\n   *  Scans forward from the insertionPoint in the old parent looking for a potential id match\n   *  for the newChild.  We stop if we find a potential id match for the new child OR\n   *  if the number of potential id matches we are discarding is greater than the\n   *  potential id matches for the new child\n   * =============================================================================\n   * @param {Node} newContent\n   * @param {Node} oldParent\n   * @param {Node} newChild\n   * @param {Node} insertionPoint\n   * @param {MorphContext} ctx\n   * @returns {null | Node}\n   */\n  function findIdSetMatch(\n    newContent,\n    oldParent,\n    newChild,\n    insertionPoint,\n    ctx,\n  ) {\n    // max id matches we are willing to discard in our search\n    let newChildPotentialIdCount = getIdIntersectionCount(\n      ctx,\n      newChild,\n      oldParent,\n    );\n\n    /**\n     * @type {Node | null}\n     */\n    let potentialMatch = null;\n\n    // only search forward if there is a possibility of an id match\n    if (newChildPotentialIdCount > 0) {\n      // TODO: This is ghosting the potentialMatch variable outside of this block.\n      //   Probably an error\n      potentialMatch = insertionPoint;\n      // if there is a possibility of an id match, scan forward\n      // keep track of the potential id match count we are discarding (the\n      // newChildPotentialIdCount must be greater than this to make it likely\n      // worth it)\n      let otherMatchCount = 0;\n      while (potentialMatch != null) {\n        // If we have an id match, return the current potential match\n        if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n          return potentialMatch;\n        }\n\n        // computer the other potential matches of this new content\n        otherMatchCount += getIdIntersectionCount(\n          ctx,\n          potentialMatch,\n          newContent,\n        );\n        if (otherMatchCount > newChildPotentialIdCount) {\n          // if we have more potential id matches in _other_ content, we\n          // do not have a good candidate for an id match, so return null\n          return null;\n        }\n\n        // advanced to the next old content child\n        potentialMatch = potentialMatch.nextSibling;\n      }\n    }\n    return potentialMatch;\n  }\n\n  /**\n   * =============================================================================\n   *  Scans forward from the insertionPoint in the old parent looking for a potential soft match\n   *  for the newChild.  We stop if we find a potential soft match for the new child OR\n   *  if we find a potential id match in the old parents children OR if we find two\n   *  potential soft matches for the next two pieces of new content\n   * =============================================================================\n   * @param {Node} newContent\n   * @param {Node} oldParent\n   * @param {Node} newChild\n   * @param {Node} insertionPoint\n   * @param {MorphContext} ctx\n   * @returns {null | Node}\n   */\n  function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n    /**\n     * @type {Node | null}\n     */\n    let potentialSoftMatch = insertionPoint;\n    /**\n     * @type {Node | null}\n     */\n    let nextSibling = newChild.nextSibling;\n    let siblingSoftMatchCount = 0;\n\n    while (potentialSoftMatch != null) {\n      if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n        // the current potential soft match has a potential id set match with the remaining new\n        // content so bail out of looking\n        return null;\n      }\n\n      // if we have a soft match with the current node, return it\n      if (isSoftMatch(potentialSoftMatch, newChild)) {\n        return potentialSoftMatch;\n      }\n\n      if (isSoftMatch(potentialSoftMatch, nextSibling)) {\n        // the next new node has a soft match with this node, so\n        // increment the count of future soft matches\n        siblingSoftMatchCount++;\n        // ok to cast: if it was null it couldn't be a soft match\n        nextSibling = /** @type {Node} */ (nextSibling).nextSibling;\n\n        // If there are two future soft matches, bail to allow the siblings to soft match\n        // so that we don't consume future soft matches for the sake of the current node\n        if (siblingSoftMatchCount >= 2) {\n          return null;\n        }\n      }\n\n      // advanced to the next old content child\n      potentialSoftMatch = potentialSoftMatch.nextSibling;\n    }\n\n    return potentialSoftMatch;\n  }\n\n  /** @type {WeakSet<Node>} */\n  const generatedByIdiomorph = new WeakSet();\n\n  /**\n   *\n   * @param {string} newContent\n   * @returns {Node | null | DocumentFragment}\n   */\n  function parseContent(newContent) {\n    let parser = new DOMParser();\n\n    // remove svgs to avoid false-positive matches on head, etc.\n    let contentWithSvgsRemoved = newContent.replace(\n      /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n      \"\",\n    );\n\n    // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n    if (\n      contentWithSvgsRemoved.match(/<\\/html>/) ||\n      contentWithSvgsRemoved.match(/<\\/head>/) ||\n      contentWithSvgsRemoved.match(/<\\/body>/)\n    ) {\n      let content = parser.parseFromString(newContent, \"text/html\");\n      // if it is a full HTML document, return the document itself as the parent container\n      if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n        generatedByIdiomorph.add(content);\n        return content;\n      } else {\n        // otherwise return the html element as the parent container\n        let htmlElement = content.firstChild;\n        if (htmlElement) {\n          generatedByIdiomorph.add(htmlElement);\n          return htmlElement;\n        } else {\n          return null;\n        }\n      }\n    } else {\n      // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n      // deal with touchy tags like tr, tbody, etc.\n      let responseDoc = parser.parseFromString(\n        \"<body><template>\" + newContent + \"</template></body>\",\n        \"text/html\",\n      );\n      let content = /** @type {HTMLTemplateElement} */ (\n        responseDoc.body.querySelector(\"template\")\n      ).content;\n      generatedByIdiomorph.add(content);\n      return content;\n    }\n  }\n\n  /**\n   *\n   * @param {null | Node | HTMLCollection | Node[] | Document & {generatedByIdiomorph:boolean}} newContent\n   * @returns {Element}\n   */\n  function normalizeContent(newContent) {\n    if (newContent == null) {\n      // noinspection UnnecessaryLocalVariableJS\n      const dummyParent = document.createElement(\"div\");\n      return dummyParent;\n    } else if (generatedByIdiomorph.has(/** @type {Element} */ (newContent))) {\n      // the template tag created by idiomorph parsing can serve as a dummy parent\n      return /** @type {Element} */ (newContent);\n    } else if (newContent instanceof Node) {\n      // a single node is added as a child to a dummy parent\n      const dummyParent = document.createElement(\"div\");\n      dummyParent.append(newContent);\n      return dummyParent;\n    } else {\n      // all nodes in the array or HTMLElement collection are consolidated under\n      // a single dummy parent element\n      const dummyParent = document.createElement(\"div\");\n      for (const elt of [...newContent]) {\n        dummyParent.append(elt);\n      }\n      return dummyParent;\n    }\n  }\n\n  /**\n   *\n   * @param {Node | null} previousSibling\n   * @param {Node} morphedNode\n   * @param {Node | null} nextSibling\n   * @returns {Node[]}\n   */\n  function insertSiblings(previousSibling, morphedNode, nextSibling) {\n    /**\n     * @type {Node[]}\n     */\n    let stack = [];\n    /**\n     * @type {Node[]}\n     */\n    let added = [];\n    while (previousSibling != null) {\n      stack.push(previousSibling);\n      previousSibling = previousSibling.previousSibling;\n    }\n    // Base the loop on the node variable, so that you do not need runtime checks for\n    // undefined value inside the loop\n    let node = stack.pop();\n    while (node !== undefined) {\n      added.push(node); // push added preceding siblings on in order and insert\n      morphedNode.parentElement?.insertBefore(node, morphedNode);\n      node = stack.pop();\n    }\n    added.push(morphedNode);\n    while (nextSibling != null) {\n      stack.push(nextSibling);\n      added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n      nextSibling = nextSibling.nextSibling;\n    }\n    while (stack.length > 0) {\n      const node = /** @type {Node} */ (stack.pop());\n      morphedNode.parentElement?.insertBefore(node, morphedNode.nextSibling);\n    }\n    return added;\n  }\n\n  /**\n   *\n   * @param {Element} newContent\n   * @param {Element} oldNode\n   * @param {MorphContext} ctx\n   * @returns {Node | null}\n   */\n  function findBestNodeMatch(newContent, oldNode, ctx) {\n    /**\n     * @type {Node | null}\n     */\n    let currentElement;\n    currentElement = newContent.firstChild;\n    /**\n     * @type {Node | null}\n     */\n    let bestElement = currentElement;\n    let score = 0;\n    while (currentElement) {\n      let newScore = scoreElement(currentElement, oldNode, ctx);\n      if (newScore > score) {\n        bestElement = currentElement;\n        score = newScore;\n      }\n      currentElement = currentElement.nextSibling;\n    }\n    return bestElement;\n  }\n\n  /**\n   *\n   * @param {Node | null} node1\n   * @param {Element} node2\n   * @param {MorphContext} ctx\n   * @returns {number}\n   */\n  // TODO: The function handles node1 and node2 as if they are Elements but the function is\n  //   called in places where node1 and node2 may be just Nodes, not Elements\n  function scoreElement(node1, node2, ctx) {\n    if (isSoftMatch(node2, node1)) {\n      // ok to cast: isSoftMatch performs a null check\n      return (\n        0.5 + getIdIntersectionCount(ctx, /** @type {Node} */ (node1), node2)\n      );\n    }\n    return 0;\n  }\n\n  /**\n   *\n   * @param {Node} tempNode\n   * @param {MorphContext} ctx\n   */\n  // TODO: The function handles tempNode as if it's Element but the function is called in\n  //   places where tempNode may be just a Node, not an Element\n  function removeNode(tempNode, ctx) {\n    removeIdsFromConsideration(ctx, tempNode);\n    // skip remove callbacks when we're going to be restoring this from the pantry in the second pass\n    if (\n      ctx.config.twoPass &&\n      hasPersistentIdNodes(ctx, tempNode) &&\n      tempNode instanceof Element\n    ) {\n      moveToPantry(tempNode, ctx);\n    } else {\n      if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;\n      tempNode.parentNode?.removeChild(tempNode);\n      ctx.callbacks.afterNodeRemoved(tempNode);\n    }\n  }\n\n  /**\n   *\n   * @param {Node} node\n   * @param {MorphContext} ctx\n   */\n  function moveToPantry(node, ctx) {\n    if (ctx.callbacks.beforeNodePantried(node) === false) return;\n\n    Array.from(node.childNodes).forEach((child) => {\n      moveToPantry(child, ctx);\n    });\n\n    // After processing children, process the current node\n    if (ctx.persistentIds.has(/** @type {Element} */ (node).id)) {\n      // @ts-ignore - use proposed moveBefore feature\n      if (ctx.pantry.moveBefore) {\n        // @ts-ignore - use proposed moveBefore feature\n        ctx.pantry.moveBefore(node, null);\n      } else {\n        ctx.pantry.insertBefore(node, null);\n      }\n    } else {\n      if (ctx.callbacks.beforeNodeRemoved(node) === false) return;\n      node.parentNode?.removeChild(node);\n      ctx.callbacks.afterNodeRemoved(node);\n    }\n  }\n\n  /**\n   *\n   * @param {Node | null} root\n   * @param {MorphContext} ctx\n   */\n  function restoreFromPantry(root, ctx) {\n    if (root instanceof Element) {\n      Array.from(ctx.pantry.children)\n        .reverse()\n        .forEach((element) => {\n          const matchElement = root.querySelector(`#${element.id}`);\n          if (matchElement) {\n            // @ts-ignore - use proposed moveBefore feature\n            if (matchElement.parentElement?.moveBefore) {\n              // @ts-ignore - use proposed moveBefore feature\n              matchElement.parentElement.moveBefore(element, matchElement);\n              while (matchElement.hasChildNodes()) {\n                // @ts-ignore - use proposed moveBefore feature\n                element.moveBefore(matchElement.firstChild, null);\n              }\n            } else {\n              matchElement.before(element);\n              while (matchElement.firstChild) {\n                element.insertBefore(matchElement.firstChild, null);\n              }\n            }\n            if (\n              ctx.callbacks.beforeNodeMorphed(element, matchElement) !== false\n            ) {\n              syncNodeFrom(matchElement, element, ctx);\n              ctx.callbacks.afterNodeMorphed(element, matchElement);\n            }\n            matchElement.remove();\n          }\n        });\n      ctx.pantry.remove();\n    }\n  }\n\n  //=============================================================================\n  // ID Set Functions\n  //=============================================================================\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {string} id\n   * @returns {boolean}\n   */\n  function isIdInConsideration(ctx, id) {\n    return !ctx.deadIds.has(id);\n  }\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {string} id\n   * @param {Node} targetNode\n   * @returns {boolean}\n   */\n  function idIsWithinNode(ctx, id, targetNode) {\n    let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;\n    return idSet.has(id);\n  }\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {Node} node\n   * @returns {void}\n   */\n  function removeIdsFromConsideration(ctx, node) {\n    let idSet = ctx.idMap.get(node) || EMPTY_SET;\n    for (const id of idSet) {\n      ctx.deadIds.add(id);\n    }\n  }\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function hasPersistentIdNodes(ctx, node) {\n    for (const id of ctx.idMap.get(node) || EMPTY_SET) {\n      if (ctx.persistentIds.has(id)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   *\n   * @param {MorphContext} ctx\n   * @param {Node} node1\n   * @param {Node} node2\n   * @returns {number}\n   */\n  function getIdIntersectionCount(ctx, node1, node2) {\n    let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;\n    let matchCount = 0;\n    for (const id of sourceSet) {\n      // a potential match is an id in the source and potentialIdsSet, but\n      // that has not already been merged into the DOM\n      if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n        ++matchCount;\n      }\n    }\n    return matchCount;\n  }\n\n  /**\n   * @param {Element} content\n   * @returns {Element[]}\n   */\n  function nodesWithIds(content) {\n    let nodes = Array.from(content.querySelectorAll(\"[id]\"));\n    if (content.id) {\n      nodes.push(content);\n    }\n    return nodes;\n  }\n\n  /**\n   * A bottom up algorithm that finds all elements with ids in the node\n   * argument and populates id sets for those nodes and all their parents, generating\n   * a set of ids contained within all nodes for the entire hierarchy in the DOM\n   *\n   * @param {Element} node\n   * @param {Map<Node, Set<string>>} idMap\n   */\n  function populateIdMapForNode(node, idMap) {\n    let nodeParent = node.parentElement;\n    for (const elt of nodesWithIds(node)) {\n      /**\n       * @type {Element|null}\n       */\n      let current = elt;\n      // walk up the parent hierarchy of that element, adding the id\n      // of element to the parent's id set\n      while (current !== nodeParent && current != null) {\n        let idSet = idMap.get(current);\n        // if the id set doesn't exist, create it and insert it in the  map\n        if (idSet == null) {\n          idSet = new Set();\n          idMap.set(current, idSet);\n        }\n        idSet.add(elt.id);\n        current = current.parentElement;\n      }\n    }\n  }\n\n  /**\n   * This function computes a map of nodes to all ids contained within that node (inclusive of the\n   * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n   * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n   * to contribute to a parent nodes matching.\n   *\n   * @param {Element} oldContent  the old content that will be morphed\n   * @param {Element} newContent  the new content to morph to\n   * @returns {Map<Node, Set<string>>} a map of nodes to id sets for the\n   */\n  function createIdMap(oldContent, newContent) {\n    /**\n     *\n     * @type {Map<Node, Set<string>>}\n     */\n    let idMap = new Map();\n    populateIdMapForNode(oldContent, idMap);\n    populateIdMapForNode(newContent, idMap);\n    return idMap;\n  }\n\n  /**\n   * @param {Element} oldContent  the old content that will be morphed\n   * @param {Element} newContent  the new content to morph to\n   * @returns {Set<string>} the id set of all persistent nodes that exist in both old and new content\n   */\n  function createPersistentIds(oldContent, newContent) {\n    const toIdTagName = (node) => node.tagName + \"#\" + node.id;\n    const oldIdSet = new Set(nodesWithIds(oldContent).map(toIdTagName));\n\n    let matchIdSet = new Set();\n    for (const newNode of nodesWithIds(newContent)) {\n      if (oldIdSet.has(toIdTagName(newNode))) {\n        matchIdSet.add(newNode.id);\n      }\n    }\n    return matchIdSet;\n  }\n\n  //=============================================================================\n  // This is what ends up becoming the Idiomorph global object\n  //=============================================================================\n  return {\n    morph,\n    defaults,\n  };\n})();\n\nexport {Idiomorph};\n", "// Icon: material-symbols:cloud-download\n// Slug: Merge fragments into the DOM using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DefaultFragmentMergeMode,\n  DefaultFragmentsSettleDurationMs,\n  DefaultFragmentsUseViewTransitions,\n  EventTypes,\n  FragmentMergeModes,\n} from '../../../../engine/consts'\nimport { initErr } from '../../../../engine/errors'\nimport {\n  type HTMLorSVGElement,\n  type InitContext,\n  PluginType,\n  type WatcherPlugin,\n} from '../../../../engine/types'\nimport { camel, isBoolString } from '../../../../utils/text'\nimport {\n  docWithViewTransitionAPI,\n  supportsViewTransitions,\n} from '../../../../utils/view-transtions'\nimport { Idiomorph } from '../../../../vendored/idiomorph.esm'\nimport {\n  SETTLING_CLASS,\n  SWAPPING_CLASS,\n  datastarSSEEventWatcher,\n} from '../shared'\n\nexport const MergeFragments: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypes.MergeFragments,\n  onGlobalInit: async (ctx) => {\n    const fragmentContainer = document.createElement('template')\n    datastarSSEEventWatcher(\n      EventTypes.MergeFragments,\n      ({\n        fragments: fragmentsRaw = '<div></div>',\n        selector = '',\n        mergeMode = DefaultFragmentMergeMode,\n        settleDuration:\n          settleDurationRaw = `${DefaultFragmentsSettleDurationMs}`,\n        useViewTransition:\n          useViewTransitionRaw = `${DefaultFragmentsUseViewTransitions}`,\n      }) => {\n        const settleDuration = Number.parseInt(settleDurationRaw)\n        const useViewTransition = isBoolString(useViewTransitionRaw)\n\n        fragmentContainer.innerHTML = fragmentsRaw.trim()\n        const fragments = [...fragmentContainer.content.children]\n        for (const fragment of fragments) {\n          if (!(fragment instanceof Element)) {\n            throw initErr('NoFragmentsFound', ctx)\n          }\n\n          const selectorOrID = selector || `#${fragment.getAttribute('id')}`\n          const targets = [...(document.querySelectorAll(selectorOrID) || [])]\n          if (!targets.length) {\n            throw initErr('NoTargetsFound', ctx, { selectorOrID })\n          }\n\n          if (useViewTransition && supportsViewTransitions) {\n            docWithViewTransitionAPI.startViewTransition(() =>\n              applyToTargets(ctx, mergeMode, settleDuration, fragment, targets),\n            )\n          } else {\n            applyToTargets(ctx, mergeMode, settleDuration, fragment, targets)\n          }\n        }\n      },\n    )\n  },\n}\n\nfunction applyToTargets(\n  ctx: InitContext,\n  mergeMode: string,\n  settleDuration: number,\n  fragment: Element,\n  capturedTargets: Element[],\n) {\n  for (const initialTarget of capturedTargets) {\n    initialTarget.classList.add(SWAPPING_CLASS)\n    const originalHTML = initialTarget.outerHTML\n    let modifiedTarget = initialTarget\n    switch (mergeMode) {\n      case FragmentMergeModes.Morph: {\n        const toApply = new Map<Element, Array<string>>()\n        const result = Idiomorph.morph(modifiedTarget, fragment, {\n          callbacks: {\n            beforeAttributeUpdated: (\n              argument: string,\n              el: Element,\n              mode: 'update' | 'remove',\n            ): boolean => {\n              if (mode === 'update' && argument.startsWith('data-')) {\n                let elAddAttrs = toApply.get(el)\n                if (!elAddAttrs) {\n                  elAddAttrs = []\n                  toApply.set(el, elAddAttrs)\n                }\n                const name = argument.slice('data-'.length)\n                elAddAttrs.push(camel(name))\n              }\n              return true\n            },\n          },\n        })\n        if (!result?.length) {\n          throw initErr('MorphFailed', ctx)\n        }\n        modifiedTarget = result[0] as Element\n\n        for (const [el, attrs] of toApply.entries()) {\n          for (const attr of attrs) {\n            ctx.applyAttributePlugin(el as HTMLorSVGElement, attr)\n          }\n        }\n\n        break\n      }\n      case FragmentMergeModes.Inner:\n        // Replace the contents of the target element with the outer HTML of the response\n        modifiedTarget.innerHTML = fragment.outerHTML\n        break\n      case FragmentMergeModes.Outer:\n        // Replace the entire target element with the response\n        modifiedTarget.replaceWith(fragment)\n        break\n      case FragmentMergeModes.Prepend:\n        // Insert the response before the first child of the target element\n        modifiedTarget.prepend(fragment)\n        break\n      case FragmentMergeModes.Append:\n        // Insert the response after the last child of the target element\n        modifiedTarget.append(fragment)\n        break\n      case FragmentMergeModes.Before:\n        // Insert the response before the target element\n        modifiedTarget.before(fragment)\n        break\n      case FragmentMergeModes.After:\n        // Insert the response after the target element\n        modifiedTarget.after(fragment)\n        break\n      case FragmentMergeModes.UpsertAttributes:\n        // Upsert the attributes of the target element\n        for (const attrName of fragment.getAttributeNames()) {\n          const value = fragment.getAttribute(attrName)!\n          modifiedTarget.setAttribute(attrName, value)\n        }\n        break\n      default:\n        throw initErr('InvalidMergeMode', ctx, { mergeMode })\n    }\n\n    const cl = modifiedTarget.classList\n    cl.add(SWAPPING_CLASS)\n\n    // ctx.apply(document.body)\n\n    setTimeout(() => {\n      initialTarget.classList.remove(SWAPPING_CLASS)\n      cl.remove(SWAPPING_CLASS)\n    }, settleDuration)\n\n    const revisedHTML = modifiedTarget.outerHTML\n\n    if (originalHTML !== revisedHTML) {\n      cl.add(SETTLING_CLASS)\n      setTimeout(() => {\n        cl.remove(SETTLING_CLASS)\n      }, settleDuration)\n    }\n  }\n}\n", "// Icon: material-symbols:settings-input-antenna\n// Slug: Merge signals using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DefaultMergeSignalsOnlyIfMissing,\n  EventTypes,\n} from '../../../../engine/consts'\nimport { PluginType, type WatcherPlugin } from '../../../../engine/types'\nimport { isBoolString, jsStrToObject } from '../../../../utils/text'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const MergeSignals: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypes.MergeSignals,\n  onGlobalInit: async (ctx) => {\n    datastarSSEEventWatcher(\n      EventTypes.MergeSignals,\n      ({\n        signals: raw = '{}',\n        onlyIfMissing: onlyIfMissingRaw = `${DefaultMergeSignalsOnlyIfMissing}`,\n      }) => {\n        const { signals } = ctx\n        const onlyIfMissing = isBoolString(onlyIfMissingRaw)\n        signals.merge(jsStrToObject(raw), onlyIfMissing)\n      },\n    )\n  },\n}\n", "// Icon: material-symbols:settings-input-antenna\n// Slug: Remove fragments from the DOM using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DefaultFragmentsSettleDurationMs,\n  DefaultFragmentsUseViewTransitions,\n  EventTypes,\n} from '../../../../engine/consts'\nimport { initErr } from '../../../../engine/errors'\nimport { PluginType, type WatcherPlugin } from '../../../../engine/types'\nimport { isBoolString } from '../../../../utils/text'\nimport {\n  docWithViewTransitionAPI,\n  supportsViewTransitions,\n} from '../../../../utils/view-transtions'\nimport { SWAPPING_CLASS, datastarSSEEventWatcher } from '../shared'\n\nexport const RemoveFragments: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypes.RemoveFragments,\n  onGlobalInit: async (ctx) => {\n    datastarSSEEventWatcher(\n      EventTypes.RemoveFragments,\n      ({\n        selector,\n        settleDuration:\n          settleDurationRaw = `${DefaultFragmentsSettleDurationMs}`,\n        useViewTransition:\n          useViewTransitionRaw = `${DefaultFragmentsUseViewTransitions}`,\n      }) => {\n        if (!selector.length) {\n          throw initErr('NoSelectorProvided', ctx)\n        }\n\n        const settleDuration = Number.parseInt(settleDurationRaw)\n        const useViewTransition = isBoolString(useViewTransitionRaw)\n        const removeTargets = document.querySelectorAll(selector)\n\n        const applyToTargets = () => {\n          for (const target of removeTargets) {\n            target.classList.add(SWAPPING_CLASS)\n          }\n\n          setTimeout(() => {\n            for (const target of removeTargets) {\n              target.remove()\n            }\n          }, settleDuration)\n        }\n\n        if (useViewTransition && supportsViewTransitions) {\n          docWithViewTransitionAPI.startViewTransition(() => applyToTargets())\n        } else {\n          applyToTargets()\n        }\n      },\n    )\n  },\n}\n", "// Icon: material-symbols:settings-input-antenna\n// Slug: Remove signals using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { EventTypes } from '../../../../engine/consts'\nimport { initErr } from '../../../../engine/errors'\nimport { PluginType, type WatcherPlugin } from '../../../../engine/types'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const RemoveSignals: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypes.RemoveSignals,\n  onGlobalInit: async (ctx) => {\n    datastarSSEEventWatcher(\n      EventTypes.RemoveSignals,\n      ({ paths: pathsRaw = '' }) => {\n        const paths = pathsRaw.split('\\n').map((p) => p.trim())\n        if (!paths?.length) {\n          throw initErr('NoPathsProvided', ctx)\n        }\n        ctx.signals.remove(...paths)\n      },\n    )\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: mdi:clipboard\n// Slug: Copy text to the clipboard\n// Description: This action copies text to the clipboard using the Clipboard API.\n\nimport { runtimeErr } from '../../../../engine/errors'\nimport { type ActionPlugin, PluginType } from '../../../../engine/types'\n\nexport const Clipboard: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'clipboard',\n  fn: (ctx, text) => {\n    if (!navigator.clipboard) {\n      throw runtimeErr('ClipboardNotAvailable', ctx)\n    }\n    navigator.clipboard.writeText(text)\n  },\n}\n", "// Authors: Ben Croker\n// Icon: mdi-message-alert\n// Slug: Add custom validity to an element using an expression\n// Description: This plugin allows you to add custom validity to an element using an expression. The expression should evaluate to a string that will be set as the custom validity message. This can be used to provide custom error messages for form validation.\n\nimport { runtimeErr } from '../../../../engine/errors'\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nexport const CustomValidity: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'customValidity',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Must,\n  onLoad: (ctx) => {\n    const { el, genRX, effect } = ctx\n    if (!(el instanceof HTMLInputElement || el instanceof HTMLSelectElement || el instanceof HTMLTextAreaElement)) {\n      throw runtimeErr('CustomValidityInvalidElement', ctx)\n    }\n    const rx = genRX()\n    return effect(() => {\n      const result = rx<string>()\n      if (typeof result !== 'string') {\n        throw runtimeErr('CustomValidityInvalidExpression', ctx, { result })\n      }\n      el.setCustomValidity(result)\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: mdi-light:vector-intersection\n// Slug: Run expression when element intersects with viewport\n// Description: An attribute that runs an expression when the element intersects with the viewport.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nconst ONCE = 'once'\nconst HALF = 'half'\nconst FULL = 'full'\n\n// Run expression when element intersects with viewport\nexport const Intersects: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'intersects',\n  keyReq: Requirement.Denied,\n  mods: new Set([ONCE, HALF, FULL]),\n  onLoad: ({ el, rawKey, mods, genRX }) => {\n    const options = { threshold: 0 }\n    if (mods.has(FULL)) options.threshold = 1\n    else if (mods.has(HALF)) options.threshold = 0.5\n\n    const rx = genRX()\n    const observer = new IntersectionObserver((entries) => {\n      for (const entry of entries) {\n        if (entry.isIntersecting) {\n          rx()\n          if (mods.has(ONCE)) {\n            observer.disconnect()\n            delete el.dataset[rawKey]\n          }\n        }\n      }\n    }, options)\n\n    observer.observe(el)\n    return () => observer.disconnect()\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: mdi:floppy-variant\n// Slug: Persist data to local storage or session storage\n// Description: This plugin allows you to persist data to local storage or session storage.  Once you add this attribute the data will be persisted to local storage or session storage.\n\nimport { DATASTAR } from '../../../../engine/consts'\nimport {\n  type AttributePlugin,\n  type NestedValues,\n  PluginType,\n} from '../../../../engine/types'\nimport { modifyCasing, trimDollarSignPrefix } from '../../../../utils/text'\n\nconst SESSION = 'session'\n\nexport const Persist: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'persist',\n  mods: new Set([SESSION]),\n  onLoad: ({ key, effect, mods, signals, value }) => {\n    key = modifyCasing(key, mods)\n    if (key === '') {\n      key = DATASTAR\n    }\n\n    const storage = mods.has(SESSION) ? sessionStorage : localStorage\n    let paths = value.split(/\\s+/).filter((p) => p !== '')\n    paths = paths.map((p) => trimDollarSignPrefix(p))\n\n    const storageToSignals = () => {\n      const data = storage.getItem(key) || '{}'\n      const nestedValues = JSON.parse(data)\n      signals.merge(nestedValues)\n    }\n\n    const signalsToStorage = () => {\n      let nv: NestedValues\n      if (!paths.length) {\n        nv = signals.values()\n      } else {\n        nv = signals.subset(...paths)\n      }\n      storage.setItem(key, JSON.stringify(nv))\n    }\n\n    storageToSignals()\n    return effect(() => {\n      signalsToStorage()\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: carbon:url\n// Slug: Replace the current URL with a new URL\n// Description: This plugin allows you to replace the current URL with a new URL.  Once you add this attribute the current URL will be replaced with the new URL.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nexport const ReplaceUrl: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'replaceUrl',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Must,\n  onLoad: ({ effect, genRX }) => {\n    const rx = genRX()\n    return effect(() => {\n      const url = rx<string>()\n      const baseUrl = window.location.href\n      const fullUrl = new URL(url, baseUrl).toString()\n      window.history.replaceState({}, '', fullUrl)\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: hugeicons:mouse-scroll-01\n// Slug: Scroll an element into view\n// Description: This attribute scrolls the element into view.\n\nimport { runtimeErr } from '../../../../engine/errors'\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nconst SMOOTH = 'smooth'\nconst INSTANT = 'instant'\nconst AUTO = 'auto'\nconst HSTART = 'hstart'\nconst HCENTER = 'hcenter'\nconst HEND = 'hend'\nconst HNEAREST = 'hnearest'\nconst VSTART = 'vstart'\nconst VCENTER = 'vcenter'\nconst VEND = 'vend'\nconst VNEAREST = 'vnearest'\nconst FOCUS = 'focus'\n\nconst CENTER = 'center'\nconst START = 'start'\nconst END = 'end'\nconst NEAREST = 'nearest'\n\n// Scrolls the element into view\nexport const ScrollIntoView: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'scrollIntoView',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Denied,\n  mods: new Set([\n    SMOOTH,\n    INSTANT,\n    AUTO,\n    HSTART,\n    HCENTER,\n    HEND,\n    HNEAREST,\n    VSTART,\n    VCENTER,\n    VEND,\n    VNEAREST,\n    FOCUS,\n  ]),\n\n  onLoad: (ctx) => {\n    const { el, mods, rawKey } = ctx\n    if (!el.tabIndex) el.setAttribute('tabindex', '0')\n    const opts: ScrollIntoViewOptions = {\n      behavior: SMOOTH,\n      block: CENTER,\n      inline: CENTER,\n    }\n    if (mods.has(SMOOTH)) opts.behavior = SMOOTH\n    if (mods.has(INSTANT)) opts.behavior = INSTANT\n    if (mods.has(AUTO)) opts.behavior = AUTO\n    if (mods.has(HSTART)) opts.inline = START\n    if (mods.has(HCENTER)) opts.inline = CENTER\n    if (mods.has(HEND)) opts.inline = END\n    if (mods.has(HNEAREST)) opts.inline = NEAREST\n    if (mods.has(VSTART)) opts.block = START\n    if (mods.has(VCENTER)) opts.block = CENTER\n    if (mods.has(VEND)) opts.block = END\n    if (mods.has(VNEAREST)) opts.block = NEAREST\n\n    if (!(el instanceof HTMLElement || el instanceof SVGElement)) {\n      throw runtimeErr('ScrollIntoViewInvalidElement', ctx)\n    }\n    if (!el.tabIndex) {\n      el.setAttribute('tabindex', '0')\n    }\n\n    el.scrollIntoView(opts)\n    if (mods.has('focus')) {\n      el.focus()\n    }\n\n    delete el.dataset[rawKey]\n    return () => {}\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: streamline:interface-edit-view-eye-eyeball-open-view\n// Slug: Show or hide an element\n// Description: This attribute shows or hides an element based on the value of the expression. If the expression is true, the element is shown. If the expression is false, the element is hidden. The element is hidden by setting the display property to none.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nconst NONE = 'none'\nconst DISPLAY = 'display'\n\nexport const Show: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'show',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Must,\n  onLoad: ({ el: { style: s }, genRX, effect }) => {\n    const rx = genRX()\n    return effect(async () => {\n      const shouldShow = rx<boolean>()\n      if (shouldShow) {\n        if (s.display === NONE) {\n          s.removeProperty(DISPLAY)\n        }\n      } else {\n        s.setProperty(DISPLAY, NONE)\n      }\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:masked-transitions\n// Slug: Setup view transitions\n// Description: This attribute plugin sets up view transitions for the current view. This plugin requires the view transition API to be enabled in the browser. If the browser does not support view transitions, an error will be logged to the console.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { supportsViewTransitions } from '../../../../utils/view-transtions'\n\nconst VIEW_TRANSITION = 'view-transition'\n\nexport const ViewTransition: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'viewTransition',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Must,\n  onGlobalInit() {\n    let hasViewTransitionMeta = false\n    for (const node of document.head.childNodes) {\n      if (node instanceof HTMLMetaElement && node.name === VIEW_TRANSITION) {\n        hasViewTransitionMeta = true\n      }\n    }\n\n    if (!hasViewTransitionMeta) {\n      const meta = document.createElement('meta')\n      meta.name = VIEW_TRANSITION\n      meta.content = 'same-origin'\n      document.head.appendChild(meta)\n    }\n  },\n  onLoad: ({ effect, el, genRX }) => {\n    if (!supportsViewTransitions) {\n      console.error('Browser does not support view transitions')\n      return\n    }\n    const rx = genRX()\n    return effect(() => {\n      const name = rx<string>()\n      if (!name?.length) return\n      const elVTASTyle = el.style as unknown as CSSStyleDeclaration\n      elVTASTyle.viewTransitionName = name\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: akar-icons:link-chain\n// Slug: Bind attributes to expressions\n// Description: Any attribute can be bound to an expression. The attribute will be updated reactively whenever the expression signal changes.\n\nimport {\n  type AttributePlugin,\n  type NestedValues,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { kebab } from '../../../../utils/text'\n\nexport const Attr: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'attr',\n  valReq: Requirement.Must,\n  onLoad: ({ el, key, effect, genRX }) => {\n    const rx = genRX()\n    if (key === '') {\n      return effect(async () => {\n        const binds = rx<NestedValues>()\n        for (const [attr, val] of Object.entries(binds)) {\n          el.setAttribute(attr, val)\n        }\n      })\n    }\n\n    // Attributes are always kebab-case\n    key = kebab(key)\n\n    return effect(async () => {\n      let value = false\n      try {\n        value = rx()\n      } catch (e) {} //\n      let v: string\n      if (typeof value === 'string') {\n        v = value\n      } else {\n        v = JSON.stringify(value)\n      }\n      if (!v || v === 'false' || v === 'null' || v === 'undefined') {\n        el.removeAttribute(key)\n      } else {\n        el.setAttribute(key, v)\n      }\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: akar-icons:link-chain\n// Slug: Bind attributes to expressions\n// Description: Any attribute can be bound to an expression. The attribute will be updated reactively whenever the expression signal changes.\n\nimport { runtimeErr } from '../../../../engine/errors'\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { modifyCasing, trimDollarSignPrefix } from '../../../../utils/text'\n\nconst dataURIRegex = /^data:(?<mime>[^;]+);base64,(?<contents>.*)$/\nconst updateEvents = ['change', 'input', 'keydown']\n\nexport const Bind: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'bind',\n  keyReq: Requirement.Exclusive,\n  valReq: Requirement.Exclusive,\n  onLoad: (ctx) => {\n    const { el, key, mods, signals, value, effect } = ctx\n    const signalName = key ? modifyCasing(key, mods) : trimDollarSignPrefix(value)\n\n    let setFromSignal = () => {}\n    let el2sig = () => {}\n\n    const tnl = el.tagName.toLowerCase()\n    let signalDefault: string | boolean | number | File = ''\n    const isInput = tnl.includes('input')\n    const type = el.getAttribute('type')\n    const isCheckbox =\n      tnl.includes('checkbox') || (isInput && type === 'checkbox')\n    if (isCheckbox) {\n      signalDefault = false\n    }\n    const isNumber = isInput && type === 'number'\n    if (isNumber) {\n      signalDefault = 0\n    }\n    const isSelect = tnl.includes('select')\n    const isRadio = tnl.includes('radio') || (isInput && type === 'radio')\n    const isFile = isInput && type === 'file'\n    if (isFile) {\n      // can't set a default value for a file input, yet\n    }\n    if (isRadio) {\n      const name = el.getAttribute('name')\n      if (!name?.length) {\n        el.setAttribute('name', signalName)\n      }\n    }\n\n    signals.upsertIfMissing(signalName, signalDefault)\n\n    setFromSignal = () => {\n      const hasValue = 'value' in el\n      const v = signals.value(signalName)\n      const vStr = `${v}`\n      if (isCheckbox || isRadio) {\n        const input = el as HTMLInputElement\n        if (isCheckbox) {\n          input.checked = !!v || v === 'true'\n        } else if (isRadio) {\n          // evaluate the value as string to handle any type casting\n          // automatically since the attribute has to be a string anyways\n          input.checked = vStr === input.value\n        }\n      } else if (isFile) {\n        // File input reading from a signal is not supported yet\n      } else if (isSelect) {\n        const select = el as HTMLSelectElement\n        if (select.multiple) {\n          for (const opt of select.options) {\n            if (opt?.disabled) return\n            if (Array.isArray(v) || typeof v === 'string') {\n              opt.selected = v.includes(opt.value)\n            } else if (typeof v === 'number') {\n              opt.selected = v === Number(opt.value)\n            } else {\n              opt.selected = v as boolean\n            }\n          }\n        } else {\n          select.value = vStr\n        }\n      } else if (hasValue) {\n        el.value = vStr\n      } else {\n        el.setAttribute('value', vStr)\n      }\n    }\n\n    el2sig = async () => {\n      if (isFile) {\n        const files = [...((el as HTMLInputElement)?.files || [])]\n        const allContents: string[] = []\n        const allMimes: string[] = []\n        const allNames: string[] = []\n\n        await Promise.all(\n          files.map((f) => {\n            return new Promise<void>((resolve) => {\n              const reader = new FileReader()\n              reader.onload = () => {\n                if (typeof reader.result !== 'string') {\n                  throw runtimeErr('InvalidFileResultType', ctx, {\n                    resultType: typeof reader.result,\n                  })\n                }\n                const match = reader.result.match(dataURIRegex)\n                if (!match?.groups) {\n                  throw runtimeErr('InvalidDataUri', ctx, {\n                    result: reader.result,\n                  })\n                }\n                allContents.push(match.groups.contents)\n                allMimes.push(match.groups.mime)\n                allNames.push(f.name)\n              }\n              reader.onloadend = () => resolve(void 0)\n              reader.readAsDataURL(f)\n            })\n          }),\n        )\n\n        signals.setValue(signalName, allContents)\n        signals.setValue(`${signalName}Mimes`, allMimes)\n        signals.setValue(`${signalName}Names`, allNames)\n\n        return\n      }\n\n      const current = signals.value(signalName)\n      const input = (el as HTMLInputElement) || (el as HTMLElement)\n\n      if (typeof current === 'number') {\n        const v = Number(input.value || input.getAttribute('value'))\n        signals.setValue(signalName, v)\n      } else if (typeof current === 'string') {\n        const v = input.value || input.getAttribute('value') || ''\n        signals.setValue(signalName, v)\n      } else if (typeof current === 'boolean') {\n        if (isCheckbox) {\n          const v = input.checked || input.getAttribute('checked') === 'true'\n          signals.setValue(signalName, v)\n        } else {\n          const v = Boolean(input.value || input.getAttribute('value'))\n          signals.setValue(signalName, v)\n        }\n      } else if (typeof current === 'undefined') {\n      } else if (Array.isArray(current)) {\n        // check if the input is a select element\n        if (isSelect) {\n          const select = el as HTMLSelectElement\n          const selectedOptions = [...select.selectedOptions]\n          const selectedValues = selectedOptions\n            .filter((opt) => opt.selected)\n            .map((opt) => opt.value)\n          signals.setValue(signalName, selectedValues)\n        } else {\n          // assume it's a comma-separated string\n          const v = JSON.stringify(input.value.split(','))\n          signals.setValue(signalName, v)\n        }\n      } else {\n        throw runtimeErr('BindUnsupportedSignalType', ctx, {\n          signalType: typeof current,\n        })\n      }\n    }\n\n    for (const event of updateEvents) {\n      el.addEventListener(event, el2sig)\n    }\n    const elSigClean = effect(() => setFromSignal())\n    /*\n     * The signal value needs to be updated after the \"pageshow\" event.\n     * Sometimes, the browser might populate inputs with previous values\n     * when navigating between pages using the back/forward navigation.\n     *\n     * For more information, read about bfcache:\n     * https://web.dev/articles/bfcache\n     */\n    const onPageshow = (ev: PageTransitionEvent) => {\n      if (!ev.persisted) return\n      el2sig()\n    }\n    window.addEventListener(\"pageshow\", onPageshow)\n\n    return () => {\n      elSigClean()\n      for (const event of updateEvents) {\n        el.removeEventListener(event, el2sig)\n      }\n      window.removeEventListener(\"pageshow\", onPageshow)\n    }\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: ic:baseline-format-paint\n// Slug: Add or remove classes from an element reactively\n// Description: This action adds or removes classes from an element reactively based on the expression provided. The expression should be an object where the keys are the class names and the values are booleans. If the value is true, the class is added. If the value is false, the class is removed.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { modifyCasing } from '../../../../utils/text'\n\nexport const Class: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'class',\n  valReq: Requirement.Must,\n  onLoad: ({ el, key, mods, effect, genRX }) => {\n    const cl = el.classList\n    const rx = genRX()\n    return effect(() => {\n      if (key === '') {\n        const classes = rx<Record<string, boolean>>()\n        for (const [k, v] of Object.entries(classes)) {\n          const classNames = k.split(/\\s+/)\n          if (v) {\n            cl.add(...classNames)\n          } else {\n            cl.remove(...classNames)\n          }\n        }\n      } else {\n        key = modifyCasing(key, mods)\n        const shouldInclude = rx<boolean>()\n        if (shouldInclude) {\n          cl.add(key)\n        } else {\n          cl.remove(key)\n        }\n      }\n    })\n  },\n}\n", "export function tagToMs(args: Set<string>) {\n  if (!args || args.size <= 0) return 0\n  for (const arg of args) {\n    if (arg.endsWith('ms')) {\n      return Number(arg.replace('ms', ''))\n    }\n    if (arg.endsWith('s')) {\n      return Number(arg.replace('s', '')) * 1000\n    }\n    try {\n      return Number.parseFloat(arg)\n    } catch (e) {}\n  }\n  return 0\n}\n\nexport function tagHas(tags: Set<string>, tag: string, defaultValue = false) {\n  if (!tags) return defaultValue\n  return tags.has(tag.toLowerCase())\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:mail\n// Slug: Add an event listener to an element\n// Description: This action adds an event listener to an element. The event listener can be triggered by a variety of events, such as clicks, keypresses, and more. The event listener can also be set to trigger only once, or to be passive or capture. The event listener can also be debounced or throttled. The event listener can also be set to trigger only when the event target is outside the element.\n\nimport {\n  type AttributePlugin,\n  DATASTAR_SIGNAL_EVENT,\n  type DatastarSignalEvent,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { tagHas, tagToMs } from '../../../../utils/tags'\nimport { camel, modifyCasing } from '../../../../utils/text'\nimport { debounce, delay, throttle } from '../../../../utils/timing'\nimport { supportsViewTransitions } from '../../../../utils/view-transtions'\nimport type { Signal } from '../../../../vendored/preact-core'\n\nconst EVT = 'evt'\nconst SIGNALS_CHANGE_PREFIX = 'signalsChange'\nconst signalChangeKeyLength = SIGNALS_CHANGE_PREFIX.length\n\nexport const On: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'on',\n  keyReq: Requirement.Must,\n  valReq: Requirement.Must,\n  argNames: [EVT],\n  removeOnLoad: (rawKey: string) => rawKey.startsWith('onLoad'),\n  onLoad: ({ el, key, mods, rawKey, signals, value, effect, genRX }) => {\n    const rx = genRX()\n    let target: Element | Window | Document = el\n    if (mods.has('window')) target = window\n\n    let callback = (evt?: Event) => {\n      if (evt) {\n        // Always prevent default on submit events (because forms)\n        if (mods.has('prevent') || key === 'submit') evt.preventDefault()\n        if (mods.has('stop')) evt.stopPropagation()\n      }\n      rx(evt)\n    }\n\n    const delayArgs = mods.get('delay')\n    if (delayArgs) {\n      const wait = tagToMs(delayArgs)\n      callback = delay(callback, wait)\n    }\n\n    const debounceArgs = mods.get('debounce')\n    if (debounceArgs) {\n      const wait = tagToMs(debounceArgs)\n      const leading = tagHas(debounceArgs, 'leading', false)\n      const trailing = !tagHas(debounceArgs, 'notrail', false)\n      callback = debounce(callback, wait, leading, trailing)\n    }\n\n    const throttleArgs = mods.get('throttle')\n    if (throttleArgs) {\n      const wait = tagToMs(throttleArgs)\n      const leading = !tagHas(throttleArgs, 'noleading', false)\n      const trailing = tagHas(throttleArgs, 'trail', false)\n      callback = throttle(callback, wait, leading, trailing)\n    }\n\n    if (supportsViewTransitions && mods.has('viewtransition')) {\n      const cb = callback // I hate javascript\n      callback = (...args: any[]) =>\n        document.startViewTransition(() => cb(...args))\n    }\n\n    const evtListOpts: AddEventListenerOptions = {\n      capture: true,\n      passive: false,\n      once: false,\n    }\n    if (!mods.has('capture')) evtListOpts.capture = false\n    if (mods.has('passive')) evtListOpts.passive = true\n    if (mods.has('once')) evtListOpts.once = true\n\n    if (key === 'load') {\n      callback()\n      return () => {}\n    }\n\n    if (key === 'interval') {\n      let duration = 1000\n      const durationArgs = mods.get('duration')\n      if (durationArgs) {\n        duration = tagToMs(durationArgs)\n        const leading = tagHas(durationArgs, 'leading', false)\n        if (leading) {\n          // Remove `.leading` from the dataset so the callback is only ever called on page load\n          el.dataset[rawKey.replace('.leading', '')] = value\n          delete el.dataset[rawKey]\n          callback()\n        }\n      }\n      const intervalId = setInterval(callback, duration)\n\n      return () => {\n        clearInterval(intervalId)\n      }\n    }\n\n    if (key === 'raf') {\n      let rafId: number | undefined\n      const raf = () => {\n        callback()\n        rafId = requestAnimationFrame(raf)\n      }\n      rafId = requestAnimationFrame(raf)\n\n      return () => {\n        if (rafId) cancelAnimationFrame(rafId)\n      }\n    }\n\n    if (key.startsWith(SIGNALS_CHANGE_PREFIX)) {\n      if (key === SIGNALS_CHANGE_PREFIX) {\n        callback()\n        const signalFn = (event: CustomEvent<DatastarSignalEvent>) =>\n          callback(event)\n        document.addEventListener(DATASTAR_SIGNAL_EVENT, signalFn)\n        return () => {\n          document.removeEventListener(DATASTAR_SIGNAL_EVENT, signalFn)\n        }\n      }\n\n      const signalPath = modifyCasing(\n        camel(key.slice(signalChangeKeyLength)),\n        mods,\n      )\n      const signalValues = new Map<Signal, any>()\n      signals.walk((path, signal) => {\n        if (path.startsWith(signalPath)) {\n          signalValues.set(signal, signal.value)\n        }\n      })\n      return effect(() => {\n        for (const [signal, prev] of signalValues) {\n          if (prev !== signal.value) {\n            callback()\n            signalValues.set(signal, signal.value)\n          }\n        }\n      })\n    }\n\n    const testOutside = mods.has('outside')\n    if (testOutside) {\n      target = document\n      const cb = callback\n      const targetOutsideCallback = (e?: Event) => {\n        const targetHTML = e?.target as HTMLElement\n        if (!el.contains(targetHTML)) {\n          cb(e)\n        }\n      }\n      callback = targetOutsideCallback\n    }\n\n    const eventName = modifyCasing(key, mods)\n    target.addEventListener(eventName, callback, evtListOpts)\n    return () => {\n      target.removeEventListener(eventName, callback)\n    }\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: mdi:cursor-pointer\n// Slug: Create a reference to an element\n// Description: This attribute creates a reference to an element that can be used in other expressions.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { modifyCasing, trimDollarSignPrefix } from '../../../../utils/text'\n\n// Sets the value of the element\nexport const Ref: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'ref',\n  keyReq: Requirement.Exclusive,\n  valReq: Requirement.Exclusive,\n  onLoad: ({ el, key, mods, signals, value }) => {\n    const signalName = key ? modifyCasing(key, mods) : trimDollarSignPrefix(value)\n    signals.setValue(signalName, el)\n    return () => signals.setValue(signalName, null)\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: tabler:typography\n// Slug: Set the text content of an element\n// Description: This attribute sets the text content of an element to the result of the expression.\n\nimport { runtimeErr } from '../../../../engine/errors'\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nexport const Text: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'text',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Must,\n  onLoad: (ctx) => {\n    const { el, effect, genRX } = ctx\n    const rx = genRX()\n    if (!(el instanceof HTMLElement)) {\n      runtimeErr('TextInvalidElement', ctx)\n    }\n    return effect(() => {\n      const res = rx(ctx)\n      el.textContent = `${res}`\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:fit-screen-outline\n// Slug: Clamp a value to a new range\n// Description: This action clamps a value to a new range. The value is first scaled to the new range, then clamped to the new range. This is useful for scaling a value to a new range, then clamping it to that range.\n\nimport {\n  type ActionPlugin,\n  PluginType,\n  type RuntimeContext,\n} from '../../../../engine/types'\n\nconst { round, max, min } = Math\nexport const Fit: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'fit',\n  fn: (\n    _: RuntimeContext,\n    v: number,\n    oldMin: number,\n    oldMax: number,\n    newMin: number,\n    newMax: number,\n    shouldClamp = false,\n    shouldRound = false,\n  ) => {\n    let fitted = ((v - oldMin) / (oldMax - oldMin)) * (newMax - newMin) + newMin\n    if (shouldRound) {\n      fitted = round(fitted)\n    }\n    if (shouldClamp) {\n      fitted = max(newMin, min(newMax, fitted))\n    }\n    return fitted\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: ion:checkmark-round\n// Slug: Set all signals that match a regular expression\n\nimport { type ActionPlugin, PluginType } from '../../../../engine/types'\n\nexport const SetAll: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'setAll',\n  fn: ({ signals }, prefix: string, newValue) => {\n    signals.walk((path, signal) => {\n      if (!path.startsWith(prefix)) return\n      signal.value = newValue\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:toggle-off\n// Slug: Toggle all signals that match a regular expression\n\nimport { type ActionPlugin, PluginType } from '../../../../engine/types'\n\nexport const ToggleAll: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'toggleAll',\n  fn: ({ signals }, prefix: string) => {\n    signals.walk((path, signal) => {\n      if (!path.startsWith(prefix)) return\n      signal.value = !signal.value\n    })\n  },\n}\n", "import { Datastar as DS } from '../engine'\nimport { DELETE } from '../plugins/official/backend/actions/delete'\nimport { GET } from '../plugins/official/backend/actions/get'\nimport { PATCH } from '../plugins/official/backend/actions/patch'\nimport { POST } from '../plugins/official/backend/actions/post'\nimport { PUT } from '../plugins/official/backend/actions/put'\nimport { Indicator } from '../plugins/official/backend/attributes/indicator'\nimport { ExecuteScript } from '../plugins/official/backend/watchers/executeScript'\nimport { MergeFragments } from '../plugins/official/backend/watchers/mergeFragments'\nimport { MergeSignals } from '../plugins/official/backend/watchers/mergeSignals'\nimport { RemoveFragments } from '../plugins/official/backend/watchers/removeFragments'\nimport { RemoveSignals } from '../plugins/official/backend/watchers/removeSignals'\nimport { Clipboard } from '../plugins/official/browser/actions/clipboard'\nimport { CustomValidity } from '../plugins/official/browser/attributes/customValidity'\nimport { Intersects } from '../plugins/official/browser/attributes/intersects'\nimport { Persist } from '../plugins/official/browser/attributes/persist'\nimport { ReplaceUrl } from '../plugins/official/browser/attributes/replaceUrl'\nimport { ScrollIntoView } from '../plugins/official/browser/attributes/scrollIntoView'\nimport { Show } from '../plugins/official/browser/attributes/show'\nimport { ViewTransition } from '../plugins/official/browser/attributes/viewTransition'\nimport { Attr } from '../plugins/official/dom/attributes/attr'\nimport { Bind } from '../plugins/official/dom/attributes/bind'\nimport { Class } from '../plugins/official/dom/attributes/class'\nimport { On } from '../plugins/official/dom/attributes/on'\nimport { Ref } from '../plugins/official/dom/attributes/ref'\nimport { Text } from '../plugins/official/dom/attributes/text'\nimport { Fit } from '../plugins/official/logic/actions/fit'\nimport { SetAll } from '../plugins/official/logic/actions/setAll'\nimport { ToggleAll } from '../plugins/official/logic/actions/toggleAll'\n\nDS.load(\n  // DOM\n  Attr,\n  Bind,\n  Class,\n  On,\n  Ref,\n  Show,\n  Text,\n  // Backend\n  Indicator,\n  GET,\n  POST,\n  PUT,\n  PATCH,\n  DELETE,\n  MergeFragments,\n  MergeSignals,\n  RemoveFragments,\n  RemoveSignals,\n  ExecuteScript,\n  // Browser\n  Clipboard,\n  CustomValidity,\n  Intersects,\n  Persist,\n  ReplaceUrl,\n  ScrollIntoView,\n  ViewTransition,\n  // Logic\n  Fit,\n  SetAll,\n  ToggleAll,\n)\nDS.aliasPrefix = 'ds'\nexport const Datastar = DS\n"],
  "mappings": "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",
  "names": ["lol", "DSP", "DSS", "DATASTAR", "DATASTAR_REQUEST", "DefaultFragmentsSettleDurationMs", "DefaultSseRetryDurationMs", "DefaultExecuteScriptAttributes", "DefaultFragmentsUseViewTransitions", "DefaultMergeSignalsOnlyIfMissing", "DefaultExecuteScriptAutoRemove", "FragmentMergeModes", "DefaultFragmentMergeMode", "EventTypes", "PluginType", "DATASTAR_SIGNAL_EVENT", "DATASTAR", "isBoolString", "str", "kebab", "$", "ofs", "camel", "x", "snake", "pascal", "jsStrToObject", "raw", "trimDollarSignPrefix", "caseFns", "modifyCasing", "mods", "c", "fn", "name", "Computed", "key", "mods", "signals", "genRX", "modifyCasing", "rx", "Signals", "ctx", "key", "mods", "signals", "value", "genRX", "ifMissing", "k", "modifyCasing", "v", "obj", "jsStrToObject", "nv", "Star", "Hash", "#value", "#prefix", "prefix", "DATASTAR", "x", "c", "elUniqId", "el", "hash", "currentEl", "i", "e", "delay", "callback", "wait", "args", "debounce", "leading", "trailing", "timer", "resetTimer", "throttle", "waiting", "url", "dserr", "type", "reason", "metadata", "e", "DATASTAR", "r", "snake", "q", "internalErr", "from", "args", "initErr", "ctx", "errCtx", "PluginType", "runtimeErr", "from", "BRAND_SYMBOL", "RUNNING", "NOTIFIED", "OUTDATED", "DISPOSED", "HAS_ERROR", "TRACKING", "startBatch", "batchDepth", "endBatch", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "needsToRecompute", "err", "internalErr", "evalContext", "batchedEffect", "batchDepth", "batchIteration", "globalVersion", "addDependency", "signal", "evalContext", "node", "TRACKING", "Signal", "value", "BRAND_SYMBOL", "prev", "next", "fn", "effect", "prevContext", "internalErr", "from", "startBatch", "endBatch", "needsToRecompute", "target", "node", "prepareSources", "rollbackNode", "cleanupSources", "head", "prev", "Computed", "fn", "Signal", "globalVersion", "OUTDATED", "NOTIFIED", "RUNNING", "TRACKING", "prevContext", "evalContext", "value", "HAS_ERROR", "err", "internalErr", "from", "addDependency", "computed", "cleanupEffect", "effect", "cleanup", "startBatch", "error", "DISPOSED", "disposeEffect", "endBatch", "endEffect", "Effect", "finish", "batchedEffect", "from", "dispatchSignalEvent", "evt", "DATASTAR_SIGNAL_EVENT", "nestedValues", "signal", "onlyPublic", "kv", "key", "value", "Signal", "mergeNested", "target", "values", "onlyIfMissing", "internalErr", "subEvt", "k", "t", "oldValue", "walkNestedSignal", "cb", "path", "nestedSubset", "original", "keys", "subset", "parts", "subOriginal", "subSubset", "i", "part", "last", "SignalsRoot", "#signals", "dotDelimitedPath", "parts", "subSignals", "i", "part", "last", "signal", "internalErr", "from", "fn", "computed", "value", "s", "oldValue", "dispatchSignalEvent", "defaultValue", "current", "Signal", "dotDelimitedPaths", "removed", "path", "other", "onlyIfMissing", "evt", "mergeNested", "keys", "nestedSubset", "cb", "walkNestedSignal", "signalNames", "onlyPublic", "nestedValues", "shouldIndent", "values", "removalKey", "k", "v", "DSP", "Engine", "#signals", "SignalsRoot", "#plugins", "#actions", "#watchers", "#mutationObserver", "#removals", "#delayedApply", "delay", "#apply", "#observe", "pluginsToLoad", "that", "plugin", "ctx", "cb", "effect", "#applyAttributePlugin", "globalInitializer", "wp", "ap", "initErr", "a", "b", "lenDiff", "rootElement", "#walkDownDOM", "el", "elRemovals", "removalFn", "datasetKey", "mutations", "target", "type", "attributeName", "oldValue", "addedNodes", "removedNodes", "node", "datasetPrefix", "requiredPrefix", "camel", "rk", "camelCasedKey", "rawKey", "p", "elAttr", "elUniqId", "key", "rawModifiers", "hasKey", "value", "hasValue", "#genRX", "keyReq", "runtimeErr", "valReq", "rawMod", "label", "mod", "t", "removeOnLoad", "argNames", "userExpression", "statementRe", "statements", "lastIdx", "last", "escaped", "escapeRe", "DSS", "match", "Hash", "fnCall", "matches", "methodsCalled", "actionsRe", "signalNames", "signalsRe", "fnContent", "fn", "args", "error", "element", "callback", "dataset", "DS", "Engine", "Star", "Signals", "Computed", "Datastar", "getBytes", "stream", "onChunk", "reader", "result", "getLines", "onLine", "buffer", "position", "fieldLength", "discardTrailingNewline", "arr", "concat", "bufLength", "lineStart", "lineEnd", "getMessages", "onId", "onRetry", "onMessage", "message", "newMessage", "decoder", "line", "field", "valueOffset", "value", "retry", "a", "b", "res", "EventStreamContentType", "LastEventId", "fetchEventSource", "ctx", "input", "inputSignal", "inputHeaders", "inputOnOpen", "onmessage", "onclose", "onerror", "openWhenHidden", "inputFetch", "retryInterval", "retryScaler", "retryMaxWaitMs", "retryMaxCount", "rest", "resolve", "reject", "retries", "headers", "curRequestController", "onVisibilityChange", "create", "retryTimer", "dispose", "fetch", "onopen", "response", "getBytes", "id", "err", "interval", "runtimeErr", "innerErr", "DATASTAR_SSE_EVENT", "DATASTAR", "SETTLING_CLASS", "SWAPPING_CLASS", "STARTED", "FINISHED", "ERROR", "RETRYING", "datastarSSEEventWatcher", "eventType", "fn", "event", "argsRaw", "dispatchSSE", "type", "argsRaw", "DATASTAR_SSE_EVENT", "isWrongContent", "err", "sse", "ctx", "method", "url", "args", "elId", "el", "signals", "userHeaders", "contentType", "includeLocal", "selector", "openWhenHidden", "retryInterval", "retryScaler", "retryMaxWaitMs", "retryMaxCount", "abort", "DefaultSseRetryDurationMs", "action", "cleanupFn", "STARTED", "runtimeErr", "initialHeaders", "DATASTAR_REQUEST", "headers", "req", "response", "status", "ERROR", "evt", "DATASTAR", "argsRawLines", "lines", "line", "colonIndex", "key", "argLines", "value", "error", "RETRYING", "urlInstance", "queryParams", "json", "formEl", "preventDefault", "formData", "formParams", "fetchEventSource", "FINISHED", "DELETE", "ctx", "url", "args", "sse", "GET", "ctx", "url", "args", "sse", "PATCH", "ctx", "url", "args", "sse", "POST", "ctx", "url", "args", "sse", "PUT", "ctx", "url", "args", "sse", "Indicator", "el", "key", "mods", "signals", "value", "signalName", "modifyCasing", "trimDollarSignPrefix", "signal", "watcher", "event", "type", "elId", "STARTED", "FINISHED", "DATASTAR_SSE_EVENT", "ExecuteScript", "EventTypes", "ctx", "datastarSSEEventWatcher", "autoRemoveRaw", "DefaultExecuteScriptAutoRemove", "attributesRaw", "DefaultExecuteScriptAttributes", "script", "autoRemove", "isBoolString", "initErr", "scriptEl", "attr", "pivot", "key", "value", "docWithViewTransitionAPI", "supportsViewTransitions", "Idiomorph", "EMPTY_SET", "defaults", "noOp", "elt", "morph", "oldNode", "newContent", "config", "parseContent", "normalizedContent", "normalizeContent", "ctx", "createMorphContext", "morphNormalizedContent", "normalizedNewContent", "oldHead", "newHead", "promises", "handleHeadElement", "morphChildren", "restoreFromPantry", "bestMatch", "findBestNodeMatch", "previousSibling", "nextSibling", "morphedNode", "morphOldNodeTo", "elements", "insertSiblings", "ignoreValueOfActiveElement", "possibleActiveElement", "isSoftMatch", "syncNodeFrom", "newParent", "oldParent", "nextNewChild", "insertionPoint", "newChild", "removeIdsFromConsideration", "isIdSetMatch", "idSetMatch", "findIdSetMatch", "removeNodesBetween", "softMatch", "findSoftMatch", "tempNode", "removeNode", "ignoreAttribute", "attr", "to", "updateType", "from", "type", "fromEl", "toEl", "fromAttributes", "toAttributes", "fromAttribute", "i", "toAttribute", "syncInputValue", "syncBooleanAttribute", "attributeName", "fromLiveValue", "toLiveValue", "ignoreUpdate", "fromValue", "toValue", "newHeadTag", "currentHead", "added", "removed", "preserved", "nodesToAppend", "headMergeStyle", "srcToNewHeadNodes", "newHeadChild", "currentHeadElt", "inNewContent", "isReAppended", "isPreserved", "log", "newNode", "newElt", "resolve", "promise", "_resolve", "removedElement", "_args", "mergeDefaults", "finalConfig", "mergedConfig", "createIdMap", "createPersistentIds", "createPantry", "pantry", "node1", "node2", "getIdIntersectionCount", "startInclusive", "endExclusive", "cursor", "newChildPotentialIdCount", "potentialMatch", "otherMatchCount", "potentialSoftMatch", "siblingSoftMatchCount", "generatedByIdiomorph", "parser", "contentWithSvgsRemoved", "content", "htmlElement", "dummyParent", "stack", "node", "currentElement", "bestElement", "score", "newScore", "scoreElement", "hasPersistentIdNodes", "moveToPantry", "child", "root", "element", "matchElement", "isIdInConsideration", "id", "idIsWithinNode", "targetNode", "idSet", "sourceSet", "matchCount", "nodesWithIds", "nodes", "populateIdMapForNode", "idMap", "nodeParent", "current", "oldContent", "toIdTagName", "oldIdSet", "matchIdSet", "MergeFragments", "EventTypes", "ctx", "fragmentContainer", "datastarSSEEventWatcher", "fragmentsRaw", "selector", "mergeMode", "DefaultFragmentMergeMode", "settleDurationRaw", "DefaultFragmentsSettleDurationMs", "useViewTransitionRaw", "DefaultFragmentsUseViewTransitions", "settleDuration", "useViewTransition", "isBoolString", "fragments", "fragment", "initErr", "selectorOrID", "targets", "supportsViewTransitions", "docWithViewTransitionAPI", "applyToTargets", "capturedTargets", "initialTarget", "SWAPPING_CLASS", "originalHTML", "modifiedTarget", "FragmentMergeModes", "toApply", "result", "Idiomorph", "argument", "el", "mode", "elAddAttrs", "name", "camel", "attrs", "attr", "attrName", "value", "cl", "revisedHTML", "SETTLING_CLASS", "MergeSignals", "EventTypes", "ctx", "datastarSSEEventWatcher", "raw", "onlyIfMissingRaw", "DefaultMergeSignalsOnlyIfMissing", "signals", "onlyIfMissing", "isBoolString", "jsStrToObject", "RemoveFragments", "EventTypes", "ctx", "datastarSSEEventWatcher", "selector", "settleDurationRaw", "DefaultFragmentsSettleDurationMs", "useViewTransitionRaw", "DefaultFragmentsUseViewTransitions", "initErr", "settleDuration", "useViewTransition", "isBoolString", "removeTargets", "applyToTargets", "target", "SWAPPING_CLASS", "supportsViewTransitions", "docWithViewTransitionAPI", "RemoveSignals", "EventTypes", "ctx", "datastarSSEEventWatcher", "pathsRaw", "paths", "p", "initErr", "Clipboard", "ctx", "text", "runtimeErr", "CustomValidity", "ctx", "el", "genRX", "effect", "runtimeErr", "rx", "result", "ONCE", "HALF", "FULL", "Intersects", "el", "rawKey", "mods", "genRX", "options", "rx", "observer", "entries", "entry", "SESSION", "Persist", "key", "effect", "mods", "signals", "value", "modifyCasing", "DATASTAR", "storage", "paths", "p", "trimDollarSignPrefix", "storageToSignals", "data", "nestedValues", "signalsToStorage", "nv", "ReplaceUrl", "effect", "genRX", "rx", "url", "baseUrl", "fullUrl", "SMOOTH", "INSTANT", "AUTO", "HSTART", "HCENTER", "HEND", "HNEAREST", "VSTART", "VCENTER", "VEND", "VNEAREST", "FOCUS", "CENTER", "START", "END", "NEAREST", "ScrollIntoView", "ctx", "el", "mods", "rawKey", "opts", "runtimeErr", "NONE", "DISPLAY", "Show", "s", "genRX", "effect", "rx", "VIEW_TRANSITION", "ViewTransition", "hasViewTransitionMeta", "node", "meta", "effect", "el", "genRX", "supportsViewTransitions", "rx", "name", "elVTASTyle", "Attr", "el", "key", "effect", "genRX", "rx", "binds", "attr", "val", "kebab", "value", "v", "dataURIRegex", "updateEvents", "Bind", "ctx", "el", "key", "mods", "signals", "value", "effect", "signalName", "modifyCasing", "trimDollarSignPrefix", "setFromSignal", "el2sig", "tnl", "signalDefault", "isInput", "type", "isCheckbox", "isSelect", "isRadio", "isFile", "hasValue", "v", "vStr", "input", "select", "opt", "files", "allContents", "allMimes", "allNames", "f", "resolve", "reader", "runtimeErr", "match", "current", "selectedValues", "event", "elSigClean", "onPageshow", "ev", "Class", "el", "key", "mods", "effect", "genRX", "cl", "rx", "classes", "k", "v", "classNames", "modifyCasing", "tagToMs", "args", "arg", "tagHas", "tags", "tag", "defaultValue", "EVT", "SIGNALS_CHANGE_PREFIX", "signalChangeKeyLength", "On", "rawKey", "el", "key", "mods", "signals", "value", "effect", "genRX", "rx", "target", "callback", "evt", "delayArgs", "wait", "tagToMs", "delay", "debounceArgs", "leading", "tagHas", "trailing", "debounce", "throttleArgs", "throttle", "supportsViewTransitions", "cb", "args", "evtListOpts", "duration", "durationArgs", "intervalId", "rafId", "raf", "signalFn", "event", "DATASTAR_SIGNAL_EVENT", "signalPath", "modifyCasing", "camel", "signalValues", "path", "signal", "prev", "e", "targetHTML", "eventName", "Ref", "el", "key", "mods", "signals", "value", "signalName", "modifyCasing", "trimDollarSignPrefix", "Text", "ctx", "el", "effect", "genRX", "rx", "runtimeErr", "res", "round", "max", "min", "Fit", "_", "v", "oldMin", "oldMax", "newMin", "newMax", "shouldClamp", "shouldRound", "fitted", "SetAll", "signals", "prefix", "newValue", "path", "signal", "ToggleAll", "signals", "prefix", "path", "signal", "Datastar", "Attr", "Bind", "Class", "On", "Ref", "Show", "Text", "Indicator", "GET", "POST", "PUT", "PATCH", "DELETE", "MergeFragments", "MergeSignals", "RemoveFragments", "RemoveSignals", "ExecuteScript", "Clipboard", "CustomValidity", "Intersects", "Persist", "ReplaceUrl", "ScrollIntoView", "ViewTransition", "Fit", "SetAll", "ToggleAll"]
}
