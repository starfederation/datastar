{
  "version": 3,
  "sources": ["../library/src/engine/consts.ts", "../library/src/utils/paths.ts", "../library/src/utils/dom.ts", "../library/src/utils/text.ts", "../library/src/plugins/core/attributes/computed.ts", "../library/src/plugins/core/attributes/effect.ts", "../library/src/plugins/core/attributes/signals.ts", "../library/src/engine/errors.ts", "../library/src/engine/types.ts", "../library/src/engine/engine.ts", "../library/src/engine/index.ts", "../library/src/plugins/framework/actions/peek.ts", "../library/src/plugins/framework/actions/setAll.ts", "../library/src/plugins/framework/actions/toggleAll.ts", "../library/src/plugins/framework/attributes/attr.ts", "../library/src/plugins/framework/attributes/bind.ts", "../library/src/plugins/framework/attributes/class.ts", "../library/src/plugins/framework/backend/shared.ts", "../library/src/plugins/framework/attributes/indicator.ts", "../library/src/plugins/framework/attributes/jsonSignals.ts", "../library/src/utils/tags.ts", "../library/src/utils/timing.ts", "../library/src/utils/view-transitions.ts", "../library/src/plugins/framework/attributes/on.ts", "../library/src/plugins/framework/attributes/onIntersect.ts", "../library/src/plugins/framework/attributes/onInterval.ts", "../library/src/plugins/framework/attributes/onLoad.ts", "../library/src/plugins/framework/attributes/ref.ts", "../library/src/plugins/framework/attributes/scope.ts", "../library/src/plugins/framework/attributes/show.ts", "../library/src/plugins/framework/attributes/text.ts", "../library/src/plugins/framework/backend/actions/fetch.ts", "../library/src/plugins/framework/backend/actions/httpMethods.ts", "../library/src/plugins/framework/backend/actions/delete.ts", "../library/src/plugins/framework/backend/actions/get.ts", "../library/src/plugins/framework/backend/actions/patch.ts", "../library/src/plugins/framework/backend/actions/post.ts", "../library/src/plugins/framework/backend/actions/put.ts", "../library/src/plugins/framework/backend/watchers/patchElements.ts", "../library/src/plugins/framework/backend/watchers/patchSignals.ts", "../library/src/bundles/datastar-aliased.ts"],
  "sourcesContent": ["// This is auto-generated by Datastar. DO NOT EDIT.\nconst lol = /\uD83D\uDD95JS_DS\uD83D\uDE80/.source\nexport const DSP = lol.slice(0, 5)\nexport const DSS = lol.slice(4)\n\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_REQUEST = \"Datastar-Request\";\n\n// #region Defaults\n\n// #region Default durations\n\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000;\n\n// #endregion\n\n\n// #region Default strings\n\n\n// #endregion\n\n\n// #region Default booleans\n\n// Should elements be patched using the ViewTransition API?\nexport const DefaultElementsUseViewTransitions = false;\n\n// Should a given set of signals patch if they are missing?\nexport const DefaultPatchSignalsOnlyIfMissing = false;\n\n// #endregion\n\n\n// #region Enums\n\n// The mode in which a element is patched into the DOM.\n// Morphs the element into the existing element.\nexport const ElementPatchModeOuter = \"outer\"\n// Replaces the inner HTML of the existing element.\nexport const ElementPatchModeInner = \"inner\"\n// Removes the existing element.\nexport const ElementPatchModeRemove = \"remove\"\n// Replaces the existing element with the new element.\nexport const ElementPatchModeReplace = \"replace\"\n// Prepends the element inside to the existing element.\nexport const ElementPatchModePrepend = \"prepend\"\n// Appends the element inside the existing element.\nexport const ElementPatchModeAppend = \"append\"\n// Inserts the element before the existing element.\nexport const ElementPatchModeBefore = \"before\"\n// Inserts the element after the existing element.\nexport const ElementPatchModeAfter = \"after\"\n\n// Default value for ElementPatchMode\nexport const DefaultElementPatchMode = ElementPatchModeOuter;\n\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\n// An event for patching HTML elements into the DOM.\nexport const EventTypePatchElements = \"datastar-patch-elements\"\n// An event for patching signals.\nexport const EventTypePatchSignals = \"datastar-patch-signals\"\n// #endregion\n\n// #endregion", "export const isPojo = (obj: any): obj is Record<string, any> =>\n  obj !== null &&\n  typeof obj === 'object' &&\n  (Object.getPrototypeOf(obj) === Object.prototype ||\n    Object.getPrototypeOf(obj) === null)\n\nexport function isEmpty(obj: Record<string, any>): boolean {\n  for (const prop in obj) {\n    if (Object.hasOwn(obj, prop)) {\n      return false\n    }\n  }\n  return true\n}\n\nexport function updateLeaves(\n  obj: Record<string, any>,\n  fn: (oldValue: any) => any,\n) {\n  for (const key in obj) {\n    const val = obj[key]\n    if (isPojo(val) || Array.isArray(val)) {\n      updateLeaves(val, fn)\n    } else {\n      obj[key] = fn(val)\n    }\n  }\n}\n\nexport const pathToObj = (\n  target: Record<string, any>,\n  paths: Record<string, any>,\n): Record<string, any> => {\n  for (const path in paths) {\n    const keys = path.split('.')\n    const lastKey = keys.pop()!\n    const obj = keys.reduce((acc, key) => (acc[key] ??= {}), target)\n    obj[lastKey] = paths[path]\n  }\n  return target\n}\n", "import type { HTMLOrSVG } from '../engine/types'\n\nexport function isHTMLOrSVG(el: Node): el is HTMLOrSVG {\n  return el instanceof HTMLElement || el instanceof SVGElement\n}\n\nexport function findClosestScoped(el: HTMLOrSVG | null): string | null {\n  return (\n    (el?.closest('[data-scope]') as HTMLOrSVG | null)?.dataset.scope ?? null\n  )\n}\n", "import type { HTMLOrSVG, Modifiers } from '../engine/types'\nimport { findClosestScoped } from './dom'\n\nexport const isBoolString = (str: string) => str.trim() === 'true'\n\nexport const kebab = (str: string) =>\n  str\n    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')\n    .replace(/([a-z])([0-9]+)/gi, '$1-$2')\n    .replace(/([0-9]+)([a-z])/gi, '$1-$2')\n    .toLowerCase()\n\nexport const camel = (str: string) =>\n  kebab(str).replace(/-./g, (x) => x[1].toUpperCase())\n\nexport const snake = (str: string) => kebab(str).replace(/-/g, '_')\n\nexport const pascal = (str: string) =>\n  camel(str).replace(/(^.|(?<=\\.).)/g, (x) => x[0].toUpperCase())\n\nexport const jsStrToObject = (raw: string) => {\n  try {\n    return JSON.parse(raw)\n  } catch {\n    // If JSON parsing fails, try to evaluate as a JavaScript object\n    // This is less safe and should be used with caution\n    return Function(`return (${raw})`)()\n  }\n}\n\nconst caseFns: Record<string, (s: string) => string> = { kebab, snake, pascal }\n\nexport function modifyCasing(str: string, mods: Modifiers) {\n  for (const c of mods.get('case') || []) {\n    const fn = caseFns[c]\n    if (fn) str = fn(str)\n  }\n  return str\n}\n\nexport function modifyScope(\n  signalName: string,\n  el: HTMLOrSVG,\n  mods: Modifiers,\n) {\n  if (mods.has('scoped')) {\n    const scope = findClosestScoped(el)\n    if (scope) {\n      signalName = `${scope}.${signalName}`\n    }\n  }\n  return signalName\n}\n", "import type { AttributePlugin } from '../../../engine/types'\nimport { pathToObj } from '../../../utils/paths'\nimport { modifyCasing, modifyScope } from '../../../utils/text'\n\nexport const Computed: AttributePlugin = {\n  type: 'attribute',\n  name: 'computed',\n  keyReq: 'must',\n  valReq: 'must',\n  isExpr: true,\n  onLoad: ({ el, key, mods, rx, computed, mergePatch }) => {\n    let signalName = modifyCasing(key, mods)\n    signalName = modifyScope(signalName, el, mods)\n    mergePatch(pathToObj({}, { [signalName]: computed(rx) }))\n  },\n}\n", "import type { AttributePlugin } from '../../../engine/types'\n\nexport const Effect: AttributePlugin = {\n  type: 'attribute',\n  name: 'effect',\n  keyReq: 'denied',\n  valReq: 'must',\n  onLoad: ({ effect, rx }) => effect(rx),\n}\n", "import type { AttributePlugin } from '../../../engine/types'\nimport { pathToObj } from '../../../utils/paths'\nimport { modifyCasing, modifyScope } from '../../../utils/text'\n\nexport const Signals: AttributePlugin = {\n  type: 'attribute',\n  name: 'signals',\n  isExpr: true,\n  onLoad: ({ el, key, mods, rx, mergePatch }) => {\n    const ifMissing = mods.has('ifmissing')\n\n    if (key) {\n      key = modifyScope(modifyCasing(key, mods), el, mods)\n      mergePatch(pathToObj({}, { [key]: rx() }), { ifMissing })\n    } else {\n      const patch = rx<Record<string, any>>()\n      const pathObj: Record<string, any> = {}\n      for (const key in patch) {\n        pathObj[modifyScope(key, el, mods)] = patch[key]\n      }\n      mergePatch(pathToObj({}, pathObj), { ifMissing })\n    }\n  },\n}\n", "import { snake } from '../utils/text'\nimport { DATASTAR } from './consts'\nimport type { InitContext, RuntimeContext } from './types'\n\nconst url = 'https://data-star.dev/errors'\n\ninterface Metadata {\n  error?: string\n  [key: string]: any\n}\n\nfunction dserr(type: string, reason: string, metadata: Metadata = {}) {\n  const e = new Error()\n  e.name = `${DATASTAR} ${type} error`\n  const r = snake(reason)\n  const q = new URLSearchParams({\n    metadata: JSON.stringify(metadata),\n  }).toString()\n  const c = JSON.stringify(metadata, null, 2)\n  e.message = `${reason}\\nMore info: ${url}/${type}/${r}?${q}\\nContext: ${c}`\n  return e\n}\n\nexport function internalErr(from: string, reason: string, args = {}) {\n  return dserr('internal', reason, Object.assign({ from }, args))\n}\n\nexport function initErr(reason: string, ctx: InitContext, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: ctx.plugin.type,\n    },\n  }\n  return dserr('init', reason, Object.assign(errCtx, metadata))\n}\n\nexport function runtimeErr(ctx: RuntimeContext, reason: string, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: ctx.plugin.type,\n    },\n    element: {\n      id: ctx.el.id,\n      tag: ctx.el.tagName,\n    },\n    expression: {\n      rawKey: ctx.rawKey,\n      key: ctx.key,\n      value: ctx.value,\n      // validSignals:\n      fnContent: ctx.fnContent,\n    },\n  }\n  return dserr('runtime', reason, Object.assign(errCtx, metadata))\n}\n", "import { DATASTAR } from './consts'\nexport type PluginType = 'attribute' | 'watcher' | 'action'\nexport type Requirement = 'allowed' | 'must' | 'denied' | 'exclusive'\n\n// export type ReactiveNode = Signal | Computed | Effect\n// export type Subscriber = Computed | Effect\nexport type OnRemovalFn = () => void\n\nexport type DatastarPlugin = AttributePlugin | WatcherPlugin | ActionPlugin\n\nexport const DATASTAR_SIGNAL_PATCH_EVENT = `${DATASTAR}-signal-patch`\nexport type JSONPatch = Record<string, any>\n\nexport interface CustomEventMap {\n  [DATASTAR_SIGNAL_PATCH_EVENT]: CustomEvent<JSONPatch>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\ndeclare global {\n  interface Document {\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n  }\n}\n\n// A plugin accessible via a `data-${name}` attribute on an element\nexport type AttributePlugin = {\n  type: 'attribute'\n  name: string // The name of the plugin\n  onGlobalInit?: (ctx: InitContext) => void // Called once on registration of the plugin\n  onLoad: (ctx: RuntimeContext) => OnRemovalFn | void // Return a function to be called on removal\n  keyReq?: Requirement // The rules for the key requirements\n  valReq?: Requirement // The rules for the value requirements\n  isExpr?: boolean // If the value is an expression\n  argNames?: string[] // argument names for the reactive expression\n}\n\n// A plugin that runs on the global scope of the Datastar instance\nexport type WatcherPlugin = {\n  type: 'watcher'\n  name: string // The name of the plugin\n  onGlobalInit?: (ctx: InitContext) => void\n}\n\nexport type ActionPlugins = Record<string, ActionPlugin>\nexport type ActionMethod = (ctx: RuntimeContext, ...args: any[]) => any\n\nexport type ActionPlugin = {\n  type: 'action'\n  name: string // The name of the plugin\n  fn: ActionMethod\n}\n\nexport type GlobalInitializer = (ctx: InitContext) => void\n\nexport type InitContext = {\n  plugin: DatastarPlugin // The plugin instance\n  actions: Readonly<ActionPlugins> // All registered actions\n  root: Record<string, any> // global signals and computed signals\n  filtered: (opts?: SignalFilterOptions, obj?: JSONPatch) => Record<string, any>\n  signal<T>(initialValue?: T | undefined): Signal<T> // creates a signal\n  computed<T>(getter: (previousValue?: T) => T): Computed<T> // creates a computed signal\n  effect(fn: (...args: any[]) => void): OnRemovalFn // creates an effect\n  mergePatch: (patch: any, args?: { ifMissing?: boolean }) => any\n  peek: <T>(fn: () => T) => T // returns the current state of the signal without subscribing\n  getPath: <T = any>(path: string) => T // get a value from the root\n  hasPath: (path: string) => boolean // check if a path exists from the root\n}\n\nexport type HTMLOrSVG = Element & (HTMLElement | SVGElement)\nexport type Modifiers = Map<string, Set<string>> // mod name -> tags\nexport type ReactiveExpressionFn = <T>(...argsThenDeps: any[]) => T // a reactive expression\n\nexport type RuntimeContext = InitContext & {\n  el: HTMLOrSVG // The element the attribute is on\n  rawKey: Readonly<string> // no parsing data-* key\n  key: Readonly<string> // data-* key without the prefix or tags\n  value: Readonly<string> // value of data-* attribute\n  mods: Modifiers // the modifiers and their tags\n  rx: ReactiveExpressionFn // function to generate a reactive expression\n  fnContent?: string // the content of the function\n  evt?: Event // the event that triggered the plugin\n  runtimeErr: (reason: string, metadata?: object) => Error\n}\n\nexport type RuntimeExpressionFunction = (\n  ctx: RuntimeContext,\n  ...args: any[]\n) => any\n\nexport type EventCallbackHandler = (...args: any[]) => void\n\nexport type SignalFilter = RegExp\nexport type SignalFilterOptions = {\n  include?: RegExp\n  exclude?: RegExp\n}\n\nexport type Signal<T = any> = {\n  (): T\n  (value: T): boolean\n}\n\nexport type Computed<T = any> = () => T\n\nexport type Effect = () => void\n", "import { findClosestScoped, isHTMLOrSVG } from '../utils/dom'\nimport { isEmpty, isPojo, pathToObj } from '../utils/paths'\nimport { camel, snake } from '../utils/text'\nimport { DATASTAR, DSP, DSS } from './consts'\nimport { initErr, runtimeErr } from './errors'\nimport type {\n  ActionPlugins,\n  AttributePlugin,\n  Computed,\n  DatastarPlugin,\n  Effect,\n  HTMLOrSVG,\n  InitContext,\n  JSONPatch,\n  OnRemovalFn,\n  RuntimeContext,\n  RuntimeExpressionFunction,\n  Signal,\n  SignalFilterOptions,\n} from './types'\nimport { DATASTAR_SIGNAL_PATCH_EVENT } from './types'\n\n/**\n * Custom signals implementation based on Alien Signals\n */\n\ninterface ReactiveNode {\n  deps_?: Link\n  depsTail_?: Link\n  subs_?: Link\n  subsTail_?: Link\n  flags_: ReactiveFlags\n}\n\ninterface Link {\n  dep_: ReactiveNode\n  sub_: ReactiveNode\n  prevSub_?: Link\n  nextSub_?: Link\n  prevDep_?: Link\n  nextDep_?: Link\n}\n\ninterface Stack<T> {\n  value_: T\n  prev_?: Stack<T>\n}\n\nenum ReactiveFlags {\n  None = 0,\n  Mutable = 1 << 0,\n  Watching = 1 << 1,\n  RecursedCheck = 1 << 2,\n  Recursed = 1 << 3,\n  Dirty = 1 << 4,\n  Pending = 1 << 5,\n}\n\nenum EffectFlags {\n  Queued = 1 << 6,\n}\n\ninterface AlienEffect extends ReactiveNode {\n  fn_(): void\n}\n\ninterface AlienComputed<T = any> extends ReactiveNode {\n  value_?: T\n  getter(previousValue?: T): T\n}\n\ninterface AlienSignal<T = any> extends ReactiveNode {\n  previousValue: T\n  value_: T\n}\n\nlet currentPatch: Record<string, any> = {}\nconst queuedEffects: (AlienEffect | undefined)[] = []\nlet batchDepth = 0\nlet notifyIndex = 0\nlet queuedEffectsLength = 0\nlet activeSub: ReactiveNode | undefined\n\nconst startBatch = (): void => {\n  batchDepth++\n}\nconst endBatch = (): void => {\n  if (!--batchDepth) {\n    flush()\n    dispatch()\n  }\n}\n\nconst signal = <T>(initialValue?: T): Signal<T> => {\n  return signalOper.bind(0, {\n    previousValue: initialValue,\n    value_: initialValue,\n    flags_: 1 satisfies ReactiveFlags.Mutable,\n  }) as Signal<T>\n}\n\nconst computedSymbol = Symbol('computed')\nconst computed = <T>(getter: (previousValue?: T) => T): Computed<T> => {\n  const c = computedOper.bind(0, {\n    flags_: 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty,\n    getter,\n  }) as Computed<T>\n  // @ts-ignore\n  c[computedSymbol] = 1\n  return c\n}\n\nconst effect = (fn: () => void): Effect => {\n  const e: AlienEffect = {\n    fn_: fn,\n    flags_: 2 satisfies ReactiveFlags.Watching,\n  }\n  if (activeSub) {\n    link(e, activeSub)\n  }\n  const prev = setCurrentSub(e)\n  try {\n    e.fn_()\n  } finally {\n    setCurrentSub(prev)\n  }\n  return effectOper.bind(0, e)\n}\n\nconst peek = <T>(fn: () => T): T => {\n  const prev = setCurrentSub(undefined)\n  try {\n    return fn()\n  } finally {\n    setCurrentSub(prev)\n  }\n}\n\nconst flush = () => {\n  while (notifyIndex < queuedEffectsLength) {\n    const effect = queuedEffects[notifyIndex]!\n    queuedEffects[notifyIndex++] = undefined\n    run(effect, (effect.flags_ &= ~EffectFlags.Queued))\n  }\n  notifyIndex = 0\n  queuedEffectsLength = 0\n}\n\nconst update = (signal: AlienSignal | AlienComputed): boolean => {\n  if ('getter' in signal) {\n    return updateComputed(signal)\n  }\n  return updateSignal(signal, signal.value_)\n}\n\nconst setCurrentSub = (sub?: ReactiveNode): ReactiveNode | undefined => {\n  const prevSub = activeSub\n  activeSub = sub\n  return prevSub\n}\n\nconst updateComputed = (c: AlienComputed): boolean => {\n  const prevSub = setCurrentSub(c)\n  startTracking(c)\n  try {\n    const oldValue = c.value_\n    return oldValue !== (c.value_ = c.getter(oldValue))\n  } finally {\n    setCurrentSub(prevSub)\n    endTracking(c)\n  }\n}\n\nconst updateSignal = (s: AlienSignal, value: any): boolean => {\n  s.flags_ = 1 satisfies ReactiveFlags.Mutable\n  return s.previousValue !== (s.previousValue = value)\n}\n\nconst notify = (e: AlienEffect): void => {\n  const flags = e.flags_\n  if (!(flags & EffectFlags.Queued)) {\n    e.flags_ = flags | EffectFlags.Queued\n    const subs = e.subs_\n    if (subs) {\n      notify(subs.sub_ as AlienEffect)\n    } else {\n      queuedEffects[queuedEffectsLength++] = e\n    }\n  }\n}\n\nconst run = (e: AlienEffect, flags: ReactiveFlags): void => {\n  if (\n    flags & (16 satisfies ReactiveFlags.Dirty) ||\n    (flags & (32 satisfies ReactiveFlags.Pending) && checkDirty(e.deps_!, e))\n  ) {\n    const prev = setCurrentSub(e)\n    startTracking(e)\n    try {\n      e.fn_()\n    } finally {\n      setCurrentSub(prev)\n      endTracking(e)\n    }\n    return\n  }\n  if (flags & (32 satisfies ReactiveFlags.Pending)) {\n    e.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending)\n  }\n  let link = e.deps_\n  while (link) {\n    const dep = link.dep_\n    const depFlags = dep.flags_\n    if (depFlags & EffectFlags.Queued) {\n      run(dep as AlienEffect, (dep.flags_ = depFlags & ~EffectFlags.Queued))\n    }\n    link = link.nextDep_\n  }\n}\n\nconst computedOper = <T>(c: AlienComputed<T>): T => {\n  const flags = c.flags_\n  if (\n    flags & (16 satisfies ReactiveFlags.Dirty) ||\n    (flags & (32 satisfies ReactiveFlags.Pending) && checkDirty(c.deps_!, c))\n  ) {\n    if (updateComputed(c)) {\n      const subs = c.subs_\n      if (subs) {\n        shallowPropagate(subs)\n      }\n    }\n  } else if (flags & (32 satisfies ReactiveFlags.Pending)) {\n    c.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending)\n  }\n  if (activeSub) {\n    link(c, activeSub)\n  }\n  return c.value_!\n}\n\nconst signalOper = <T>(s: AlienSignal<T>, ...value: [T]): T | boolean => {\n  if (value.length) {\n    const newValue = value[0]\n    if (s.value_ !== (s.value_ = newValue)) {\n      s.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty\n      const subs = s.subs_\n      if (subs) {\n        propagate(subs)\n        if (!batchDepth) {\n          flush()\n        }\n      }\n      return true\n    }\n    return false\n  }\n  const currentValue = s.value_\n  if (s.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n    if (updateSignal(s, currentValue)) {\n      const subs_ = s.subs_\n      if (subs_) {\n        shallowPropagate(subs_)\n      }\n    }\n  }\n  if (activeSub) {\n    link(s, activeSub)\n  }\n  return currentValue\n}\n\nconst effectOper = (e: AlienEffect): void => {\n  let dep = e.deps_\n  while (dep) {\n    dep = unlink(dep, e)\n  }\n  const sub = e.subs_\n  if (sub) {\n    unlink(sub)\n  }\n  e.flags_ = 0 satisfies ReactiveFlags.None\n}\n\nconst link = (dep: ReactiveNode, sub: ReactiveNode): void => {\n  const prevDep = sub.depsTail_\n  if (prevDep && prevDep.dep_ === dep) {\n    return\n  }\n  let nextDep: Link | undefined\n  const recursedCheck = sub.flags_ & (4 satisfies ReactiveFlags.RecursedCheck)\n  if (recursedCheck) {\n    nextDep = prevDep ? prevDep.nextDep_ : sub.deps_\n    if (nextDep && nextDep.dep_ === dep) {\n      sub.depsTail_ = nextDep\n      return\n    }\n  }\n  const prevSub = dep.subsTail_\n  if (\n    prevSub &&\n    prevSub.sub_ === sub &&\n    (!recursedCheck || isValidLink(prevSub, sub))\n  ) {\n    return\n  }\n  const newLink =\n    (sub.depsTail_ =\n    dep.subsTail_ =\n      {\n        dep_: dep,\n        sub_: sub,\n        prevDep_: prevDep,\n        nextDep_: nextDep,\n        prevSub_: prevSub,\n      })\n  if (nextDep) {\n    nextDep.prevDep_ = newLink\n  }\n  if (prevDep) {\n    prevDep.nextDep_ = newLink\n  } else {\n    sub.deps_ = newLink\n  }\n  if (prevSub) {\n    prevSub.nextSub_ = newLink\n  } else {\n    dep.subs_ = newLink\n  }\n}\n\nconst unlink = (link: Link, sub_ = link.sub_): Link | undefined => {\n  const dep_ = link.dep_\n  const prevDep_ = link.prevDep_\n  const nextDep_ = link.nextDep_\n  const nextSub_ = link.nextSub_\n  const prevSub_ = link.prevSub_\n  if (nextDep_) {\n    nextDep_.prevDep_ = prevDep_\n  } else {\n    sub_.depsTail_ = prevDep_\n  }\n  if (prevDep_) {\n    prevDep_.nextDep_ = nextDep_\n  } else {\n    sub_.deps_ = nextDep_\n  }\n  if (nextSub_) {\n    nextSub_.prevSub_ = prevSub_\n  } else {\n    dep_.subsTail_ = prevSub_\n  }\n  if (prevSub_) {\n    prevSub_.nextSub_ = nextSub_\n  } else if (!(dep_.subs_ = nextSub_)) {\n    if ('getter' in dep_) {\n      let toRemove = dep_.deps_\n      if (toRemove) {\n        dep_.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty\n        do {\n          toRemove = unlink(toRemove, dep_)\n        } while (toRemove)\n      }\n    } else if (!('previousValue' in dep_)) {\n      effectOper(dep_ as AlienEffect)\n    }\n  }\n  return nextDep_\n}\n\nconst propagate = (link: Link): void => {\n  let next = link.nextSub_\n  let stack: Stack<Link | undefined> | undefined\n\n  top: while (true) {\n    const sub = link.sub_\n\n    let flags = sub.flags_\n\n    if (flags & (3 as ReactiveFlags.Mutable | ReactiveFlags.Watching)) {\n      if (\n        !(\n          flags &\n          (60 as\n            | ReactiveFlags.RecursedCheck\n            | ReactiveFlags.Recursed\n            | ReactiveFlags.Dirty\n            | ReactiveFlags.Pending)\n        )\n      ) {\n        sub.flags_ = flags | (32 satisfies ReactiveFlags.Pending)\n      } else if (\n        !(flags & (12 as ReactiveFlags.RecursedCheck | ReactiveFlags.Recursed))\n      ) {\n        flags = 0 satisfies ReactiveFlags.None\n      } else if (!(flags & (4 satisfies ReactiveFlags.RecursedCheck))) {\n        sub.flags_ =\n          (flags & ~(8 satisfies ReactiveFlags.Recursed)) |\n          (32 satisfies ReactiveFlags.Pending)\n      } else if (\n        !(flags & (48 as ReactiveFlags.Dirty | ReactiveFlags.Pending)) &&\n        isValidLink(link, sub)\n      ) {\n        sub.flags_ =\n          flags | (40 as ReactiveFlags.Recursed | ReactiveFlags.Pending)\n        flags &= 1 satisfies ReactiveFlags.Mutable\n      } else {\n        flags = 0 satisfies ReactiveFlags.None\n      }\n\n      if (flags & (2 satisfies ReactiveFlags.Watching)) {\n        notify(sub as AlienEffect)\n      }\n\n      if (flags & (1 satisfies ReactiveFlags.Mutable)) {\n        const subSubs = sub.subs_\n        if (subSubs) {\n          link = subSubs\n          if (subSubs.nextSub_) {\n            stack = { value_: next, prev_: stack }\n            next = link.nextSub_\n          }\n          continue\n        }\n      }\n    }\n\n    if ((link = next!)) {\n      next = link.nextSub_\n      continue\n    }\n\n    while (stack) {\n      link = stack.value_!\n      stack = stack.prev_\n      if (link) {\n        next = link.nextSub_\n        continue top\n      }\n    }\n\n    break\n  }\n}\n\nconst startTracking = (sub: ReactiveNode): void => {\n  sub.depsTail_ = undefined\n  sub.flags_ =\n    (sub.flags_ &\n      ~(56 as\n        | ReactiveFlags.Recursed\n        | ReactiveFlags.Dirty\n        | ReactiveFlags.Pending)) |\n    (4 satisfies ReactiveFlags.RecursedCheck)\n}\n\nconst endTracking = (sub: ReactiveNode): void => {\n  const depsTail_ = sub.depsTail_\n  let toRemove = depsTail_ ? depsTail_.nextDep_ : sub.deps_\n  while (toRemove) {\n    toRemove = unlink(toRemove, sub)\n  }\n  sub.flags_ &= ~(4 satisfies ReactiveFlags.RecursedCheck)\n}\n\nconst checkDirty = (link: Link, sub: ReactiveNode): boolean => {\n  let stack: Stack<Link> | undefined\n  let checkDepth = 0\n\n  top: while (true) {\n    const dep = link.dep_\n    const depFlags = dep.flags_\n\n    let dirty = false\n\n    if (sub.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n      dirty = true\n    } else if (\n      (depFlags & (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)) ===\n      (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)\n    ) {\n      if (update(dep as AlienSignal | AlienComputed)) {\n        const subs = dep.subs_!\n        if (subs.nextSub_) {\n          shallowPropagate(subs)\n        }\n        dirty = true\n      }\n    } else if (\n      (depFlags & (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)) ===\n      (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)\n    ) {\n      if (link.nextSub_ || link.prevSub_) {\n        stack = { value_: link, prev_: stack }\n      }\n      link = dep.deps_!\n      sub = dep\n      ++checkDepth\n      continue\n    }\n\n    if (!dirty && link.nextDep_) {\n      link = link.nextDep_\n      continue\n    }\n\n    while (checkDepth) {\n      --checkDepth\n      const firstSub = sub.subs_!\n      const hasMultipleSubs = firstSub.nextSub_\n      if (hasMultipleSubs) {\n        link = stack!.value_\n        stack = stack!.prev_\n      } else {\n        link = firstSub\n      }\n      if (dirty) {\n        if (update(sub as AlienSignal | AlienComputed)) {\n          if (hasMultipleSubs) {\n            shallowPropagate(firstSub)\n          }\n          sub = link.sub_\n          continue\n        }\n      } else {\n        sub.flags_ &= ~(32 satisfies ReactiveFlags.Pending)\n      }\n      sub = link.sub_\n      if (link.nextDep_) {\n        link = link.nextDep_\n        continue top\n      }\n      dirty = false\n    }\n\n    return dirty\n  }\n}\n\nconst shallowPropagate = (link: Link): void => {\n  do {\n    const sub = link.sub_\n    const nextSub = link.nextSub_\n    const subFlags = sub.flags_\n    if (\n      (subFlags & (48 as ReactiveFlags.Pending | ReactiveFlags.Dirty)) ===\n      (32 satisfies ReactiveFlags.Pending)\n    ) {\n      sub.flags_ = subFlags | (16 satisfies ReactiveFlags.Dirty)\n      if (subFlags & (2 satisfies ReactiveFlags.Watching)) {\n        notify(sub as AlienEffect)\n      }\n    }\n    link = nextSub!\n  } while (link)\n}\n\nconst isValidLink = (checkLink: Link, sub: ReactiveNode): boolean => {\n  const depsTail = sub.depsTail_\n  if (depsTail) {\n    let link = sub.deps_!\n    do {\n      if (link === checkLink) {\n        return true\n      }\n      if (link === depsTail) {\n        break\n      }\n      link = link.nextDep_!\n    } while (link)\n  }\n  return false\n}\n\nconst getPath = <T = any>(path: string): T =>\n  path.split('.').reduce((acc, key) => acc[key], root) as T\n\nconst hasPath = (path: string): boolean =>\n  peek(\n    () =>\n      path\n        .split('.')\n        .reduce(\n          (obj, key) => (obj && Object.hasOwn(obj, key) ? obj[key] : undefined),\n          root,\n        ) !== undefined,\n  )\n\nconst deep = (value: any, prefix = ''): any => {\n  const isArr = Array.isArray(value)\n  if (isArr || isPojo(value)) {\n    const deepObj = (isArr ? [] : {}) as Record<string, Signal>\n    for (const key in value) {\n      deepObj[key] = signal(\n        deep((value as Record<string, Signal>)[key], `${prefix + key}.`),\n      )\n    }\n    const keys = signal(0)\n    return new Proxy(deepObj, {\n      get: (_, prop: string) => {\n        if (prop === 'toJSON' && !Object.hasOwn(deepObj, prop)) {\n          return\n        }\n        if (isArr && prop in Array.prototype) {\n          keys()\n          return deepObj[prop]\n        }\n        if (!Object.hasOwn(deepObj, prop)) {\n          deepObj[prop] = signal('')\n          dispatch({ [prefix + prop]: '' })\n          keys(keys() + 1)\n        }\n        return deepObj[prop]()\n      },\n      set: (_, prop: string, newValue) => {\n        if (isArr && prop === 'length') {\n          deepObj[prop] = newValue\n          dispatch({ [prefix.slice(0, -1)]: deepObj })\n          keys(keys() + 1)\n          return true\n        }\n\n        if (Object.hasOwn(deepObj, prop)) {\n          if (newValue === null || newValue === undefined) {\n            delete deepObj[prop]\n            dispatch({ [prefix + prop]: null })\n            keys(keys() + 1)\n            return true\n          }\n          if (deepObj[prop](deep(newValue, `${prefix + prop}.`))) {\n            dispatch({ [prefix + prop]: newValue })\n          }\n        } else {\n          if (newValue === null || newValue === undefined) {\n            return true\n          }\n          if (Object.hasOwn(newValue, computedSymbol)) {\n            deepObj[prop] = newValue\n            dispatch({ [prefix + prop]: '' })\n          } else {\n            deepObj[prop] = signal(deep(newValue, `${prefix + prop}.`))\n            dispatch({ [prefix + prop]: newValue })\n          }\n\n          keys(keys() + 1)\n        }\n\n        return true\n      },\n      deleteProperty: (_, prop: string) => {\n        if (Object.hasOwn(deepObj, prop)) {\n          delete deepObj[prop]\n          dispatch({ [prefix + prop]: null })\n          keys(keys() + 1)\n        }\n\n        return true\n      },\n      ownKeys: () => {\n        keys()\n        return Reflect.ownKeys(deepObj)\n      },\n      has(_, prop) {\n        keys()\n        return prop in deepObj\n      },\n    })\n  }\n  return value\n}\n\nconst dispatch = (obj?: Record<string, any>) => {\n  if (obj) {\n    pathToObj(currentPatch, obj)\n  }\n  if (!batchDepth && !isEmpty(currentPatch)) {\n    const oldPatch = currentPatch\n    currentPatch = {}\n    document.dispatchEvent(\n      new CustomEvent<JSONPatch>(DATASTAR_SIGNAL_PATCH_EVENT, {\n        detail: oldPatch,\n      }),\n    )\n  }\n}\n\nconst mergePatch = (\n  patch: Record<string, any>,\n  { ifMissing }: { ifMissing?: boolean } = {},\n): void => {\n  startBatch()\n  for (const key in patch) {\n    if (patch[key] === null || patch[key] === undefined) {\n      if (!ifMissing) {\n        delete root[key]\n      }\n    } else {\n      mergeInner(patch[key], key, root, '', ifMissing)\n    }\n  }\n  endBatch()\n}\n\nconst mergeInner = (\n  patch: any,\n  target: string,\n  targetParent: Record<string, any>,\n  prefix: string,\n  ifMissing: boolean | undefined,\n): void => {\n  if (isPojo(patch)) {\n    if (\n      !(\n        Object.hasOwn(targetParent, target) &&\n        (isPojo(targetParent[target]) || Array.isArray(targetParent[target]))\n      )\n    ) {\n      targetParent[target] = {}\n    }\n\n    for (const key in patch) {\n      if (patch[key] === null || patch[key] === undefined) {\n        if (!ifMissing) {\n          delete targetParent[target][key]\n        }\n      } else {\n        mergeInner(\n          patch[key],\n          key,\n          targetParent[target],\n          `${prefix + target}.`,\n          ifMissing,\n        )\n      }\n    }\n  } else if (!(ifMissing && Object.hasOwn(targetParent, target))) {\n    targetParent[target] = patch\n  }\n}\n\nfunction filtered(\n  { include = /.*/, exclude = /(?!)/ }: SignalFilterOptions = {},\n  obj: JSONPatch = root,\n) {\n  // We need to find all valid signal paths in the object\n  const pathObj: Record<string, any> = {}\n  const stack: Array<[any, string]> = [[obj, '']]\n\n  while (stack.length) {\n    const [node, prefix] = stack.pop()!\n\n    for (const key in node) {\n      if (isPojo(node[key])) {\n        stack.push([node[key], `${prefix + key}.`])\n      } else if (include.test(prefix + key) && !exclude.test(prefix + key)) {\n        pathObj[prefix + key] = getPath(prefix + key)\n      }\n    }\n  }\n\n  return pathToObj({}, pathObj)\n}\n\nconst root: Record<string, any> = deep({})\n\n/**\n * Turn data-* attributes into reactive expressions\n * This is the core of the Datastar\n */\n\nconst actions: ActionPlugins = {}\nconst plugins: AttributePlugin[] = []\nlet pluginRegexs: RegExp[] = []\n\n// Map of cleanup functions by element, keyed by a dataset key-value hash\nconst removals = new Map<HTMLOrSVG, Map<string, OnRemovalFn>>()\n\nlet mutationObserver: MutationObserver | null = null\n\nlet alias = ''\nexport function setAlias(value: string) {\n  alias = value\n}\nexport function aliasify(name: string) {\n  return alias ? `data-${alias}-${name}` : `data-${name}`\n}\n\nexport function load(...pluginsToLoad: DatastarPlugin[]) {\n  for (const plugin of pluginsToLoad) {\n    const ctx: InitContext = {\n      plugin,\n      actions,\n      root,\n      filtered,\n      signal,\n      computed,\n      effect,\n      mergePatch,\n      peek,\n      getPath,\n      hasPath,\n    }\n    if (plugin.type === 'action') {\n      actions[plugin.name] = plugin\n    } else if (plugin.type === 'attribute') {\n      plugins.push(plugin)\n      plugin.onGlobalInit?.(ctx)\n    } else if (plugin.type === 'watcher') {\n      plugin.onGlobalInit?.(ctx)\n    } else {\n      throw initErr('InvalidPluginType', ctx)\n    }\n  }\n\n  // Sort attribute plugins by descending length then alphabetically\n  plugins.sort((a, b) => {\n    const lenDiff = b.name.length - a.name.length\n    if (lenDiff !== 0) return lenDiff\n    return a.name.localeCompare(b.name)\n  })\n\n  pluginRegexs = plugins.map((plugin) => RegExp(`^${plugin.name}([A-Z]|_|$)`))\n}\n\nfunction applyEls(els: Iterable<HTMLOrSVG>): void {\n  for (const el of els) {\n    for (const key in el.dataset) {\n      applyAttributePlugin(el, key, el.dataset[key]!)\n    }\n  }\n}\n\n// Apply all plugins to the entire DOM or a provided element\nexport function apply(root: HTMLOrSVG = document.body) {\n  // Delay applying plugins to give custom plugins a chance to load\n  queueMicrotask(() => {\n    applyEls([root])\n    applyEls(root.querySelectorAll<HTMLOrSVG>('*'))\n\n    // Monitor the entire document body or a provided element for changes\n    // https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe\n    if (!mutationObserver) {\n      mutationObserver = new MutationObserver(observe)\n      mutationObserver.observe(root, {\n        subtree: true,\n        childList: true,\n        attributes: true,\n      })\n    }\n  })\n}\n\nfunction applyAttributePlugin(\n  el: HTMLOrSVG,\n  attrKey: string,\n  value: string,\n): void {\n  const rawKey = camel(alias ? attrKey.slice(alias.length) : attrKey)\n  const plugin = plugins.find((_, i) => pluginRegexs[i].test(rawKey))\n  if (plugin) {\n    // Extract the key and modifiers\n    let [key, ...rawModifiers] = rawKey.slice(plugin.name.length).split(/__+/)\n\n    const hasKey = !!key\n    if (hasKey) {\n      key = camel(key)\n    }\n    const hasValue = !!value\n\n    // Create the runtime context\n    const ctx: RuntimeContext = {\n      el,\n      rawKey,\n      key,\n      value,\n      mods: new Map(),\n      root,\n      filtered,\n      mergePatch,\n      signal,\n      computed,\n      effect,\n      plugin,\n      actions,\n      peek,\n      getPath,\n      hasPath,\n      runtimeErr: 0 as any,\n      rx: 0 as any,\n    }\n    ctx.runtimeErr = runtimeErr.bind(0, ctx)\n    ctx.rx = generateReactiveExpression(ctx)\n\n    // Check the requirements\n    const keyReq = plugin.keyReq || 'allowed'\n    if (hasKey) {\n      if (keyReq === 'denied') {\n        throw ctx.runtimeErr(`${plugin.name}KeyNotAllowed`)\n      }\n    } else if (keyReq === 'must') {\n      throw ctx.runtimeErr(`${plugin.name}KeyRequired`)\n    }\n\n    const valReq = plugin.valReq || 'allowed'\n    if (hasValue) {\n      if (valReq === 'denied') {\n        throw ctx.runtimeErr(`${plugin.name}ValueNotAllowed`)\n      }\n    } else if (valReq === 'must') {\n      throw ctx.runtimeErr(`${plugin.name}ValueRequired`)\n    }\n\n    // Check for exclusive requirements\n    if (keyReq === 'exclusive' || valReq === 'exclusive') {\n      if (hasKey && hasValue) {\n        throw ctx.runtimeErr(`${plugin.name}KeyAndValueProvided`)\n      }\n      if (!hasKey && !hasValue) {\n        throw ctx.runtimeErr(`${plugin.name}KeyOrValueRequired`)\n      }\n    }\n\n    for (const rawMod of rawModifiers) {\n      const [label, ...mod] = rawMod.split('.')\n      ctx.mods.set(camel(label), new Set(mod.map((t) => t.toLowerCase())))\n    }\n\n    startBatch()\n    const cleanup = plugin.onLoad(ctx)\n    endBatch()\n    if (cleanup) {\n      let cleanups = removals.get(el)\n      if (cleanups) {\n        cleanups.get(rawKey)?.()\n      } else {\n        cleanups = new Map()\n        removals.set(el, cleanups)\n      }\n      cleanups.set(rawKey, cleanup)\n    }\n  }\n}\n\n// Set up a mutation observer to run plugin removal and apply functions\nfunction observe(mutations: MutationRecord[]) {\n  const ignore = `[${aliasify('ignore')}]`\n\n  for (const {\n    target,\n    type,\n    attributeName,\n    addedNodes,\n    removedNodes,\n  } of mutations) {\n    if (type === 'childList') {\n      for (const node of removedNodes) {\n        if (isHTMLOrSVG(node)) {\n          const cleanups = removals.get(node)\n          // If removals has el, delete it and run all cleanup functions\n          if (removals.delete(node)) {\n            for (const cleanup of cleanups!.values()) {\n              cleanup()\n            }\n            cleanups!.clear()\n          }\n        }\n      }\n\n      for (const node of addedNodes) {\n        if (isHTMLOrSVG(node)) {\n          applyEls([node])\n          applyEls(node.querySelectorAll<HTMLOrSVG>('*'))\n        }\n      }\n    } else if (type === 'attributes') {\n      // If el has a parent with data-ignore, skip it\n      if (isHTMLOrSVG(target) && !target.closest(ignore)) {\n        const key = camel(attributeName!.slice(5))\n        const value = target.getAttribute(attributeName!)\n        if (value === null) {\n          const cleanups = removals.get(target)\n          if (cleanups) {\n            cleanups.get(key)?.()\n            cleanups.delete(key)\n          }\n        } else {\n          applyAttributePlugin(target, key, value)\n        }\n      }\n    }\n  }\n}\n\nfunction generateReactiveExpression(\n  ctx: RuntimeContext,\n): RuntimeExpressionFunction {\n  let expr = ''\n\n  const attrPlugin = (ctx.plugin as AttributePlugin) || undefined\n\n  // plugin is guaranteed to be an attribute plugin\n  if (attrPlugin?.isExpr) {\n    // This regex allows Datastar expressions to support nested\n    // regex and strings that contain ; without breaking.\n    //\n    // Each of these regex defines a block type we want to match\n    // (importantly we ignore the content within these blocks):\n    //\n    // regex            \\/(\\\\\\/|[^\\/])*\\/\n    // double quotes      \"(\\\\\"|[^\\\"])*\"\n    // single quotes      '(\\\\'|[^'])*'\n    // ticks              `(\\\\`|[^`])*`\n    // iife               \\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;)\\{]*)\\s*\\)\\s*\\(\\s*\\)\n    //\n    // The iife support is (intentionally) limited. It only supports\n    // function and arrow syntax with no arguments, and no nested IIFEs.\n    //\n    // We also want to match the non delimiter part of statements\n    // note we only support ; statement delimiters:\n    //\n    // [^;]\n    //\n    const statementRe =\n      /(\\/(\\\\\\/|[^/])*\\/|\"(\\\\\"|[^\"])*\"|'(\\\\'|[^'])*'|`(\\\\`|[^`])*`|\\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;){]*)\\s*\\)\\s*\\(\\s*\\)|[^;])+/gm\n    const statements = ctx.value.trim().match(statementRe)\n    if (statements) {\n      const lastIdx = statements.length - 1\n      const last = statements[lastIdx].trim()\n      if (!last.startsWith('return')) {\n        statements[lastIdx] = `return (${last});`\n      }\n      expr = statements.join(';\\n')\n    }\n  } else {\n    expr = ctx.value.trim()\n  }\n\n  // Handle $$ syntax - converts $$signal to $context.signal for context signals\n  expr = expr.replace(\n    // Regex: matches $$ followed by valid signal names (including nested like $$foo.bar)\n    /\\$\\$([a-zA-Z_][\\w.-]*(?:\\.[a-zA-Z_][\\w.-]*)*?)(?=\\s|$|[^\\w.-])/g,\n    // s = captured signal name after $$\n    (_, s) => {\n      const scope = findClosestScoped(ctx.el)\n      return scope ? `$${scope}.${s}` : `$${s}` // if no scope: $signal for global scope\n    },\n  )\n\n  expr = expr.replace(\n    /\\$([a-zA-Z_][\\w.-]*(?:\\.[a-zA-Z_][\\w.-]*)*?)(?=\\s|$|[^\\w.-])/g,\n    (match, signalName) => {\n      // If the signal name ends with a hyphen followed by a $, it's likely two separate signals\n      // So we should not include the trailing hyphen in this signal name\n      if (\n        signalName.endsWith('-') &&\n        match.length < expr.length &&\n        expr[expr.indexOf(match) + match.length] === '$'\n      ) {\n        signalName = signalName.slice(0, -1)\n        const parts = signalName.split('.')\n        return `${parts.reduce((acc: string, part: string) => `${acc}['${part}']`, '$')}-`\n      }\n\n      const parts = signalName.split('.')\n      return parts.reduce(\n        (acc: string, part: string) => `${acc}['${part}']`,\n        '$',\n      )\n    },\n  )\n\n  // Ignore any escaped values\n  const escaped = new Map<string, string>()\n  const escapeRe = RegExp(`(?:${DSP})(.*?)(?:${DSS})`, 'gm')\n  for (const match of expr.matchAll(escapeRe)) {\n    const k = match[1]\n    const v = `dsEscaped${djb2(k)}`\n    escaped.set(v, k)\n    expr = expr.replace(DSP + k + DSS, v)\n  }\n\n  const nameGen = (prefix: string, name: string) => {\n    return `${prefix}${snake(name).replaceAll(/\\./g, '_')}`\n  }\n\n  // Replace any action calls\n  const actionsCalled = new Set<string>()\n  const actionsRe = RegExp(`@(${Object.keys(actions).join('|')})\\\\(`, 'gm')\n  const actionMatches = [...expr.matchAll(actionsRe)]\n  const actionNames = new Set<string>()\n  const actionFns = new Set<(...args: any[]) => any>()\n  if (actionMatches.length) {\n    const actionPrefix = `${DATASTAR}Act_`\n    for (const match of actionMatches) {\n      const actionName = match[1]\n      const action = actions[actionName]\n      if (!action) {\n        continue\n      }\n      actionsCalled.add(actionName)\n\n      const name = nameGen(actionPrefix, actionName)\n\n      // Add ctx to action calls\n      expr = expr.replace(`@${actionName}(`, `${name}(`)\n      actionNames.add(name)\n      actionFns.add((...args: any[]) => action.fn(ctx, ...args))\n    }\n  }\n\n  // Replace any escaped values\n  for (const [k, v] of escaped) {\n    expr = expr.replace(k, v)\n  }\n\n  ctx.fnContent = expr\n\n  try {\n    const fn = Function(\n      'el',\n      '$',\n      ...(attrPlugin?.argNames || []),\n      ...actionNames,\n      expr,\n    )\n    return (...args: any[]) => {\n      try {\n        return fn(ctx.el, root, ...args, ...actionFns)\n      } catch (e: any) {\n        throw ctx.runtimeErr('ExecuteExpression', {\n          error: e.message,\n        })\n      }\n    }\n  } catch (error: any) {\n    throw ctx.runtimeErr('GenerateExpression', {\n      error: error.message,\n    })\n  }\n}\n\nfunction djb2(str: string) {\n  let hash = 5831\n  let i = str.length\n  while (i--) {\n    hash += (hash << 5) + str.charCodeAt(i)\n  }\n  return (hash >>> 0).toString(36)\n}\n", "import { DSP } from '../engine/consts'\n\n// @ts-ignore\nconst _ = DSP // This is to force the import of DSP first in the compiled code\n\nimport { Computed } from '../plugins/core/attributes/computed'\nimport { Effect } from '../plugins/core/attributes/effect'\nimport { Signals } from '../plugins/core/attributes/signals'\nimport { apply, load, setAlias } from './engine'\n\nload(Signals, Computed, Effect)\n\nexport { apply, load, setAlias }\n", "// Icon: ion:eye\n// Slug: Peek at signals that match the signal path\n// Description: Use a signal or computed signal without subscribing to it.\n\nimport type { ActionPlugin } from '../../../engine/types'\n\nexport const Peek: ActionPlugin = {\n  type: 'action',\n  name: 'peek',\n  fn: ({ peek }, fn: () => any) => {\n    return peek(fn)\n  },\n}\n", "// Icon: ion:checkmark-round\n// Slug: Set all signals that match the signal path\n// Description: Set all signals that match one or more space-separated paths in which `*` can be used as a wildcard\n\nimport type {\n  ActionPlugin,\n  RuntimeContext,\n  SignalFilterOptions,\n} from '../../../engine/types'\nimport { updateLeaves } from '../../../utils/paths'\n\nexport const SetAll: ActionPlugin = {\n  type: 'action',\n  name: 'setAll',\n  fn: (\n    { filtered, mergePatch, peek }: RuntimeContext,\n    value: any,\n    filter: SignalFilterOptions,\n  ) => {\n    peek(() => {\n      const masked = filtered(filter)\n      updateLeaves(masked, () => value)\n      mergePatch(masked)\n    })\n  },\n}\n", "// Icon: material-symbols:toggle-off\n// Slug: Toggle all signals that match the signal path\n// Description: Toggle all signals that match one or more space-separated paths in which `*` can be used as a wildcard\n\nimport type {\n  ActionPlugin,\n  RuntimeContext,\n  SignalFilterOptions,\n} from '../../../engine/types'\nimport { updateLeaves } from '../../../utils/paths'\n\nexport const ToggleAll: ActionPlugin = {\n  type: 'action',\n  name: 'toggleAll',\n  fn: (\n    { filtered, mergePatch, peek }: RuntimeContext,\n    filter: SignalFilterOptions,\n  ) => {\n    peek(() => {\n      const masked = filtered(filter)\n      updateLeaves(masked, (oldValue: any) => !oldValue)\n      mergePatch(masked)\n    })\n  },\n}\n", "// Icon: material-symbols:edit-attributes-outline\n// Slug: Bind attributes to expressions\n// Description: Any attribute can be bound to an expression. The attribute will be updated reactively whenever the expression signal changes.\n\nimport type { AttributePlugin } from '../../../engine/types'\nimport { kebab } from '../../../utils/text'\n\nexport const Attr: AttributePlugin = {\n  type: 'attribute',\n  name: 'attr',\n  valReq: 'must',\n  isExpr: true,\n  onLoad: ({ el, effect, key, rx }) => {\n    const syncAttr = (key: string, val: any) => {\n      if (val === '' || val === true) {\n        el.setAttribute(key, '')\n      } else if (val === false || val === null || val === undefined) {\n        el.removeAttribute(key)\n      } else {\n        el.setAttribute(key, val)\n      }\n    }\n    if (key === '') {\n      const observer = new MutationObserver(() => {\n        observer.disconnect()\n        const obj = rx() as Record<string, any>\n        for (const [key, val] of Object.entries(obj)) {\n          syncAttr(key, val)\n        }\n        observer.observe(el, {\n          attributeFilter: Object.keys(obj),\n        })\n      })\n      const cleanup = effect(() => {\n        observer.disconnect()\n        const obj = rx() as Record<string, any>\n        for (const key in obj) {\n          syncAttr(key, obj[key])\n        }\n        observer.observe(el, {\n          attributeFilter: Object.keys(obj),\n        })\n      })\n\n      return () => {\n        observer.disconnect()\n        cleanup()\n      }\n    }\n    // Attributes are always kebab-case\n    const k = kebab(key)\n    const observer = new MutationObserver(() => {\n      observer.disconnect()\n      const value = rx<string>()\n      syncAttr(k, value)\n      observer.observe(el, {\n        attributeFilter: [value],\n      })\n    })\n    const cleanup = effect(() => {\n      observer.disconnect()\n      const value = rx<string>()\n      syncAttr(k, value)\n      observer.observe(el, {\n        attributeFilter: [value],\n      })\n    })\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n", "// Icon: akar-icons:link-chain\n// Slug: Bind attributes to expressions\n// Description: Any attribute can be bound to an expression. The attribute will be updated reactively whenever the expression signal changes.\n\nimport { aliasify } from '../../../engine/engine'\nimport type { AttributePlugin } from '../../../engine/types'\nimport { pathToObj } from '../../../utils/paths'\nimport { modifyCasing, modifyScope } from '../../../utils/text'\n\nconst dataURIRegex = /^data:(?<mime>[^;]+);base64,(?<contents>.*)$/\nconst textType = /email|password|search|tel|text|url/\nconst numberType = /number|range/\n\nexport const Bind: AttributePlugin = {\n  type: 'attribute',\n  name: 'bind',\n  keyReq: 'exclusive',\n  valReq: 'exclusive',\n  onLoad: ({\n    el,\n    key,\n    mods,\n    value,\n    effect,\n    mergePatch,\n    runtimeErr,\n    getPath,\n    hasPath,\n  }) => {\n    let signalName = key ? modifyCasing(key, mods) : value\n    signalName = modifyScope(signalName, el, mods)\n\n    if (\n      (el instanceof HTMLInputElement && textType.test(el.type)) ||\n      el instanceof HTMLTextAreaElement\n    ) {\n      if (Array.isArray(hasPath(signalName) && getPath(signalName))) {\n        // For array signals, determine this input's index based on DOM order\n        const scopedModifier = mods.has('scoped') ? '__scoped' : ''\n        const allBoundInputs = document.querySelectorAll(\n          `[${aliasify('bind')}${scopedModifier}-${key}],[${aliasify('bind')}${scopedModifier}=\"${value}\"]`,\n        )\n\n        let inputIndex = 0\n        const pathObj: Record<string, string> = {}\n        for (const input of allBoundInputs) {\n          if (!hasPath(`${signalName}.${inputIndex}`)) {\n            pathObj[`${signalName}.${inputIndex}`] = (\n              input as HTMLInputElement\n            ).value\n          }\n\n          if (el === input) {\n            break\n          }\n          inputIndex++\n        }\n        mergePatch(pathToObj({}, pathObj))\n\n        const syncSignal = () => {\n          mergePatch(\n            pathToObj({}, { [`${signalName}.${inputIndex}`]: el.value }),\n          )\n        }\n\n        el.addEventListener('change', syncSignal)\n        el.addEventListener('input', syncSignal)\n\n        const cleanup = effect(\n          () => (el.value = getPath(signalName)[inputIndex]),\n        )\n\n        return () => {\n          cleanup()\n          el.removeEventListener('change', syncSignal)\n          el.removeEventListener('input', syncSignal)\n        }\n      }\n\n      // Non-array signal handling\n      mergePatch(pathToObj({}, { [signalName]: el.value }), { ifMissing: true })\n\n      const syncSignal = () =>\n        mergePatch(pathToObj({}, { [signalName]: el.value }))\n      el.addEventListener('change', syncSignal)\n      el.addEventListener('input', syncSignal)\n\n      const cleanup = effect(() => (el.value = getPath(signalName)))\n\n      return () => {\n        cleanup()\n        el.removeEventListener('change', syncSignal)\n        el.removeEventListener('input', syncSignal)\n      }\n    }\n\n    if (el instanceof HTMLInputElement) {\n      if (el.type === 'checkbox') {\n        if (Array.isArray(hasPath(signalName) && getPath(signalName))) {\n          // For array signals, determine this input's index based on DOM order\n          const scopedModifier = mods.has('scoped') ? '__scoped' : ''\n          const allBoundInputs = document.querySelectorAll(\n            `[${aliasify('bind')}${scopedModifier}-${key}],[${aliasify('bind')}${scopedModifier}=\"${value}\"]`,\n          )\n\n          let inputIndex = 0\n          const pathObj: Record<string, string | boolean> = {}\n          for (const input of allBoundInputs) {\n            if (!hasPath(`${signalName}.${inputIndex}`)) {\n              const val = input.getAttribute('value')\n              pathObj[`${signalName}.${inputIndex}`] = val\n                ? (input as HTMLInputElement).checked\n                  ? val\n                  : ''\n                : (input as HTMLInputElement).checked\n            }\n\n            if (el === input) {\n              break\n            }\n            inputIndex++\n          }\n          mergePatch(pathToObj({}, pathObj))\n\n          const syncSignal = () => {\n            const val = el.getAttribute('value')\n            mergePatch(\n              pathToObj(\n                {},\n                {\n                  [`${signalName}.${inputIndex}`]: val\n                    ? el.checked\n                      ? val\n                      : ''\n                    : el.checked,\n                },\n              ),\n            )\n          }\n\n          el.addEventListener('change', syncSignal)\n          el.addEventListener('input', syncSignal)\n\n          const cleanup = effect(() => {\n            const val = el.getAttribute('value')\n            el.checked = val\n              ? val === getPath(signalName)[inputIndex]\n              : getPath(signalName)[inputIndex]\n          })\n\n          return () => {\n            cleanup()\n            el.removeEventListener('change', syncSignal)\n            el.removeEventListener('input', syncSignal)\n          }\n        }\n\n        const val = el.getAttribute('value')\n        mergePatch(\n          pathToObj(\n            {},\n            { [signalName]: val ? (el.checked ? val : '') : el.checked },\n          ),\n        )\n\n        const syncSignal = () => {\n          const val = el.getAttribute('value')\n          mergePatch(\n            pathToObj(\n              {},\n              { [signalName]: val ? (el.checked ? val : '') : el.checked },\n            ),\n          )\n        }\n        el.addEventListener('change', syncSignal)\n        el.addEventListener('input', syncSignal)\n\n        const cleanup = effect(() => {\n          const val = el.getAttribute('value')\n          el.checked = val ? val === getPath(signalName) : getPath(signalName)\n        })\n\n        return () => {\n          cleanup()\n          el.removeEventListener('change', syncSignal)\n          el.removeEventListener('input', syncSignal)\n        }\n      }\n\n      if (el.type === 'radio') {\n        // Set up radio button name attribute if not present\n        if (!el.getAttribute('name')?.length) {\n          el.setAttribute('name', signalName)\n        }\n\n        mergePatch(pathToObj({}, { [signalName]: el.value }), {\n          ifMissing: true,\n        })\n\n        const syncSignal = () =>\n          el.checked && mergePatch(pathToObj({}, { [signalName]: el.value }))\n        el.addEventListener('change', syncSignal)\n        el.addEventListener('input', syncSignal)\n\n        const cleanup = effect(\n          () => (el.checked = el.value === getPath(signalName)),\n        )\n\n        return () => {\n          cleanup()\n          el.removeEventListener('change', syncSignal)\n          el.removeEventListener('input', syncSignal)\n        }\n      }\n\n      if (numberType.test(el.type)) {\n        mergePatch(pathToObj({}, { [signalName]: +el.value }), {\n          ifMissing: true,\n        })\n\n        const syncSignal = () =>\n          mergePatch(pathToObj({}, { [signalName]: +el.value }))\n        el.addEventListener('change', syncSignal)\n        el.addEventListener('input', syncSignal)\n\n        const cleanup = effect(() => (el.value = getPath(signalName)))\n\n        return () => {\n          cleanup()\n          el.removeEventListener('change', syncSignal)\n          el.removeEventListener('input', syncSignal)\n        }\n      }\n\n      if (el.type === 'file') {\n        const syncSignal = () => {\n          const files = [...(el.files || [])]\n          const allContents: string[] = []\n          const allMimes: string[] = []\n          const allNames: string[] = []\n          Promise.all(\n            files.map(\n              (f) =>\n                new Promise<void>((resolve) => {\n                  const reader = new FileReader()\n                  reader.onload = () => {\n                    if (typeof reader.result !== 'string') {\n                      throw runtimeErr('InvalidFileResultType', {\n                        resultType: typeof reader.result,\n                      })\n                    }\n                    const match = reader.result.match(dataURIRegex)\n                    if (!match?.groups) {\n                      throw runtimeErr('InvalidDataUri', {\n                        result: reader.result,\n                      })\n                    }\n                    allContents.push(match.groups.contents)\n                    allMimes.push(match.groups.mime)\n                    allNames.push(f.name)\n                  }\n                  reader.onloadend = () => resolve()\n                  reader.readAsDataURL(f)\n                }),\n            ),\n          ).then(() => {\n            mergePatch(\n              pathToObj(\n                {},\n                {\n                  [signalName]: allContents,\n                  [`${signalName}Mimes`]: allMimes,\n                  [`${signalName}Names`]: allNames,\n                },\n              ),\n            )\n          })\n        }\n\n        el.addEventListener('change', syncSignal)\n        el.addEventListener('input', syncSignal)\n\n        return () => {\n          el.removeEventListener('change', syncSignal)\n          el.removeEventListener('input', syncSignal)\n        }\n      }\n      // else unsupported type\n    }\n\n    if (el instanceof HTMLSelectElement) {\n      if (el.multiple) {\n        // Multi-select handling\n        mergePatch(\n          pathToObj(\n            {},\n            {\n              [signalName]: [...el.selectedOptions].map(\n                (option) => option.value,\n              ),\n            },\n          ),\n          {\n            ifMissing: true,\n          },\n        )\n\n        const syncSignal = () =>\n          mergePatch(\n            pathToObj(\n              {},\n              {\n                [signalName]: [...el.selectedOptions].map(\n                  (option) => option.value,\n                ),\n              },\n            ),\n          )\n        el.addEventListener('change', syncSignal)\n        el.addEventListener('input', syncSignal)\n\n        const cleanup = effect(() => {\n          const signalValue: string[] = getPath(signalName)\n          for (const option of el.options) {\n            option.selected = signalValue.includes(option.value)\n          }\n        })\n\n        return () => {\n          cleanup()\n          el.removeEventListener('change', syncSignal)\n          el.removeEventListener('input', syncSignal)\n        }\n      }\n\n      // Single-select handling\n      mergePatch(\n        pathToObj(\n          {},\n          {\n            [signalName]: el.value,\n          },\n        ),\n        {\n          ifMissing: true,\n        },\n      )\n\n      const syncSignal = () =>\n        mergePatch(\n          pathToObj(\n            {},\n            {\n              [signalName]: el.value,\n            },\n          ),\n        )\n      el.addEventListener('change', syncSignal)\n      el.addEventListener('input', syncSignal)\n\n      const syncElement = () => (el.value = getPath(signalName))\n      const cleanup = effect(syncElement)\n\n      return () => {\n        cleanup()\n        el.removeEventListener('change', syncSignal)\n        el.removeEventListener('input', syncSignal)\n      }\n    }\n\n    mergePatch(\n      pathToObj(\n        {},\n        {\n          [signalName]: el.getAttribute('value'),\n        },\n      ),\n      { ifMissing: true },\n    )\n\n    const observer = new MutationObserver(() => {\n      mergePatch(\n        pathToObj(\n          {},\n          {\n            [signalName]: el.getAttribute('value'),\n          },\n        ),\n      )\n    })\n    observer.observe(el, {\n      attributeFilter: ['value'],\n    })\n\n    const cleanup = effect(() => el.setAttribute('value', getPath(signalName)))\n\n    return () => {\n      cleanup()\n      observer.disconnect()\n    }\n  },\n}\n", "// Icon: ic:baseline-format-paint\n// Slug: Add or remove classes from an element reactively\n// Description: This action adds or removes classes from an element reactively based on the expression provided. The expression should be an object where the keys are the class names and the values are booleans. If the value is true, the class is added. If the value is false, the class is removed.\n\nimport type { AttributePlugin } from '../../../engine/types'\nimport { kebab, modifyCasing } from '../../../utils/text'\n\nexport const Class: AttributePlugin = {\n  type: 'attribute',\n  name: 'class',\n  valReq: 'must',\n  isExpr: true,\n  onLoad: ({ key, el, effect, mods, rx }) => {\n    if (key === '') {\n      const observer = new MutationObserver(() => {\n        observer.disconnect()\n        const classes = rx<Record<string, boolean>>()\n        for (const [k, v] of Object.entries(classes)) {\n          const classNames = k.split(/\\s+/)\n          if (v) {\n            el.classList.add(...classNames)\n          } else {\n            el.classList.remove(...classNames)\n          }\n        }\n        observer.observe(el, {\n          attributeFilter: ['class'],\n        })\n      })\n      const cleanup = effect(() => {\n        observer.disconnect()\n        const classes = rx<Record<string, boolean>>()\n        for (const [k, v] of Object.entries(classes)) {\n          const classNames = k.split(/\\s+/)\n          if (v) {\n            el.classList.add(...classNames)\n          } else {\n            el.classList.remove(...classNames)\n          }\n        }\n        observer.observe(el, {\n          attributeFilter: ['class'],\n        })\n      })\n\n      return () => {\n        observer.disconnect()\n        cleanup()\n      }\n    }\n\n    // Default to kebab-case and allow modifying\n    let className = kebab(key)\n    className = modifyCasing(className, mods)\n    const observer = new MutationObserver(() => {\n      observer.disconnect()\n      const shouldInclude = rx<boolean>()\n      if (shouldInclude) {\n        el.classList.add(className)\n      } else {\n        el.classList.remove(className)\n      }\n      observer.observe(el, {\n        attributeFilter: ['class'],\n      })\n    })\n    const cleanup = effect(() => {\n      observer.disconnect()\n      const shouldInclude = rx<boolean>()\n      if (shouldInclude) {\n        el.classList.add(className)\n      } else {\n        el.classList.remove(className)\n      }\n      observer.observe(el, {\n        attributeFilter: ['class'],\n      })\n    })\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n", "import { DATASTAR } from '../../../engine/consts'\nimport type { HTMLOrSVG } from '../../../engine/types'\n\nexport const DATASTAR_SSE_EVENT = `${DATASTAR}-sse`\nexport const STARTED = 'started'\nexport const FINISHED = 'finished'\nexport const ERROR = 'error'\nexport const RETRYING = 'retrying'\nexport const RETRIES_FAILED = 'retrying'\n\nexport interface DatastarSSEEvent {\n  type: string\n  el: HTMLOrSVG\n  argsRaw: Record<string, string>\n}\n\nexport interface CustomEventMap {\n  [DATASTAR_SSE_EVENT]: CustomEvent<DatastarSSEEvent>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\n\ndeclare global {\n  interface Document {\n    //adds definition to Document, but you can do the same with HTMLElement\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n  }\n}\n\nexport function datastarSSEEventWatcher(\n  eventType: string,\n  fn: (argsRaw: Record<string, string>) => void,\n) {\n  document.addEventListener(\n    DATASTAR_SSE_EVENT,\n    (event: CustomEvent<DatastarSSEEvent>) => {\n      if (event.detail.type === eventType) {\n        const { argsRaw } = event.detail\n        fn(argsRaw)\n      }\n    },\n  )\n}\n", "// Icon: material-symbols:network-wifi\n// Slug: Sets the indicator signal used when fetching data via SSE\n// Description: must be a valid signal name\n\nimport type { AttributePlugin } from '../../../engine/types'\nimport { pathToObj } from '../../../utils/paths'\nimport { modifyCasing, modifyScope } from '../../../utils/text'\nimport {\n  DATASTAR_SSE_EVENT,\n  type DatastarSSEEvent,\n  FINISHED,\n  STARTED,\n} from '../backend/shared'\n\nexport const Indicator: AttributePlugin = {\n  type: 'attribute',\n  name: 'indicator',\n  keyReq: 'exclusive',\n  valReq: 'exclusive',\n  onLoad: ({ el, key, mods, mergePatch, value }) => {\n    let signalName = key ? modifyCasing(key, mods) : value\n    signalName = modifyScope(signalName, el, mods)\n\n    mergePatch(pathToObj({}, { [signalName]: false }), { ifMissing: true })\n\n    const watcher = ((event: CustomEvent<DatastarSSEEvent>) => {\n      const { type, el: elt } = event.detail\n      if (elt !== el) {\n        return\n      }\n      switch (type) {\n        case STARTED:\n          mergePatch(pathToObj({}, { [signalName]: true }))\n          break\n        case FINISHED:\n          mergePatch(pathToObj({}, { [signalName]: false }))\n          break\n      }\n    }) as EventListener\n    document.addEventListener(DATASTAR_SSE_EVENT, watcher)\n    return () => {\n      mergePatch(pathToObj({}, { [signalName]: false }))\n      document.removeEventListener(DATASTAR_SSE_EVENT, watcher)\n    }\n  },\n}\n", "// Icon: tabler:typography\n// Slug: Set the text content of an element to a reactive JSON stringified version of all signals\n// Description: This attribute sets the text content of an element to a reactive JSON stringified version of all signals.\n\nimport type {\n  AttributePlugin,\n  SignalFilterOptions,\n} from '../../../engine/types'\nimport { jsStrToObject } from '../../../utils/text'\n\nexport const JsonSignals: AttributePlugin = {\n  type: 'attribute',\n  name: 'jsonSignals',\n  keyReq: 'denied',\n  onLoad: ({ el, effect, value, filtered, mods }) => {\n    const spaces = mods.has('terse') ? 0 : 2\n    let filters: SignalFilterOptions = {}\n    if (value) {\n      filters = jsStrToObject(value)\n    }\n\n    const callback = () => {\n      observer.disconnect()\n      el.textContent = JSON.stringify(filtered(filters), null, spaces)\n      observer.observe(el, {\n        childList: true,\n      })\n    }\n    const observer = new MutationObserver(callback)\n    const cleanup = effect(callback)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n", "export function tagToMs(args: Set<string>) {\n  if (!args || args.size <= 0) return 0\n  for (const arg of args) {\n    if (arg.endsWith('ms')) {\n      return +arg.replace('ms', '')\n    }\n    if (arg.endsWith('s')) {\n      return +arg.replace('s', '') * 1000\n    }\n    try {\n      return Number.parseFloat(arg)\n    } catch (_) {}\n  }\n  return 0\n}\n\nexport function tagHas(tags: Set<string>, tag: string, defaultValue = false) {\n  if (!tags) return defaultValue\n  return tags.has(tag.toLowerCase())\n}\n\nexport function tagFirst(tags?: Set<string>, defaultValue = ''): string {\n  if (tags && tags.size > 0) {\n    for (const tag of tags) {\n      return tag\n    }\n  }\n  return defaultValue\n}\n", "import type { EventCallbackHandler, Modifiers } from '../engine/types'\nimport { tagHas, tagToMs } from './tags'\n\nexport function delay(\n  callback: EventCallbackHandler,\n  wait: number,\n): EventCallbackHandler {\n  return (...args: any[]) => {\n    setTimeout(() => {\n      callback(...args)\n    }, wait)\n  }\n}\n\nexport function debounce(\n  callback: EventCallbackHandler,\n  wait: number,\n  leading = false,\n  trailing = true,\n): EventCallbackHandler {\n  let timer = 0\n  return (...args: any[]) => {\n    timer && clearTimeout(timer)\n\n    if (leading && !timer) {\n      callback(...args)\n    }\n\n    timer = setTimeout(() => {\n      if (trailing) {\n        callback(...args)\n      }\n      timer && clearTimeout(timer)\n    }, wait)\n  }\n}\n\nexport function throttle(\n  callback: EventCallbackHandler,\n  wait: number,\n  leading = true,\n  trailing = false,\n): EventCallbackHandler {\n  let waiting = false\n\n  return (...args: any[]) => {\n    if (waiting) return\n\n    if (leading) {\n      callback(...args)\n    }\n\n    waiting = true\n    setTimeout(() => {\n      waiting = false\n      if (trailing) {\n        callback(...args)\n      }\n    }, wait)\n  }\n}\n\nexport function modifyTiming(\n  callback: EventCallbackHandler,\n  mods: Modifiers,\n): EventCallbackHandler {\n  const delayArgs = mods.get('delay')\n  if (delayArgs) {\n    const wait = tagToMs(delayArgs)\n    callback = delay(callback, wait)\n  }\n\n  const debounceArgs = mods.get('debounce')\n  if (debounceArgs) {\n    const wait = tagToMs(debounceArgs)\n    const leading = tagHas(debounceArgs, 'leading', false)\n    const trailing = !tagHas(debounceArgs, 'notrail', false)\n    callback = debounce(callback, wait, leading, trailing)\n  }\n\n  const throttleArgs = mods.get('throttle')\n  if (throttleArgs) {\n    const wait = tagToMs(throttleArgs)\n    const leading = !tagHas(throttleArgs, 'noleading', false)\n    const trailing = tagHas(throttleArgs, 'trail', false)\n    callback = throttle(callback, wait, leading, trailing)\n  }\n\n  return callback\n}\n", "import type { EventCallbackHandler, Modifiers } from '../engine/types'\n\nexport interface DocumentSupportingViewTransitionAPI {\n  startViewTransition(\n    updateCallback: () => Promise<void> | void,\n  ): IViewTransition\n}\n\nexport interface IViewTransition {\n  finished: Promise<void>\n  ready: Promise<void>\n  updateCallbackDone: Promise<void>\n  skipTransition(): void\n}\n\nexport const supportsViewTransitions = !!document.startViewTransition\n\nexport function modifyViewTransition(\n  callback: EventCallbackHandler,\n  mods: Modifiers,\n): EventCallbackHandler {\n  if (mods.has('viewtransition') && supportsViewTransitions) {\n    const cb = callback // I hate javascript\n    callback = (...args: any[]) =>\n      document.startViewTransition(() => cb(...args))\n  }\n\n  return callback\n}\n", "// Icon: material-symbols:mail\n// Slug: Add an event listener to an element\n// Description: This plugin adds an event listener to an element. The event listener can be triggered by a variety of events, such as clicks, keypresses, and more. The event listener can also be set to trigger only once, or to be passive or capture. The event listener can also be debounced or throttled. The event listener can also be set to trigger only when the event target is outside the element.\n\nimport {\n  type AttributePlugin,\n  DATASTAR_SIGNAL_PATCH_EVENT,\n} from '../../../engine/types'\nimport { kebab, modifyCasing } from '../../../utils/text'\nimport { modifyTiming } from '../../../utils/timing'\nimport { modifyViewTransition } from '../../../utils/view-transitions'\nimport { DATASTAR_SSE_EVENT } from '../backend/shared'\n\nexport const On: AttributePlugin = {\n  type: 'attribute',\n  name: 'on',\n  keyReq: 'must',\n  valReq: 'must',\n  argNames: ['evt'],\n  onLoad: (ctx) => {\n    const { el, key, mods, rx } = ctx\n    let target: Element | Window | Document = el\n    if (mods.has('window')) target = window\n    let callback = (evt?: Event) => {\n      if (evt) {\n        if (mods.has('prevent')) {\n          evt.preventDefault()\n        }\n        if (mods.has('stop')) {\n          evt.stopPropagation()\n        }\n        // Return if not a trusted event, not a custom event and no `trust` modifier exists\n        if (\n          !(evt.isTrusted || evt instanceof CustomEvent || mods.has('trust'))\n        ) {\n          return\n        }\n        ctx.evt = evt\n      }\n      rx(evt)\n    }\n    callback = modifyTiming(callback, mods)\n    callback = modifyViewTransition(callback, mods)\n    const evtListOpts: AddEventListenerOptions = {\n      capture: mods.has('capture'),\n      passive: mods.has('passive'),\n      once: mods.has('once'),\n    }\n    if (mods.has('outside')) {\n      target = document\n      const cb = callback\n      callback = (evt?: Event) => {\n        if (!el.contains(evt?.target as HTMLElement)) {\n          cb(evt)\n        }\n      }\n    }\n    // Default to kebab-case and allow modifying\n    let eventName = kebab(key)\n    eventName = modifyCasing(eventName, mods)\n    // Listen for Datastar events on the document\n    if (\n      eventName === DATASTAR_SSE_EVENT ||\n      eventName === DATASTAR_SIGNAL_PATCH_EVENT\n    ) {\n      target = document\n    }\n    // Prevent default on form submit events\n    if (el instanceof HTMLFormElement && eventName === 'submit') {\n      const cb = callback\n      callback = (evt?: Event) => {\n        evt?.preventDefault()\n        cb(evt)\n      }\n    }\n    target.addEventListener(eventName, callback, evtListOpts)\n    return () => {\n      target.removeEventListener(eventName, callback)\n    }\n  },\n}\n", "// Icon: mdi-light:vector-intersection\n// Slug: Runs an expression when an element intersects with the viewport\n// Description: An attribute that runs an expression when an element intersects with the viewport.\n\nimport type { AttributePlugin, HTMLOrSVG } from '../../../engine/types'\nimport { modifyTiming } from '../../../utils/timing'\nimport { modifyViewTransition } from '../../../utils/view-transitions'\n\nconst once = new WeakSet<HTMLOrSVG>()\n\nexport const OnIntersect: AttributePlugin = {\n  type: 'attribute',\n  name: 'onIntersect',\n  keyReq: 'denied',\n  onLoad: ({ el, mods, rx }) => {\n    let callback = () => rx()\n    callback = modifyTiming(callback, mods)\n    callback = modifyViewTransition(callback, mods)\n    const options = { threshold: 0 }\n    if (mods.has('full')) {\n      options.threshold = 1\n    } else if (mods.has('half')) {\n      options.threshold = 0.5\n    }\n    let observer: IntersectionObserver | null = new IntersectionObserver(\n      (entries) => {\n        for (const entry of entries) {\n          if (entry.isIntersecting) {\n            callback()\n            if (observer && once.has(el)) {\n              observer.disconnect()\n            }\n          }\n        }\n      },\n      options,\n    )\n    observer.observe(el)\n    if (mods.has('once')) {\n      once.add(el)\n    }\n    return () => {\n      if (!mods.has('once')) {\n        once.delete(el)\n      }\n      if (observer) {\n        observer.disconnect()\n        observer = null\n      }\n    }\n  },\n}\n", "// Icon: material-symbols:timer-outline\n// Slug: Runs an expression on an interval\n// Description: This attribute runs an expression on an interval. The interval can be set to a specific duration, and can be set to trigger immediately.\n\nimport type { AttributePlugin } from '../../../engine/types'\nimport { tagHas, tagToMs } from '../../../utils/tags'\nimport { modifyViewTransition } from '../../../utils/view-transitions'\n\nexport const OnInterval: AttributePlugin = {\n  type: 'attribute',\n  name: 'onInterval',\n  keyReq: 'denied',\n  valReq: 'must',\n  onLoad: ({ mods, rx }) => {\n    let callback = () => rx()\n    callback = modifyViewTransition(callback, mods)\n    let duration = 1000\n    const durationArgs = mods.get('duration')\n    if (durationArgs) {\n      duration = tagToMs(durationArgs)\n      const leading = tagHas(durationArgs, 'leading', false)\n      if (leading) {\n        callback()\n      }\n    }\n    const intervalId = setInterval(callback, duration)\n    return () => {\n      clearInterval(intervalId)\n    }\n  },\n}\n", "// Icon: material-symbols:timer-play-outline\n// Slug: Runs an expression when the element is loaded\n// Description: This attribute runs an expression when the element is loaded.\n\nimport type { AttributePlugin } from '../../../engine/types'\nimport { tagToMs } from '../../../utils/tags'\nimport { delay } from '../../../utils/timing'\nimport { modifyViewTransition } from '../../../utils/view-transitions'\n\nexport const OnLoad: AttributePlugin = {\n  type: 'attribute',\n  name: 'onLoad',\n  keyReq: 'denied',\n  valReq: 'must',\n  onLoad: ({ rx, mods, mergePatch }) => {\n    let callback = () => {\n      const result = rx()\n      mergePatch({}) // This will trigger a flush after the rx() call\n      return result\n    }\n    callback = modifyViewTransition(callback, mods)\n    let wait = 0\n    const delayArgs = mods.get('delay')\n    if (delayArgs) {\n      wait = tagToMs(delayArgs)\n    }\n    // Delay the callback regardless of whether the modifier is set so that other plugins are processed first.\n    callback = delay(callback, wait)\n    callback()\n  },\n}\n", "// Icon: mdi:cursor-pointer\n// Slug: Create a reference to an element\n// Description: This attribute creates a reference to an element that can be used in other expressions.\n\nimport type { AttributePlugin } from '../../../engine/types'\nimport { pathToObj } from '../../../utils/paths'\nimport { modifyCasing, modifyScope } from '../../../utils/text'\n\n// Sets the value of the element\nexport const Ref: AttributePlugin = {\n  type: 'attribute',\n  name: 'ref',\n  keyReq: 'exclusive',\n  valReq: 'exclusive',\n  onLoad: ({ el, key, mods, value, mergePatch }) => {\n    let signalName = key ? modifyCasing(key, mods) : value\n    signalName = modifyScope(signalName, el, mods)\n\n    mergePatch(pathToObj({}, { [signalName]: el }))\n  },\n}\n", "// Icon: tabler:box\n// Slug: Create a scope for scoped signals\n// Description: This attribute creates a scope for scoping data to specific DOM elements.\n\nimport type { AttributePlugin } from '../../../engine/types'\nimport { modifyScope } from '../../../utils/text'\n\nexport const Scope: AttributePlugin = {\n  type: 'attribute',\n  name: 'scope',\n  keyReq: 'denied',\n  onLoad: ({ el, value, mods, mergePatch }) => {\n    let scopeKey = value || `_${crypto.randomUUID()}`\n\n    if (el.parentElement) {\n      scopeKey = modifyScope(scopeKey, el.parentElement, mods)\n    }\n\n    const scopeKeyObj = scopeKey\n      .split('.')\n      .reduceRight<any>((acc, part) => ({ [part]: acc }), {})\n    mergePatch(scopeKeyObj)\n\n    el.setAttribute('data-scope', scopeKey)\n    el.removeAttribute('data-scope__scoped')\n\n    return () => {\n      const parts = scopeKey.split('.')\n      const removalObj = parts.reduceRight<any>(\n        (acc, part) => ({ [part]: acc }),\n        null,\n      )\n      mergePatch(removalObj)\n    }\n  },\n}\n", "// Icon: streamline:interface-edit-view-eye-eyeball-open-view\n// Slug: Show or hide an element\n// Description: This attribute shows or hides an element based on the value of the expression. If the expression is true, the element is shown. If the expression is false, the element is hidden. The element is hidden by setting the display property to none.\n\nimport type { AttributePlugin } from '../../../engine/types'\n\nconst NONE = 'none'\nconst DISPLAY = 'display'\n\nexport const Show: AttributePlugin = {\n  type: 'attribute',\n  name: 'show',\n  keyReq: 'denied',\n  valReq: 'must',\n  isExpr: true,\n  onLoad: ({ el, effect, rx }) => {\n    const update = () => {\n      observer.disconnect()\n      const shouldShow = rx()\n      if (shouldShow) {\n        if (el.style.display === NONE) el.style.removeProperty(DISPLAY)\n      } else {\n        el.style.setProperty(DISPLAY, NONE)\n      }\n      observer.observe(el, { attributeFilter: ['style'] })\n    }\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n", "// Icon: tabler:typography\n// Slug: Set the text content of an element\n// Description: This attribute sets the text content of an element to the result of the expression.\n\nimport type { AttributePlugin } from '../../../engine/types'\n\nexport const Text: AttributePlugin = {\n  type: 'attribute',\n  name: 'text',\n  keyReq: 'denied',\n  valReq: 'must',\n  isExpr: true,\n  onLoad: ({ el, effect, rx }) => {\n    const update = () => {\n      observer.disconnect()\n      el.textContent = `${rx()}`\n      observer.observe(el, { childList: true })\n    }\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n", "// Icon: ic:baseline-get-app\n// Slug: Use a GET request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DATASTAR,\n  DATASTAR_REQUEST,\n  DefaultSseRetryDurationMs,\n  EventTypePatchElements,\n  EventTypePatchSignals,\n} from '../../../../engine/consts'\nimport type {\n  HTMLOrSVG,\n  RuntimeContext,\n  SignalFilterOptions,\n} from '../../../../engine/types'\nimport { kebab } from '../../../../utils/text'\nimport {\n  DATASTAR_SSE_EVENT,\n  type DatastarSSEEvent,\n  ERROR,\n  FINISHED,\n  RETRIES_FAILED,\n  RETRYING,\n  STARTED,\n} from '../shared'\n\nconst isWrongContent = (err: any) => `${err}`.includes('text/event-stream')\n\nexport type ContentType = 'json' | 'form'\n\nexport const dispatchSSE = (\n  type: string,\n  el: HTMLOrSVG,\n  argsRaw: Record<string, any>,\n) =>\n  document.dispatchEvent(\n    new CustomEvent<DatastarSSEEvent>(DATASTAR_SSE_EVENT, {\n      detail: { type, el, argsRaw },\n    }),\n  )\n\nexport function setupHeaders(\n  contentType: ContentType,\n  userHeaders?: Record<string, string>,\n): Record<string, string> {\n  const initialHeaders: Record<string, any> = {\n    Accept: 'text/event-stream, text/html, application/json',\n    [DATASTAR_REQUEST]: true,\n  }\n  if (contentType === 'json') {\n    initialHeaders['Content-Type'] = 'application/json'\n  }\n  return Object.assign({}, initialHeaders, userHeaders)\n}\n\ntype ResponseOverrides =\n  | {\n      selector?: string\n      mode?: string\n      useViewTransition?: boolean\n    }\n  | {\n      onlyIfMissing?: boolean\n    }\n\nexport type FetchArgs = {\n  headers?: Record<string, string>\n  openWhenHidden?: boolean\n  retryInterval?: number\n  retryScaler?: number\n  retryMaxWaitMs?: number\n  retryMaxCount?: number\n  abort?: AbortSignal\n  responseOverrides?: ResponseOverrides\n  contentType?: 'json' | 'form'\n  filterSignals?: SignalFilterOptions\n  selector?: string\n}\n\nexport const sse = async (\n  { el, evt, filtered, runtimeErr }: RuntimeContext,\n  method: string,\n  url: string,\n  {\n    selector,\n    headers: userHeaders,\n    contentType = 'json',\n    filterSignals = { include: /.*/, exclude: /(^|\\.)_/ },\n    openWhenHidden = false,\n    retryInterval = DefaultSseRetryDurationMs,\n    retryScaler = 2,\n    retryMaxWaitMs = 30_000,\n    retryMaxCount = 10,\n    abort,\n  }: FetchArgs = {},\n) => {\n  const action = method.toLowerCase()\n  let cleanupFn = () => {}\n\n  try {\n    if (!url?.length) {\n      throw runtimeErr('SseNoUrlProvided', { action })\n    }\n\n    const headers = setupHeaders(contentType, userHeaders)\n    const urlInstance = new URL(url, window.location.href)\n    const queryParams = new URLSearchParams(urlInstance.search)\n\n    let body: string | FormData | URLSearchParams | ReadableStream | null = null\n\n    if (contentType === 'json') {\n      const res = JSON.stringify(filtered(filterSignals))\n      if (method === 'GET') {\n        queryParams.set(DATASTAR, res)\n      } else {\n        body = res\n      }\n    } else if (contentType === 'form') {\n      const formEl = (\n        selector ? document.querySelector(selector) : el.closest('form')\n      ) as HTMLFormElement\n\n      if (!formEl) {\n        throw runtimeErr(selector ? 'FormNotFound' : 'ClosestFormNotFound', {\n          method,\n          selector,\n        })\n      }\n\n      if (!formEl.checkValidity()) {\n        formEl.reportValidity()\n        return\n      }\n\n      const formData = new FormData(formEl)\n      let submitter = el as HTMLElement | null\n\n      if (el === formEl && evt instanceof SubmitEvent) {\n        submitter = evt.submitter\n      } else {\n        const preventDefault = (evt: Event) => evt.preventDefault()\n        formEl.addEventListener('submit', preventDefault)\n        cleanupFn = () => formEl.removeEventListener('submit', preventDefault)\n      }\n\n      if (submitter instanceof HTMLButtonElement) {\n        const name = submitter.getAttribute('name')\n        if (name) formData.append(name, submitter.value)\n      }\n\n      const multipart = formEl.getAttribute('enctype') === 'multipart/form-data'\n      const headers: Record<string, string> = {}\n\n      if (method === 'GET') {\n        const formParams = new URLSearchParams(formData as any)\n        for (const [key, value] of formParams) {\n          queryParams.append(key, value)\n        }\n      } else if (multipart) {\n        body = formData\n      } else {\n        headers['Content-Type'] = 'application/x-www-form-urlencoded'\n        body = new URLSearchParams(formData as any)\n      }\n    } else {\n      throw runtimeErr('SseInvalidContentType', { action, contentType })\n    }\n\n    let duplex: 'half' | undefined\n    // Upload progress events are only available for: HTTPS connections (required for streaming uploads) withMultipart form data uploads\n    if (__USE_UPLOAD_PROGRESS__) {\n      if (urlInstance.protocol === 'https:' && body instanceof FormData) {\n        const boundary = `----FormDataBoundary${Math.random().toString(36).substring(2, 11)}`\n        const encoder = new TextEncoder()\n\n        // Calculate size\n        let total = 0\n        const parts: Array<{ field: string; value: string | File }> = []\n\n        for (const [name, value] of body) {\n          parts.push({ field: name, value })\n          total += encoder.encode(`--${boundary}\\r\\n`).byteLength\n\n          if (value instanceof File) {\n            total += encoder.encode(\n              `Content-Disposition: form-data; name=\"${name}\"; filename=\"${value.name}\"\\r\\n` +\n                `Content-Type: ${value.type || 'application/octet-stream'}\\r\\n\\r\\n`,\n            ).byteLength\n            total += value.size + 2\n          } else {\n            total += encoder.encode(\n              `Content-Disposition: form-data; name=\"${name}\"\\r\\n\\r\\n${value}\\r\\n`,\n            ).byteLength\n          }\n        }\n        total += encoder.encode(`--${boundary}--\\r\\n`).byteLength\n\n        let loaded = 0\n\n        body = new ReadableStream({\n          async start(controller) {\n            const write = (data: Uint8Array) => {\n              controller.enqueue(data)\n              loaded += data.byteLength\n\n              const progress = Math.round((loaded / total) * 100)\n              dispatchSSE('upload-progress', el, {\n                progress,\n                loaded,\n                total,\n              })\n            }\n\n            dispatchSSE('upload-progress', el, {\n              progress: 0,\n              loaded: 0,\n              total: total,\n            })\n\n            try {\n              for (const { field, value } of parts) {\n                write(encoder.encode(`--${boundary}\\r\\n`))\n\n                if (value instanceof File) {\n                  write(\n                    encoder.encode(\n                      `Content-Disposition: form-data; name=\"${field}\"; filename=\"${value.name}\"\\r\\n` +\n                        `Content-Type: ${value.type || 'application/octet-stream'}\\r\\n\\r\\n`,\n                    ),\n                  )\n\n                  const reader = value.stream().getReader()\n                  try {\n                    while (true) {\n                      const { done, value: chunk } = await reader.read()\n                      if (done) break\n                      write(chunk)\n                    }\n                  } finally {\n                    reader.releaseLock()\n                  }\n                  write(encoder.encode('\\r\\n'))\n                } else {\n                  write(\n                    encoder.encode(\n                      `Content-Disposition: form-data; name=\"${field}\"\\r\\n\\r\\n${value}\\r\\n`,\n                    ),\n                  )\n                }\n              }\n\n              write(encoder.encode(`--${boundary}--\\r\\n`))\n\n              if (loaded < total) {\n                dispatchSSE('upload-progress', el, {\n                  progress: 100,\n                  loaded: total,\n                  total,\n                })\n              }\n\n              controller.close()\n            } catch (error) {\n              controller.error(error)\n            }\n          },\n        })\n        duplex = 'half'\n\n        Object.assign(headers, {\n          'Content-Type': `multipart/form-data; boundary=${boundary}`,\n        })\n      }\n    }\n\n    dispatchSSE(STARTED, el, {})\n    urlInstance.search = queryParams.toString()\n\n    try {\n      await performSSERequest(urlInstance.toString(), el, {\n        method,\n        headers,\n        body,\n        signal: abort,\n        openWhenHidden,\n        retryInterval,\n        retryScaler,\n        retryMaxWaitMs,\n        retryMaxCount,\n        duplex,\n      })\n    } catch (error) {\n      if (!isWrongContent(error)) {\n        throw runtimeErr('SseFetchFailed', { method, url, error })\n      }\n    }\n  } finally {\n    dispatchSSE(FINISHED, el, {})\n    cleanupFn()\n  }\n}\n\nasync function performSSERequest(\n  url: string,\n  el: HTMLOrSVG,\n  options: RequestInit & {\n    headers: Record<string, string>\n    openWhenHidden?: boolean\n    retryInterval?: number\n    retryScaler?: number\n    retryMaxWaitMs?: number\n    retryMaxCount?: number\n    duplex?: 'half'\n  },\n) {\n  const {\n    signal,\n    openWhenHidden = false,\n    retryInterval = 1000,\n    retryScaler = 2,\n    retryMaxWaitMs = 30000,\n    retryMaxCount = 10,\n    ...fetchOptions\n  } = options\n  let retries = 0\n  let currentRetryInterval = retryInterval\n  let controller = new AbortController()\n\n  const visibilityHandler = () => {\n    if (document.hidden && !openWhenHidden) {\n      controller.abort()\n    }\n  }\n  document.addEventListener('visibilitychange', visibilityHandler)\n\n  const cleanup = () => {\n    document.removeEventListener('visibilitychange', visibilityHandler)\n    controller.abort()\n  }\n\n  signal?.addEventListener('abort', cleanup)\n\n  async function attempt(): Promise<void> {\n    controller = new AbortController()\n\n    try {\n      const response = await fetch(url, {\n        ...fetchOptions,\n        signal: controller.signal,\n      })\n\n      if (response.status >= 400) {\n        dispatchSSE(ERROR, el, { status: response.status.toString() })\n      }\n\n      retries = 0\n      currentRetryInterval = retryInterval\n\n      const ct = response.headers.get('Content-Type')\n\n      // Handle non-SSE responses\n      if (ct?.includes('text/html')) {\n        const html = await response.text()\n        const argsRaw: Record<string, string> = { elements: html }\n        for (const key of ['selector', 'mode', 'useViewTransition']) {\n          const value = response.headers.get(`datastar-${kebab(key)}`)\n          if (value) argsRaw[key] = value\n        }\n        dispatchSSE(EventTypePatchElements, el, argsRaw)\n      } else if (ct?.includes('application/json')) {\n        const json = await response.text()\n        const argsRaw: Record<string, string> = { signals: json }\n        for (const key of ['onlyIfMissing', 'mode', 'useViewTransition']) {\n          const value = response.headers.get(`datastar-${kebab(key)}`)\n          if (value) argsRaw[key] = value\n        }\n        dispatchSSE(EventTypePatchSignals, el, argsRaw)\n      } else if (ct?.includes('text/javascript')) {\n        const script = document.createElement('script')\n        const scriptAttributesHeader = response.headers.get(\n          'datastar-script-attributes',\n        )\n\n        if (scriptAttributesHeader) {\n          for (const [name, value] of Object.entries(\n            JSON.parse(scriptAttributesHeader),\n          )) {\n            script.setAttribute(name, value as string)\n          }\n        }\n        script.textContent = await response.text()\n        document.head.appendChild(script)\n      } else {\n        // Handle SSE stream\n        await processSSEStream(response, el, (retry) => {\n          currentRetryInterval = retry\n        })\n      }\n\n      cleanup()\n    } catch (err) {\n      if (!controller.signal.aborted) {\n        if (++retries >= retryMaxCount) {\n          dispatchSSE(RETRIES_FAILED, el, {})\n          cleanup()\n          throw new Error('Max retries reached')\n        }\n\n        dispatchSSE(RETRYING, el, { message: `${err}` })\n        currentRetryInterval = Math.min(\n          currentRetryInterval * retryScaler,\n          retryMaxWaitMs,\n        )\n\n        await new Promise((resolve) =>\n          setTimeout(resolve, currentRetryInterval),\n        )\n        return attempt()\n      }\n    }\n  }\n\n  return attempt()\n}\n\nasync function processSSEStream(\n  response: Response,\n  el: HTMLOrSVG,\n  onRetry: (retry: number) => void,\n) {\n  const reader = response.body!.getReader()\n  const decoder = new TextDecoder()\n  let buffer = ''\n\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) break\n\n    buffer += decoder.decode(value, { stream: true })\n    const lines = buffer.split('\\n')\n    buffer = lines.pop() || ''\n\n    let lineIndex = 0\n    while (lineIndex < lines.length) {\n      // Process SSE messages - collect lines until empty line\n      let currentEvent = ''\n      const dataLines: string[] = []\n      let retry: number | undefined\n\n      // Collect all lines for this message until empty line\n      while (lineIndex < lines.length && lines[lineIndex].length > 0) {\n        const line = lines[lineIndex]\n\n        if (line.startsWith('event:')) {\n          currentEvent = line.slice(6).trimStart()\n        } else if (line.startsWith('data:')) {\n          dataLines.push(line.slice(5).trimStart())\n        } else if (line.startsWith('retry:')) {\n          const retryValue = Number.parseInt(line.slice(6).trimStart())\n          if (!Number.isNaN(retryValue)) retry = retryValue\n        }\n        // Ignore other fields like id:, or lines without colons\n\n        lineIndex++\n      }\n\n      // Process the collected message if it's a datastar event with data\n      if (currentEvent.includes(DATASTAR) && dataLines.length > 0) {\n        const argsRaw: Record<string, string[]> = {}\n\n        // Collect all values for each key\n        for (const dataLine of dataLines) {\n          const spaceIndex = dataLine.indexOf(' ')\n          if (spaceIndex > 0) {\n            const key = dataLine.slice(0, spaceIndex)\n            const value = dataLine.slice(spaceIndex + 1)\n            if (!argsRaw[key]) {\n              argsRaw[key] = []\n            }\n            argsRaw[key].push(value)\n          }\n        }\n\n        // Join multi-line values with newlines\n        const argsRawJoined: Record<string, string> = {}\n        for (const [key, values] of Object.entries(argsRaw)) {\n          argsRawJoined[key] = values.join('\\n')\n        }\n\n        dispatchSSE(currentEvent, el, argsRawJoined)\n      }\n\n      // Handle retry if present\n      if (retry !== undefined) {\n        onRetry(retry)\n      }\n\n      // Skip the empty line\n      lineIndex++\n    }\n  }\n}\n", "// Factory for creating HTTP method action plugins\nimport type { ActionPlugin } from '../../../../engine/types'\nimport { type FetchArgs, sse } from './fetch'\n\n// Helper to create HTTP method plugins with consistent structure\nexport const createHttpMethod = (\n  name: string,\n  method: string,\n): ActionPlugin => ({\n  type: 'action',\n  name,\n  fn: (ctx, url: string, args: FetchArgs) => sse(ctx, method, url, args),\n})\n", "// Icon: material-symbols:delete-outline\n// Slug: Use a DELETE request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { createHttpMethod } from './httpMethods'\n\nexport const DELETE = createHttpMethod('delete', 'DELETE')\n", "// Icon: ic:baseline-get-app\n// Slug: Use a GET request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { createHttpMethod } from './httpMethods'\n\nexport const GET = createHttpMethod('get', 'GET')\n", "// Icon: fluent:patch-24-filled\n// Slug: Use a PATCH request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { createHttpMethod } from './httpMethods'\n\nexport const PATCH = createHttpMethod('patch', 'PATCH')\n", "// Icon: ri:signpost-fill\n// Slug: Use a POST request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { createHttpMethod } from './httpMethods'\n\nexport const POST = createHttpMethod('post', 'POST')\n", "// Icon: material-symbols:arrows-input\n// Slug: Use a PUT request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { createHttpMethod } from './httpMethods'\n\nexport const PUT = createHttpMethod('put', 'PUT')\n", "// Icon: material-symbols:cloud-download\n// Slug: Patch elements into the DOM using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DefaultElementPatchMode,\n  ElementPatchModeAfter,\n  ElementPatchModeAppend,\n  ElementPatchModeBefore,\n  ElementPatchModeInner,\n  ElementPatchModeOuter,\n  ElementPatchModePrepend,\n  ElementPatchModeRemove,\n  ElementPatchModeReplace,\n  EventTypePatchElements,\n} from '../../../../engine/consts'\nimport { aliasify } from '../../../../engine/engine'\nimport { initErr } from '../../../../engine/errors'\nimport type {\n  HTMLOrSVG,\n  InitContext,\n  WatcherPlugin,\n} from '../../../../engine/types'\nimport { kebab } from '../../../../utils/text'\nimport { supportsViewTransitions } from '../../../../utils/view-transitions'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const PatchElements: WatcherPlugin = {\n  type: 'watcher',\n  name: EventTypePatchElements,\n  async onGlobalInit(ctx) {\n    datastarSSEEventWatcher(EventTypePatchElements, (args) =>\n      onPatchElements(ctx, args),\n    )\n  },\n}\n\nfunction onPatchElements(\n  ctx: InitContext,\n  {\n    elements,\n    selector,\n    mode = DefaultElementPatchMode,\n    useViewTransition,\n  }: Record<string, string>,\n) {\n  const template = document.createElement('template')\n  template.innerHTML = elements\n\n  for (const node of [...template.content.childNodes]) {\n    const type = node.nodeType\n    if (type !== 1) {\n      if (type === 3 && !node.nodeValue!.trim()) {\n        continue\n      }\n      throw initErr('NoElementsFound', ctx)\n    }\n\n    const selectorOrId = selector || `#${(node as Element).id}`\n    const targets = document.querySelectorAll(selectorOrId)\n    if (!targets.length) {\n      throw initErr('NoTargetsFound', ctx, {\n        selectorOrId,\n      })\n    }\n\n    if (useViewTransition && supportsViewTransitions) {\n      document.startViewTransition(() =>\n        applyToTargets(ctx, mode, node as HTMLOrSVG, targets),\n      )\n    } else {\n      applyToTargets(ctx, mode, node as HTMLOrSVG, targets)\n    }\n  }\n}\n\nfunction applyToTargets(\n  ctx: InitContext,\n  mode: string,\n  element: HTMLOrSVG,\n  capturedTargets: NodeListOf<Element>,\n) {\n  for (const target of capturedTargets) {\n    if (mode === ElementPatchModeRemove) {\n      target.remove()\n    } else if (\n      mode === ElementPatchModeOuter ||\n      mode === ElementPatchModeInner\n    ) {\n      morph(target, element, mode)\n    } else {\n      const cloned = element.cloneNode(true) as Element\n      if (mode === ElementPatchModeReplace) {\n        target.replaceWith(cloned)\n      } else if (mode === ElementPatchModePrepend) {\n        target.prepend(cloned)\n      } else if (mode === ElementPatchModeAppend) {\n        target.append(cloned)\n      } else if (mode === ElementPatchModeBefore) {\n        target.before(cloned)\n      } else if (mode === ElementPatchModeAfter) {\n        target.after(cloned)\n      } else {\n        throw initErr('InvalidPatchMode', ctx, { mode })\n      }\n    }\n\n    const elScripts =\n      target instanceof HTMLScriptElement\n        ? [target]\n        : target.querySelectorAll('script')\n    for (const old of elScripts) {\n      const script = document.createElement('script')\n      for (const { name, value } of old.attributes) {\n        script.setAttribute(name, value)\n      }\n      script.text = old.text\n      old.replaceWith(script)\n    }\n  }\n}\n\nconst oldIdTagNameMap = new Map<string, string>()\nconst ctxIdMap = new Map<Node, Set<string>>()\nconst ctxPersistentIds = new Set<string>()\nconst duplicateIds = new Set<string>()\nconst ctxPantry = document.createElement('div')\nctxPantry.hidden = true\n\nfunction morph(\n  oldElt: Element,\n  newElt: Element,\n  mode: typeof ElementPatchModeInner | typeof ElementPatchModeOuter,\n): void {\n  const ignore = aliasify('ignore-morph')\n  if (\n    (oldElt.hasAttribute(ignore) && newElt.hasAttribute(ignore)) ||\n    oldElt.parentElement?.closest(`[${ignore}]`)\n  ) {\n    return\n  }\n\n  const normalizedElt = document.createElement('div')\n  normalizedElt.append(newElt as Element)\n  document.body.insertAdjacentElement('afterend', ctxPantry)\n\n  // Computes the set of ids that persist between the two contents excluding duplicates\n  const oldIdElements = oldElt.querySelectorAll('[id]')\n  for (const { id, tagName } of oldIdElements) {\n    if (oldIdTagNameMap.has(id)) {\n      duplicateIds.add(id)\n    } else {\n      oldIdTagNameMap.set(id, tagName)\n    }\n  }\n  if (oldElt.id) {\n    if (oldIdTagNameMap.has(oldElt.id)) {\n      duplicateIds.add(oldElt.id)\n    } else {\n      oldIdTagNameMap.set(oldElt.id, oldElt.tagName)\n    }\n  }\n\n  ctxPersistentIds.clear()\n  const newIdElements = normalizedElt.querySelectorAll('[id]')\n  for (const { id, tagName } of newIdElements) {\n    if (ctxPersistentIds.has(id)) {\n      duplicateIds.add(id)\n    } else if (oldIdTagNameMap.get(id) === tagName) {\n      ctxPersistentIds.add(id)\n    }\n  }\n\n  oldIdTagNameMap.clear()\n\n  for (const id of duplicateIds) {\n    ctxPersistentIds.delete(id)\n  }\n\n  duplicateIds.clear()\n\n  // Computes a map of nodes to all ids contained within that node (inclusive of the node).\n  // This map can be used to ask if two nodes have intersecting sets of ids,\n  // which allows for a looser definition of \"matching\" than tradition id matching,\n  // and allows child nodes to contribute to a parent nodes matching.\n  // const idMap = new Map<Node, Set<string>>()\n  ctxIdMap.clear()\n\n  populateIdMapWithTree(\n    mode === 'outer' ? oldElt.parentElement! : oldElt,\n    oldIdElements,\n  )\n  populateIdMapWithTree(normalizedElt, newIdElements)\n\n  morphChildren(\n    mode === 'outer' ? oldElt.parentElement! : oldElt,\n    normalizedElt,\n    mode === 'outer' ? (oldElt as Node) : null,\n    oldElt.nextSibling,\n  )\n\n  ctxPantry.remove()\n}\n\n// This is the core algorithm for matching up children.\n// The idea is to use id sets to try to match up nodes as faithfully as possible.\n// We greedily match, which allows us to keep the algorithm fast,\n// but by using id sets, we are able to better match up with content deeper in the DOM.\nfunction morphChildren(\n  oldParent: Element, // the old content that we are merging the new content into\n  newParent: Element, // the parent element of the new content\n  insertionPoint: Node | null = null, // // the point in the DOM we start morphing at (defaults to first child)\n  endPoint: Node | null = null, // the point in the DOM we stop morphing at (defaults to after last child)\n): void {\n  // normalize\n  if (\n    oldParent instanceof HTMLTemplateElement &&\n    newParent instanceof HTMLTemplateElement\n  ) {\n    // we can pretend the DocumentElement is an Element\n    oldParent = oldParent.content as unknown as Element\n    newParent = newParent.content as unknown as Element\n  }\n  insertionPoint ??= oldParent.firstChild\n\n  // run through all the new content\n  for (const newChild of newParent.childNodes) {\n    // once we reach the end of the old parent content skip to the end and insert the rest\n    if (insertionPoint && insertionPoint !== endPoint) {\n      const bestMatch = findBestMatch(newChild, insertionPoint, endPoint)\n      if (bestMatch) {\n        // if the node to morph is not at the insertion point then remove/move up to it\n        if (bestMatch !== insertionPoint) {\n          let cursor: Node | null = insertionPoint\n          // Remove nodes between the start and end nodes\n          while (cursor && cursor !== bestMatch) {\n            const tempNode = cursor\n            cursor = cursor.nextSibling\n            removeNode(tempNode)\n          }\n        }\n        morphNode(bestMatch, newChild)\n        insertionPoint = bestMatch.nextSibling\n        continue\n      }\n    }\n\n    // @ts-ignore\n    const ncId = newChild.id\n    // if the matching node is elsewhere in the original content\n    if (newChild instanceof Element && ctxPersistentIds.has(ncId)) {\n      // move it and all its children here and morph, will always be found\n      // Search for an element by id within the document and pantry, and move it using moveBefore.\n\n      const movedChild = window[ncId] as unknown as Element\n\n      // Removes an element from its ancestors' id maps.\n      // This is needed when an element is moved from the \"future\" via `moveBeforeId`.\n      // Otherwise, its erstwhile ancestors could be mistakenly moved to the pantry rather than being deleted,\n      // preventing their removal hooks from being called.\n      let current = movedChild\n      while ((current = current.parentNode as Element)) {\n        const idSet = ctxIdMap.get(current)\n        if (idSet) {\n          idSet.delete(ncId)\n          if (!idSet.size) {\n            ctxIdMap.delete(current)\n          }\n        }\n      }\n\n      moveBefore(oldParent, movedChild, insertionPoint)\n      morphNode(movedChild, newChild)\n      insertionPoint = movedChild.nextSibling\n      continue\n    }\n\n    // This performs the action of inserting a new node while handling situations where the node contains\n    // elements with persistent ids and possible state info we can still preserve by moving in and then morphing\n    if (ctxIdMap.has(newChild)) {\n      // node has children with ids with possible state so create a dummy elt of same type and apply full morph algorithm\n      const newEmptyChild = document.createElement(\n        (newChild as Element).tagName,\n      )\n      oldParent.insertBefore(newEmptyChild, insertionPoint)\n      morphNode(newEmptyChild, newChild)\n      insertionPoint = newEmptyChild.nextSibling\n    } else {\n      // optimization: no id state to preserve so we can just insert a clone of the newChild and its descendants\n      const newClonedChild = document.importNode(newChild, true) // importNode to not mutate newParent\n      oldParent.insertBefore(newClonedChild, insertionPoint)\n      insertionPoint = newClonedChild.nextSibling\n    }\n  }\n\n  // remove any remaining old nodes that didn't match up with new content\n  while (insertionPoint && insertionPoint !== endPoint) {\n    const tempNode = insertionPoint\n    insertionPoint = insertionPoint.nextSibling\n    removeNode(tempNode)\n  }\n}\n\n// Scans forward from the startPoint to the endPoint looking for a match for the node.\n// It looks for an id set match first, then a soft match.\n// We abort soft matching if we find two future soft matches, to reduce churn.\nfunction findBestMatch(\n  node: Node,\n  startPoint: Node | null,\n  endPoint: Node | null,\n): Node | null {\n  let bestMatch = null\n  let nextSibling = node.nextSibling\n  let siblingSoftMatchCount = 0\n  let displaceMatchCount = 0\n\n  // max id matches we are willing to displace in our search\n  const nodeMatchCount = ctxIdMap.get(node)?.size || 0\n\n  let cursor = startPoint\n  while (cursor && cursor !== endPoint) {\n    // soft matching is a prerequisite for id set matching\n    if (isSoftMatch(cursor, node)) {\n      let isIdSetMatch = false\n      const oldSet = ctxIdMap.get(cursor)\n      const newSet = ctxIdMap.get(node)\n\n      if (newSet && oldSet) {\n        for (const id of oldSet) {\n          // a potential match is an id in the new and old nodes that\n          // has not already been merged into the DOM\n          // But the newNode content we call this on has not been\n          // merged yet and we don't allow duplicate IDs so it is simple\n          if (newSet.has(id)) {\n            isIdSetMatch = true\n            break\n          }\n        }\n      }\n\n      if (isIdSetMatch) {\n        return cursor // found an id set match, we're done!\n      }\n\n      // we haven't yet saved a soft match fallback\n      // the current soft match will hard match something else in the future, leave it\n      if (!bestMatch && !ctxIdMap.has(cursor)) {\n        // optimization: if node can't id set match, we can just return the soft match immediately\n        if (!nodeMatchCount) {\n          return cursor\n        }\n        // save this as the fallback if we get through the loop without finding a hard match\n        bestMatch = cursor\n      }\n    }\n    // check for ids we may be displaced when matching\n    displaceMatchCount += ctxIdMap.get(cursor)?.size || 0\n    if (displaceMatchCount > nodeMatchCount) {\n      // if we are going to displace more ids than the node contains then\n      // we do not have a good candidate for an id match, so return\n      break\n    }\n\n    if (bestMatch === null && nextSibling && isSoftMatch(cursor, nextSibling)) {\n      // The next new node has a soft match with this node, so\n      // increment the count of future soft matches\n      siblingSoftMatchCount++\n      nextSibling = nextSibling.nextSibling\n\n      // If there are two future soft matches, block soft matching for this node to allow\n      // future siblings to soft match. This is to reduce churn in the DOM when an element\n      // is prepended.\n      if (siblingSoftMatchCount >= 2) {\n        bestMatch = undefined\n      }\n    }\n\n    // if the current node contains active element, stop looking for better future matches,\n    // because if one is found, this node will be moved to the pantry, re-parenting it and thus losing focus\n    if (cursor.contains(document.activeElement)) break\n\n    cursor = cursor.nextSibling\n  }\n\n  return bestMatch || null\n}\n\nfunction isSoftMatch(oldNode: Node, newNode: Node): boolean {\n  // ok to cast: if one is not element, `id` and `tagName` will be null and we'll just compare that.\n  const oldId = (oldNode as Element).id\n  return (\n    oldNode.nodeType === newNode.nodeType &&\n    (oldNode as Element).tagName === (newNode as Element).tagName &&\n    // If oldElt has an `id` with possible state and it doesn't match newElt.id then avoid morphing.\n    // We'll still match an anonymous node with an IDed newElt, though, because if it got this far,\n    // its not persistent, and new nodes can't have any hidden state.\n    (!oldId || oldId === (newNode as Element).id)\n  )\n}\n\n// Gets rid of an unwanted DOM node; strategy depends on nature of its reuse:\n// - Persistent nodes will be moved to the pantry for later reuse\n// - Other nodes will have their hooks called, and then are removed\nfunction removeNode(node: Node) {\n  // are we going to id set match this later?\n  if (ctxIdMap.has(node)) {\n    // skip callbacks and move to pantry\n    moveBefore(ctxPantry, node, null)\n  } else {\n    // remove for realsies\n    node.parentNode?.removeChild(node)\n  }\n}\n\n// Moves an element before another element within the same parent.\n// Uses the proposed `moveBefore` API if available (and working), otherwise falls back to `insertBefore`.\n// This is essentially a forward-compat wrapper.\nconst moveBefore: (parentNode: Node, node: Node, after: Node | null) => void =\n  // @ts-ignore\n  removeNode.call.bind(ctxPantry.moveBefore ?? ctxPantry.insertBefore)\n\nfunction morphNode(\n  oldNode: Node, // root node to merge content into\n  newNode: Node, // new content to merge\n): Node {\n  // syncs the oldNode to the newNode, copying over all attributes and\n  // inner element state from the newNode to the oldNode\n  const type = newNode.nodeType\n\n  // if is an element type, sync the attributes from the\n  // new node into the new node\n  if (type === 1 /* element type */) {\n    const ignore = aliasify('ignore-morph')\n    if (\n      (oldNode as Element).hasAttribute(ignore) &&\n      (newNode as Element).hasAttribute(ignore)\n    ) {\n      return oldNode\n    }\n\n    const preserveAttrs = (newNode as HTMLElement)\n      .getAttribute(aliasify('preserve-attr'))\n      ?.split(' ')\n\n    for (const { name, value } of (newNode as Element).attributes) {\n      // @ts-ignore\n      if (\n        (oldNode as Element).getAttribute(name) !== value &&\n        !preserveAttrs?.includes(kebab(name))\n      ) {\n        ;(oldNode as Element).setAttribute(name, value)\n      }\n    }\n\n    const oldAttrs = (oldNode as Element).attributes\n    for (let i = oldAttrs.length - 1; i >= 0; i--) {\n      const { name } = oldAttrs[i]\n      if (\n        !(newNode as Element).hasAttribute(name) &&\n        !preserveAttrs?.includes(kebab(name))\n      ) {\n        ;(oldNode as Element).removeAttribute(name)\n      }\n    }\n\n    //  many bothans died to bring us information:\n    //  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n    //  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n    if (\n      oldNode instanceof HTMLInputElement &&\n      newNode instanceof HTMLInputElement &&\n      newNode.type !== 'file'\n    ) {\n      const bind = aliasify('bind').slice(5)\n      let noBind = true\n      for (const key in newNode.dataset) {\n        if (key.startsWith(bind)) {\n          noBind = false\n          break\n        }\n      }\n      if (noBind) {\n        const newValue = newNode.value\n        if (!newNode.hasAttribute('value')) {\n          oldNode.value = ''\n          oldNode.removeAttribute('value')\n        } else if (oldNode.value !== newValue) {\n          oldNode.setAttribute('value', newValue)\n          oldNode.value = newValue\n        }\n      }\n    } else if (\n      oldNode instanceof HTMLTextAreaElement &&\n      newNode instanceof HTMLTextAreaElement\n    ) {\n      const newValue = newNode.value\n      if (newValue !== oldNode.value) {\n        oldNode.value = newValue\n      }\n      if (oldNode.firstChild && oldNode.firstChild.nodeValue !== newValue) {\n        oldNode.firstChild.nodeValue = newValue\n      }\n    }\n  }\n\n  if (type === 8 /* comment */ || type === 3 /* text */) {\n    if (oldNode.nodeValue !== newNode.nodeValue) {\n      oldNode.nodeValue = newNode.nodeValue\n    }\n  }\n\n  if (!oldNode.isEqualNode(newNode)) {\n    morphChildren(oldNode as Element, newNode as Element)\n  }\n  return oldNode\n}\n\n// A bottom-up algorithm that populates a map of Element -> IdSet.\n// The idSet for a given element is the set of all IDs contained within its subtree.\n// As an optimization, we filter these IDs through the given list of persistent IDs,\n// because we don't need to bother considering IDed elements that won't be in the new content.\nfunction populateIdMapWithTree(\n  root: Element | null,\n  elements: Element[] | NodeListOf<Element>,\n) {\n  for (const elt of elements) {\n    if (ctxPersistentIds.has(elt.id)) {\n      let current: Element | null = elt\n      // walk up the parent hierarchy of that element, adding the id of element to the parent's id set\n      while (current && current !== root) {\n        let idSet = ctxIdMap.get(current)\n        // if the id set doesn't exist, create it and insert it in the map\n        if (!idSet) {\n          idSet = new Set()\n          ctxIdMap.set(current, idSet)\n        }\n        idSet.add(elt.id)\n        current = current.parentElement\n      }\n    }\n  }\n}\n", "// Icon: material-symbols:settings-input-antenna\n// Slug: Patch signals using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DefaultPatchSignalsOnlyIfMissing,\n  EventTypePatchSignals,\n} from '../../../../engine/consts'\nimport type { WatcherPlugin } from '../../../../engine/types'\nimport { isBoolString, jsStrToObject } from '../../../../utils/text'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const PatchSignals: WatcherPlugin = {\n  type: 'watcher',\n  name: EventTypePatchSignals,\n  onGlobalInit: (ctx) =>\n    datastarSSEEventWatcher(\n      EventTypePatchSignals,\n      ({\n        signals: raw = '{}',\n        onlyIfMissing: onlyIfMissingRaw = `${DefaultPatchSignalsOnlyIfMissing}`,\n      }) =>\n        ctx.mergePatch(jsStrToObject(raw), {\n          ifMissing: isBoolString(onlyIfMissingRaw),\n        }),\n    ),\n}\n", "import { apply, load, setAlias } from '../engine'\nimport { Peek } from '../plugins/framework/actions/peek'\nimport { SetAll } from '../plugins/framework/actions/setAll'\nimport { ToggleAll } from '../plugins/framework/actions/toggleAll'\nimport { Attr } from '../plugins/framework/attributes/attr'\nimport { Bind } from '../plugins/framework/attributes/bind'\nimport { Class } from '../plugins/framework/attributes/class'\nimport { Indicator } from '../plugins/framework/attributes/indicator'\nimport { JsonSignals } from '../plugins/framework/attributes/jsonSignals'\nimport { On } from '../plugins/framework/attributes/on'\nimport { OnIntersect } from '../plugins/framework/attributes/onIntersect'\nimport { OnInterval } from '../plugins/framework/attributes/onInterval'\nimport { OnLoad } from '../plugins/framework/attributes/onLoad'\nimport { Ref } from '../plugins/framework/attributes/ref'\nimport { Scope } from '../plugins/framework/attributes/scope'\nimport { Show } from '../plugins/framework/attributes/show'\nimport { Text } from '../plugins/framework/attributes/text'\nimport { DELETE } from '../plugins/framework/backend/actions/delete'\nimport { GET } from '../plugins/framework/backend/actions/get'\nimport { PATCH } from '../plugins/framework/backend/actions/patch'\nimport { POST } from '../plugins/framework/backend/actions/post'\nimport { PUT } from '../plugins/framework/backend/actions/put'\nimport { PatchElements } from '../plugins/framework/backend/watchers/patchElements'\nimport { PatchSignals } from '../plugins/framework/backend/watchers/patchSignals'\n\nsetAlias('star')\n\nload(\n  // Backend\n  GET,\n  POST,\n  PUT,\n  PATCH,\n  DELETE,\n  PatchElements,\n  PatchSignals,\n  // Attributes\n  Attr,\n  Bind,\n  Class,\n  Indicator,\n  JsonSignals,\n  On,\n  OnIntersect,\n  OnInterval,\n  OnLoad,\n  Ref,\n  Scope,\n  Show,\n  Text,\n  // Actions\n  Peek,\n  SetAll,\n  ToggleAll,\n)\n\napply()\n\nexport { apply, load, setAlias }\n"],
  "mappings": "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",
  "names": ["lol", "DSP", "DSS", "DATASTAR", "DATASTAR_REQUEST", "DefaultSseRetryDurationMs", "DefaultPatchSignalsOnlyIfMissing", "ElementPatchModeOuter", "ElementPatchModeInner", "ElementPatchModeRemove", "ElementPatchModeReplace", "ElementPatchModePrepend", "ElementPatchModeAppend", "ElementPatchModeBefore", "ElementPatchModeAfter", "DefaultElementPatchMode", "EventTypePatchElements", "EventTypePatchSignals", "isPojo", "obj", "isEmpty", "prop", "updateLeaves", "fn", "key", "val", "pathToObj", "target", "paths", "path", "keys", "lastKey", "acc", "isHTMLOrSVG", "el", "findClosestScoped", "isBoolString", "str", "kebab", "camel", "x", "snake", "pascal", "jsStrToObject", "raw", "caseFns", "modifyCasing", "mods", "c", "fn", "modifyScope", "signalName", "el", "scope", "findClosestScoped", "Computed", "el", "key", "mods", "rx", "computed", "mergePatch", "signalName", "modifyCasing", "modifyScope", "pathToObj", "Effect", "effect", "rx", "Signals", "el", "key", "mods", "rx", "mergePatch", "ifMissing", "modifyScope", "modifyCasing", "pathToObj", "patch", "pathObj", "url", "dserr", "type", "reason", "metadata", "e", "DATASTAR", "snake", "q", "c", "initErr", "reason", "ctx", "metadata", "errCtx", "dserr", "runtimeErr", "DATASTAR_SIGNAL_PATCH_EVENT", "DATASTAR", "currentPatch", "queuedEffects", "batchDepth", "notifyIndex", "queuedEffectsLength", "activeSub", "startBatch", "endBatch", "flush", "dispatch", "signal", "initialValue", "signalOper", "value_", "flags_", "computedSymbol", "computed", "getter", "c", "computedOper", "effect", "fn", "e", "fn_", "link", "prev", "setCurrentSub", "effectOper", "peek", "run", "update", "updateComputed", "updateSignal", "sub", "prevSub", "startTracking", "oldValue", "endTracking", "s", "value", "notify", "flags", "subs", "subs_", "sub_", "checkDirty", "deps_", "dep", "dep_", "depFlags", "nextDep_", "shallowPropagate", "newValue", "propagate", "currentValue", "unlink", "prevDep", "depsTail_", "nextDep", "recursedCheck", "subsTail_", "isValidLink", "newLink", "prevDep_", "prevSub_", "nextSub_", "toRemove", "next", "stack", "top", "subSubs", "prev_", "checkDepth", "dirty", "firstSub", "hasMultipleSubs", "nextSub", "subFlags", "checkLink", "depsTail", "getPath", "path", "acc", "key", "root", "hasPath", "obj", "deep", "prefix", "isArr", "isPojo", "deepObj", "keys", "_", "prop", "pathToObj", "isEmpty", "oldPatch", "DATASTAR_SIGNAL_PATCH_EVENT", "mergePatch", "patch", "ifMissing", "mergeInner", "target", "targetParent", "filtered", "include", "exclude", "pathObj", "node", "actions", "plugins", "pluginRegexs", "removals", "mutationObserver", "alias", "setAlias", "aliasify", "name", "load", "pluginsToLoad", "plugin", "ctx", "initErr", "a", "b", "lenDiff", "applyEls", "els", "el", "applyAttributePlugin", "apply", "observe", "attrKey", "rawKey", "camel", "i", "rawModifiers", "hasKey", "hasValue", "runtimeErr", "generateReactiveExpression", "keyReq", "valReq", "rawMod", "label", "mod", "t", "cleanup", "cleanups", "mutations", "ignore", "type", "attributeName", "addedNodes", "removedNodes", "isHTMLOrSVG", "expr", "attrPlugin", "statementRe", "statements", "lastIdx", "last", "scope", "findClosestScoped", "match", "signalName", "part", "escaped", "escapeRe", "DSP", "DSS", "k", "v", "djb2", "nameGen", "snake", "actionsCalled", "actionsRe", "actionMatches", "actionNames", "actionFns", "actionPrefix", "DATASTAR", "actionName", "action", "args", "error", "str", "hash", "load", "Signals", "Computed", "Effect", "Peek", "peek", "fn", "SetAll", "filtered", "mergePatch", "peek", "value", "filter", "masked", "updateLeaves", "ToggleAll", "filtered", "mergePatch", "peek", "filter", "masked", "updateLeaves", "oldValue", "Attr", "el", "effect", "key", "rx", "syncAttr", "val", "observer", "obj", "cleanup", "k", "kebab", "value", "dataURIRegex", "textType", "numberType", "Bind", "el", "key", "mods", "value", "effect", "mergePatch", "runtimeErr", "getPath", "hasPath", "signalName", "modifyCasing", "modifyScope", "scopedModifier", "allBoundInputs", "aliasify", "inputIndex", "pathObj", "input", "pathToObj", "syncSignal", "cleanup", "val", "files", "allContents", "allMimes", "allNames", "f", "resolve", "reader", "match", "option", "signalValue", "observer", "Class", "key", "el", "effect", "mods", "rx", "observer", "classes", "k", "v", "classNames", "cleanup", "className", "kebab", "modifyCasing", "DATASTAR_SSE_EVENT", "DATASTAR", "STARTED", "FINISHED", "ERROR", "RETRYING", "RETRIES_FAILED", "datastarSSEEventWatcher", "eventType", "fn", "event", "argsRaw", "Indicator", "el", "key", "mods", "mergePatch", "value", "signalName", "modifyCasing", "modifyScope", "pathToObj", "watcher", "event", "type", "elt", "STARTED", "FINISHED", "DATASTAR_SSE_EVENT", "JsonSignals", "el", "effect", "value", "filtered", "mods", "spaces", "filters", "jsStrToObject", "callback", "observer", "cleanup", "tagToMs", "args", "arg", "tagHas", "tags", "tag", "defaultValue", "delay", "callback", "wait", "args", "debounce", "leading", "trailing", "timer", "throttle", "waiting", "modifyTiming", "mods", "delayArgs", "tagToMs", "debounceArgs", "tagHas", "throttleArgs", "supportsViewTransitions", "modifyViewTransition", "callback", "mods", "cb", "args", "On", "ctx", "el", "key", "mods", "rx", "target", "callback", "evt", "modifyTiming", "modifyViewTransition", "evtListOpts", "cb", "eventName", "kebab", "modifyCasing", "DATASTAR_SSE_EVENT", "DATASTAR_SIGNAL_PATCH_EVENT", "once", "OnIntersect", "el", "mods", "rx", "callback", "modifyTiming", "modifyViewTransition", "options", "observer", "entries", "entry", "OnInterval", "mods", "rx", "callback", "modifyViewTransition", "duration", "durationArgs", "tagToMs", "tagHas", "intervalId", "OnLoad", "rx", "mods", "mergePatch", "callback", "result", "modifyViewTransition", "wait", "delayArgs", "tagToMs", "delay", "Ref", "el", "key", "mods", "value", "mergePatch", "signalName", "modifyCasing", "modifyScope", "pathToObj", "Scope", "el", "value", "mods", "mergePatch", "scopeKey", "modifyScope", "scopeKeyObj", "acc", "part", "removalObj", "NONE", "DISPLAY", "Show", "el", "effect", "rx", "update", "observer", "cleanup", "Text", "el", "effect", "rx", "update", "observer", "cleanup", "isWrongContent", "err", "dispatchSSE", "type", "el", "argsRaw", "DATASTAR_SSE_EVENT", "setupHeaders", "contentType", "userHeaders", "initialHeaders", "DATASTAR_REQUEST", "sse", "evt", "filtered", "runtimeErr", "method", "url", "selector", "filterSignals", "openWhenHidden", "retryInterval", "DefaultSseRetryDurationMs", "retryScaler", "retryMaxWaitMs", "retryMaxCount", "abort", "action", "cleanupFn", "headers", "urlInstance", "queryParams", "body", "res", "DATASTAR", "formEl", "formData", "submitter", "preventDefault", "name", "multipart", "formParams", "key", "value", "duplex", "STARTED", "performSSERequest", "error", "FINISHED", "options", "signal", "fetchOptions", "retries", "currentRetryInterval", "controller", "visibilityHandler", "cleanup", "attempt", "response", "ERROR", "ct", "kebab", "EventTypePatchElements", "EventTypePatchSignals", "script", "scriptAttributesHeader", "processSSEStream", "retry", "RETRIES_FAILED", "RETRYING", "resolve", "onRetry", "reader", "decoder", "buffer", "done", "lines", "lineIndex", "currentEvent", "dataLines", "line", "retryValue", "dataLine", "spaceIndex", "argsRawJoined", "values", "createHttpMethod", "name", "method", "ctx", "url", "args", "sse", "DELETE", "createHttpMethod", "GET", "createHttpMethod", "PATCH", "createHttpMethod", "POST", "createHttpMethod", "PUT", "createHttpMethod", "PatchElements", "EventTypePatchElements", "ctx", "datastarSSEEventWatcher", "args", "onPatchElements", "elements", "selector", "mode", "DefaultElementPatchMode", "useViewTransition", "template", "node", "type", "initErr", "selectorOrId", "targets", "supportsViewTransitions", "applyToTargets", "element", "capturedTargets", "target", "ElementPatchModeRemove", "ElementPatchModeOuter", "ElementPatchModeInner", "morph", "cloned", "ElementPatchModeReplace", "ElementPatchModePrepend", "ElementPatchModeAppend", "ElementPatchModeBefore", "ElementPatchModeAfter", "elScripts", "old", "script", "name", "value", "oldIdTagNameMap", "ctxIdMap", "ctxPersistentIds", "duplicateIds", "ctxPantry", "oldElt", "newElt", "ignore", "aliasify", "normalizedElt", "oldIdElements", "id", "tagName", "newIdElements", "populateIdMapWithTree", "morphChildren", "oldParent", "newParent", "insertionPoint", "endPoint", "newChild", "bestMatch", "findBestMatch", "cursor", "tempNode", "removeNode", "morphNode", "ncId", "movedChild", "current", "idSet", "moveBefore", "newEmptyChild", "newClonedChild", "startPoint", "nextSibling", "siblingSoftMatchCount", "displaceMatchCount", "nodeMatchCount", "isSoftMatch", "isIdSetMatch", "oldSet", "newSet", "oldNode", "newNode", "oldId", "preserveAttrs", "kebab", "oldAttrs", "i", "bind", "noBind", "key", "newValue", "root", "elt", "PatchSignals", "EventTypePatchSignals", "ctx", "datastarSSEEventWatcher", "raw", "onlyIfMissingRaw", "DefaultPatchSignalsOnlyIfMissing", "jsStrToObject", "isBoolString", "setAlias", "load", "GET", "POST", "PUT", "PATCH", "DELETE", "PatchElements", "PatchSignals", "Attr", "Bind", "Class", "Indicator", "JsonSignals", "On", "OnIntersect", "OnInterval", "OnLoad", "Ref", "Scope", "Show", "Text", "Peek", "SetAll", "ToggleAll", "apply"]
}
